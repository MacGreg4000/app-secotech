
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/binary.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model admintask
 * 
 */
export type admintask = $Result.DefaultSelection<Prisma.$admintaskPayload>
/**
 * Model pret
 * 
 */
export type pret = $Result.DefaultSelection<Prisma.$pretPayload>
/**
 * Model soustraitant
 * 
 */
export type soustraitant = $Result.DefaultSelection<Prisma.$soustraitantPayload>
/**
 * Model contrat
 * 
 */
export type contrat = $Result.DefaultSelection<Prisma.$contratPayload>
/**
 * Model FicheTechnique
 * 
 */
export type FicheTechnique = $Result.DefaultSelection<Prisma.$FicheTechniquePayload>
/**
 * Model Commande
 * 
 */
export type Commande = $Result.DefaultSelection<Prisma.$CommandePayload>
/**
 * Model LigneCommande
 * 
 */
export type LigneCommande = $Result.DefaultSelection<Prisma.$LigneCommandePayload>
/**
 * Model EtatAvancement
 * 
 */
export type EtatAvancement = $Result.DefaultSelection<Prisma.$EtatAvancementPayload>
/**
 * Model LigneEtatAvancement
 * 
 */
export type LigneEtatAvancement = $Result.DefaultSelection<Prisma.$LigneEtatAvancementPayload>
/**
 * Model AvenantEtatAvancement
 * 
 */
export type AvenantEtatAvancement = $Result.DefaultSelection<Prisma.$AvenantEtatAvancementPayload>
/**
 * Model companysettings
 * 
 */
export type companysettings = $Result.DefaultSelection<Prisma.$companysettingsPayload>
/**
 * Model CommandeSousTraitant
 * 
 */
export type CommandeSousTraitant = $Result.DefaultSelection<Prisma.$CommandeSousTraitantPayload>
/**
 * Model LigneCommandeSousTraitant
 * 
 */
export type LigneCommandeSousTraitant = $Result.DefaultSelection<Prisma.$LigneCommandeSousTraitantPayload>
/**
 * Model avenant_soustraitant_etat_avancement
 * 
 */
export type avenant_soustraitant_etat_avancement = $Result.DefaultSelection<Prisma.$avenant_soustraitant_etat_avancementPayload>
/**
 * Model ligne_soustraitant_etat_avancement
 * 
 */
export type ligne_soustraitant_etat_avancement = $Result.DefaultSelection<Prisma.$ligne_soustraitant_etat_avancementPayload>
/**
 * Model soustraitant_etat_avancement
 * 
 */
export type soustraitant_etat_avancement = $Result.DefaultSelection<Prisma.$soustraitant_etat_avancementPayload>
/**
 * Model photo_soustraitant_etat_avancement
 * 
 */
export type photo_soustraitant_etat_avancement = $Result.DefaultSelection<Prisma.$photo_soustraitant_etat_avancementPayload>
/**
 * Model Depense
 * 
 */
export type Depense = $Result.DefaultSelection<Prisma.$DepensePayload>
/**
 * Model UserNotes
 * 
 */
export type UserNotes = $Result.DefaultSelection<Prisma.$UserNotesPayload>
/**
 * Model Rack
 * 
 */
export type Rack = $Result.DefaultSelection<Prisma.$RackPayload>
/**
 * Model Emplacement
 * 
 */
export type Emplacement = $Result.DefaultSelection<Prisma.$EmplacementPayload>
/**
 * Model Materiau
 * 
 */
export type Materiau = $Result.DefaultSelection<Prisma.$MateriauPayload>
/**
 * Model Avenant
 * 
 */
export type Avenant = $Result.DefaultSelection<Prisma.$AvenantPayload>
/**
 * Model Chantier
 * 
 */
export type Chantier = $Result.DefaultSelection<Prisma.$ChantierPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentOuvrier
 * 
 */
export type DocumentOuvrier = $Result.DefaultSelection<Prisma.$DocumentOuvrierPayload>
/**
 * Model Etat
 * 
 */
export type Etat = $Result.DefaultSelection<Prisma.$EtatPayload>
/**
 * Model LigneEtat
 * 
 */
export type LigneEtat = $Result.DefaultSelection<Prisma.$LigneEtatPayload>
/**
 * Model LigneMarche
 * 
 */
export type LigneMarche = $Result.DefaultSelection<Prisma.$LigneMarchePayload>
/**
 * Model Machine
 * 
 */
export type Machine = $Result.DefaultSelection<Prisma.$MachinePayload>
/**
 * Model Marche
 * 
 */
export type Marche = $Result.DefaultSelection<Prisma.$MarchePayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model Ouvrier
 * 
 */
export type Ouvrier = $Result.DefaultSelection<Prisma.$OuvrierPayload>
/**
 * Model Tache
 * 
 */
export type Tache = $Result.DefaultSelection<Prisma.$TachePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BonRegie
 * 
 */
export type BonRegie = $Result.DefaultSelection<Prisma.$BonRegiePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const pret_statut: {
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE'
};

export type pret_statut = (typeof pret_statut)[keyof typeof pret_statut]


export const User_role: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER'
};

export type User_role = (typeof User_role)[keyof typeof User_role]


export const Machine_statut: {
  DISPONIBLE: 'DISPONIBLE',
  PRETE: 'PRETE',
  EN_PANNE: 'EN_PANNE',
  EN_REPARATION: 'EN_REPARATION',
  MANQUE_CONSOMMABLE: 'MANQUE_CONSOMMABLE'
};

export type Machine_statut = (typeof Machine_statut)[keyof typeof Machine_statut]

}

export type pret_statut = $Enums.pret_statut

export const pret_statut: typeof $Enums.pret_statut

export type User_role = $Enums.User_role

export const User_role: typeof $Enums.User_role

export type Machine_statut = $Enums.Machine_statut

export const Machine_statut: typeof $Enums.Machine_statut

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Settings
 * const settings = await prisma.settings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Settings
   * const settings = await prisma.settings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => $Utils.JsPromise<void> : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admintask`: Exposes CRUD operations for the **admintask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admintasks
    * const admintasks = await prisma.admintask.findMany()
    * ```
    */
  get admintask(): Prisma.admintaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pret`: Exposes CRUD operations for the **pret** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prets
    * const prets = await prisma.pret.findMany()
    * ```
    */
  get pret(): Prisma.pretDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soustraitant`: Exposes CRUD operations for the **soustraitant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Soustraitants
    * const soustraitants = await prisma.soustraitant.findMany()
    * ```
    */
  get soustraitant(): Prisma.soustraitantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contrat`: Exposes CRUD operations for the **contrat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contrats
    * const contrats = await prisma.contrat.findMany()
    * ```
    */
  get contrat(): Prisma.contratDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ficheTechnique`: Exposes CRUD operations for the **FicheTechnique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FicheTechniques
    * const ficheTechniques = await prisma.ficheTechnique.findMany()
    * ```
    */
  get ficheTechnique(): Prisma.FicheTechniqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commande`: Exposes CRUD operations for the **Commande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commandes
    * const commandes = await prisma.commande.findMany()
    * ```
    */
  get commande(): Prisma.CommandeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneCommande`: Exposes CRUD operations for the **LigneCommande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneCommandes
    * const ligneCommandes = await prisma.ligneCommande.findMany()
    * ```
    */
  get ligneCommande(): Prisma.LigneCommandeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etatAvancement`: Exposes CRUD operations for the **EtatAvancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EtatAvancements
    * const etatAvancements = await prisma.etatAvancement.findMany()
    * ```
    */
  get etatAvancement(): Prisma.EtatAvancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneEtatAvancement`: Exposes CRUD operations for the **LigneEtatAvancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneEtatAvancements
    * const ligneEtatAvancements = await prisma.ligneEtatAvancement.findMany()
    * ```
    */
  get ligneEtatAvancement(): Prisma.LigneEtatAvancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avenantEtatAvancement`: Exposes CRUD operations for the **AvenantEtatAvancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvenantEtatAvancements
    * const avenantEtatAvancements = await prisma.avenantEtatAvancement.findMany()
    * ```
    */
  get avenantEtatAvancement(): Prisma.AvenantEtatAvancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companysettings`: Exposes CRUD operations for the **companysettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companysettings
    * const companysettings = await prisma.companysettings.findMany()
    * ```
    */
  get companysettings(): Prisma.companysettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commandeSousTraitant`: Exposes CRUD operations for the **CommandeSousTraitant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandeSousTraitants
    * const commandeSousTraitants = await prisma.commandeSousTraitant.findMany()
    * ```
    */
  get commandeSousTraitant(): Prisma.CommandeSousTraitantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneCommandeSousTraitant`: Exposes CRUD operations for the **LigneCommandeSousTraitant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneCommandeSousTraitants
    * const ligneCommandeSousTraitants = await prisma.ligneCommandeSousTraitant.findMany()
    * ```
    */
  get ligneCommandeSousTraitant(): Prisma.LigneCommandeSousTraitantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avenant_soustraitant_etat_avancement`: Exposes CRUD operations for the **avenant_soustraitant_etat_avancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avenant_soustraitant_etat_avancements
    * const avenant_soustraitant_etat_avancements = await prisma.avenant_soustraitant_etat_avancement.findMany()
    * ```
    */
  get avenant_soustraitant_etat_avancement(): Prisma.avenant_soustraitant_etat_avancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligne_soustraitant_etat_avancement`: Exposes CRUD operations for the **ligne_soustraitant_etat_avancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ligne_soustraitant_etat_avancements
    * const ligne_soustraitant_etat_avancements = await prisma.ligne_soustraitant_etat_avancement.findMany()
    * ```
    */
  get ligne_soustraitant_etat_avancement(): Prisma.ligne_soustraitant_etat_avancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soustraitant_etat_avancement`: Exposes CRUD operations for the **soustraitant_etat_avancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Soustraitant_etat_avancements
    * const soustraitant_etat_avancements = await prisma.soustraitant_etat_avancement.findMany()
    * ```
    */
  get soustraitant_etat_avancement(): Prisma.soustraitant_etat_avancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photo_soustraitant_etat_avancement`: Exposes CRUD operations for the **photo_soustraitant_etat_avancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photo_soustraitant_etat_avancements
    * const photo_soustraitant_etat_avancements = await prisma.photo_soustraitant_etat_avancement.findMany()
    * ```
    */
  get photo_soustraitant_etat_avancement(): Prisma.photo_soustraitant_etat_avancementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.depense`: Exposes CRUD operations for the **Depense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Depenses
    * const depenses = await prisma.depense.findMany()
    * ```
    */
  get depense(): Prisma.DepenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNotes`: Exposes CRUD operations for the **UserNotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotes
    * const userNotes = await prisma.userNotes.findMany()
    * ```
    */
  get userNotes(): Prisma.UserNotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rack`: Exposes CRUD operations for the **Rack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Racks
    * const racks = await prisma.rack.findMany()
    * ```
    */
  get rack(): Prisma.RackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emplacement`: Exposes CRUD operations for the **Emplacement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emplacements
    * const emplacements = await prisma.emplacement.findMany()
    * ```
    */
  get emplacement(): Prisma.EmplacementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materiau`: Exposes CRUD operations for the **Materiau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materiaus
    * const materiaus = await prisma.materiau.findMany()
    * ```
    */
  get materiau(): Prisma.MateriauDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avenant`: Exposes CRUD operations for the **Avenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avenants
    * const avenants = await prisma.avenant.findMany()
    * ```
    */
  get avenant(): Prisma.AvenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chantier`: Exposes CRUD operations for the **Chantier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chantiers
    * const chantiers = await prisma.chantier.findMany()
    * ```
    */
  get chantier(): Prisma.ChantierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentOuvrier`: Exposes CRUD operations for the **DocumentOuvrier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentOuvriers
    * const documentOuvriers = await prisma.documentOuvrier.findMany()
    * ```
    */
  get documentOuvrier(): Prisma.DocumentOuvrierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etat`: Exposes CRUD operations for the **Etat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etats
    * const etats = await prisma.etat.findMany()
    * ```
    */
  get etat(): Prisma.EtatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneEtat`: Exposes CRUD operations for the **LigneEtat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneEtats
    * const ligneEtats = await prisma.ligneEtat.findMany()
    * ```
    */
  get ligneEtat(): Prisma.LigneEtatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneMarche`: Exposes CRUD operations for the **LigneMarche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneMarches
    * const ligneMarches = await prisma.ligneMarche.findMany()
    * ```
    */
  get ligneMarche(): Prisma.LigneMarcheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marche`: Exposes CRUD operations for the **Marche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marches
    * const marches = await prisma.marche.findMany()
    * ```
    */
  get marche(): Prisma.MarcheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ouvrier`: Exposes CRUD operations for the **Ouvrier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ouvriers
    * const ouvriers = await prisma.ouvrier.findMany()
    * ```
    */
  get ouvrier(): Prisma.OuvrierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tache`: Exposes CRUD operations for the **Tache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taches
    * const taches = await prisma.tache.findMany()
    * ```
    */
  get tache(): Prisma.TacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bonRegie`: Exposes CRUD operations for the **BonRegie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BonRegies
    * const bonRegies = await prisma.bonRegie.findMany()
    * ```
    */
  get bonRegie(): Prisma.BonRegieDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Settings: 'Settings',
    admintask: 'admintask',
    pret: 'pret',
    soustraitant: 'soustraitant',
    contrat: 'contrat',
    FicheTechnique: 'FicheTechnique',
    Commande: 'Commande',
    LigneCommande: 'LigneCommande',
    EtatAvancement: 'EtatAvancement',
    LigneEtatAvancement: 'LigneEtatAvancement',
    AvenantEtatAvancement: 'AvenantEtatAvancement',
    companysettings: 'companysettings',
    CommandeSousTraitant: 'CommandeSousTraitant',
    LigneCommandeSousTraitant: 'LigneCommandeSousTraitant',
    avenant_soustraitant_etat_avancement: 'avenant_soustraitant_etat_avancement',
    ligne_soustraitant_etat_avancement: 'ligne_soustraitant_etat_avancement',
    soustraitant_etat_avancement: 'soustraitant_etat_avancement',
    photo_soustraitant_etat_avancement: 'photo_soustraitant_etat_avancement',
    Depense: 'Depense',
    UserNotes: 'UserNotes',
    Rack: 'Rack',
    Emplacement: 'Emplacement',
    Materiau: 'Materiau',
    Avenant: 'Avenant',
    Chantier: 'Chantier',
    Client: 'Client',
    Document: 'Document',
    DocumentOuvrier: 'DocumentOuvrier',
    Etat: 'Etat',
    LigneEtat: 'LigneEtat',
    LigneMarche: 'LigneMarche',
    Machine: 'Machine',
    Marche: 'Marche',
    Note: 'Note',
    Ouvrier: 'Ouvrier',
    Tache: 'Tache',
    User: 'User',
    BonRegie: 'BonRegie'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "settings" | "admintask" | "pret" | "soustraitant" | "contrat" | "ficheTechnique" | "commande" | "ligneCommande" | "etatAvancement" | "ligneEtatAvancement" | "avenantEtatAvancement" | "companysettings" | "commandeSousTraitant" | "ligneCommandeSousTraitant" | "avenant_soustraitant_etat_avancement" | "ligne_soustraitant_etat_avancement" | "soustraitant_etat_avancement" | "photo_soustraitant_etat_avancement" | "depense" | "userNotes" | "rack" | "emplacement" | "materiau" | "avenant" | "chantier" | "client" | "document" | "documentOuvrier" | "etat" | "ligneEtat" | "ligneMarche" | "machine" | "marche" | "note" | "ouvrier" | "tache" | "user" | "bonRegie"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      admintask: {
        payload: Prisma.$admintaskPayload<ExtArgs>
        fields: Prisma.admintaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admintaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admintaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>
          }
          findFirst: {
            args: Prisma.admintaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admintaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>
          }
          findMany: {
            args: Prisma.admintaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>[]
          }
          create: {
            args: Prisma.admintaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>
          }
          createMany: {
            args: Prisma.admintaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.admintaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>
          }
          update: {
            args: Prisma.admintaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>
          }
          deleteMany: {
            args: Prisma.admintaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admintaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.admintaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admintaskPayload>
          }
          aggregate: {
            args: Prisma.AdmintaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmintask>
          }
          groupBy: {
            args: Prisma.admintaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmintaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.admintaskCountArgs<ExtArgs>
            result: $Utils.Optional<AdmintaskCountAggregateOutputType> | number
          }
        }
      }
      pret: {
        payload: Prisma.$pretPayload<ExtArgs>
        fields: Prisma.pretFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pretFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pretFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>
          }
          findFirst: {
            args: Prisma.pretFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pretFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>
          }
          findMany: {
            args: Prisma.pretFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>[]
          }
          create: {
            args: Prisma.pretCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>
          }
          createMany: {
            args: Prisma.pretCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pretDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>
          }
          update: {
            args: Prisma.pretUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>
          }
          deleteMany: {
            args: Prisma.pretDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pretUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pretUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pretPayload>
          }
          aggregate: {
            args: Prisma.PretAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePret>
          }
          groupBy: {
            args: Prisma.pretGroupByArgs<ExtArgs>
            result: $Utils.Optional<PretGroupByOutputType>[]
          }
          count: {
            args: Prisma.pretCountArgs<ExtArgs>
            result: $Utils.Optional<PretCountAggregateOutputType> | number
          }
        }
      }
      soustraitant: {
        payload: Prisma.$soustraitantPayload<ExtArgs>
        fields: Prisma.soustraitantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.soustraitantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.soustraitantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>
          }
          findFirst: {
            args: Prisma.soustraitantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.soustraitantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>
          }
          findMany: {
            args: Prisma.soustraitantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>[]
          }
          create: {
            args: Prisma.soustraitantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>
          }
          createMany: {
            args: Prisma.soustraitantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.soustraitantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>
          }
          update: {
            args: Prisma.soustraitantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>
          }
          deleteMany: {
            args: Prisma.soustraitantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.soustraitantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.soustraitantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitantPayload>
          }
          aggregate: {
            args: Prisma.SoustraitantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoustraitant>
          }
          groupBy: {
            args: Prisma.soustraitantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoustraitantGroupByOutputType>[]
          }
          count: {
            args: Prisma.soustraitantCountArgs<ExtArgs>
            result: $Utils.Optional<SoustraitantCountAggregateOutputType> | number
          }
        }
      }
      contrat: {
        payload: Prisma.$contratPayload<ExtArgs>
        fields: Prisma.contratFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contratFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contratFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>
          }
          findFirst: {
            args: Prisma.contratFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contratFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>
          }
          findMany: {
            args: Prisma.contratFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>[]
          }
          create: {
            args: Prisma.contratCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>
          }
          createMany: {
            args: Prisma.contratCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contratDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>
          }
          update: {
            args: Prisma.contratUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>
          }
          deleteMany: {
            args: Prisma.contratDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contratUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contratUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contratPayload>
          }
          aggregate: {
            args: Prisma.ContratAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContrat>
          }
          groupBy: {
            args: Prisma.contratGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContratGroupByOutputType>[]
          }
          count: {
            args: Prisma.contratCountArgs<ExtArgs>
            result: $Utils.Optional<ContratCountAggregateOutputType> | number
          }
        }
      }
      FicheTechnique: {
        payload: Prisma.$FicheTechniquePayload<ExtArgs>
        fields: Prisma.FicheTechniqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FicheTechniqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FicheTechniqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>
          }
          findFirst: {
            args: Prisma.FicheTechniqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FicheTechniqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>
          }
          findMany: {
            args: Prisma.FicheTechniqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>[]
          }
          create: {
            args: Prisma.FicheTechniqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>
          }
          createMany: {
            args: Prisma.FicheTechniqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FicheTechniqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>
          }
          update: {
            args: Prisma.FicheTechniqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>
          }
          deleteMany: {
            args: Prisma.FicheTechniqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FicheTechniqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FicheTechniqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheTechniquePayload>
          }
          aggregate: {
            args: Prisma.FicheTechniqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFicheTechnique>
          }
          groupBy: {
            args: Prisma.FicheTechniqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<FicheTechniqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.FicheTechniqueCountArgs<ExtArgs>
            result: $Utils.Optional<FicheTechniqueCountAggregateOutputType> | number
          }
        }
      }
      Commande: {
        payload: Prisma.$CommandePayload<ExtArgs>
        fields: Prisma.CommandeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          findFirst: {
            args: Prisma.CommandeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          findMany: {
            args: Prisma.CommandeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          create: {
            args: Prisma.CommandeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          createMany: {
            args: Prisma.CommandeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommandeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          update: {
            args: Prisma.CommandeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          deleteMany: {
            args: Prisma.CommandeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommandeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          aggregate: {
            args: Prisma.CommandeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommande>
          }
          groupBy: {
            args: Prisma.CommandeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandeCountArgs<ExtArgs>
            result: $Utils.Optional<CommandeCountAggregateOutputType> | number
          }
        }
      }
      LigneCommande: {
        payload: Prisma.$LigneCommandePayload<ExtArgs>
        fields: Prisma.LigneCommandeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneCommandeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneCommandeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>
          }
          findFirst: {
            args: Prisma.LigneCommandeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneCommandeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>
          }
          findMany: {
            args: Prisma.LigneCommandeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>[]
          }
          create: {
            args: Prisma.LigneCommandeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>
          }
          createMany: {
            args: Prisma.LigneCommandeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LigneCommandeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>
          }
          update: {
            args: Prisma.LigneCommandeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>
          }
          deleteMany: {
            args: Prisma.LigneCommandeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneCommandeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneCommandeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePayload>
          }
          aggregate: {
            args: Prisma.LigneCommandeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneCommande>
          }
          groupBy: {
            args: Prisma.LigneCommandeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneCommandeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneCommandeCountArgs<ExtArgs>
            result: $Utils.Optional<LigneCommandeCountAggregateOutputType> | number
          }
        }
      }
      EtatAvancement: {
        payload: Prisma.$EtatAvancementPayload<ExtArgs>
        fields: Prisma.EtatAvancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtatAvancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtatAvancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>
          }
          findFirst: {
            args: Prisma.EtatAvancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtatAvancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>
          }
          findMany: {
            args: Prisma.EtatAvancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>[]
          }
          create: {
            args: Prisma.EtatAvancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>
          }
          createMany: {
            args: Prisma.EtatAvancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EtatAvancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>
          }
          update: {
            args: Prisma.EtatAvancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>
          }
          deleteMany: {
            args: Prisma.EtatAvancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtatAvancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtatAvancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatAvancementPayload>
          }
          aggregate: {
            args: Prisma.EtatAvancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtatAvancement>
          }
          groupBy: {
            args: Prisma.EtatAvancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtatAvancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtatAvancementCountArgs<ExtArgs>
            result: $Utils.Optional<EtatAvancementCountAggregateOutputType> | number
          }
        }
      }
      LigneEtatAvancement: {
        payload: Prisma.$LigneEtatAvancementPayload<ExtArgs>
        fields: Prisma.LigneEtatAvancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneEtatAvancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneEtatAvancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>
          }
          findFirst: {
            args: Prisma.LigneEtatAvancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneEtatAvancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>
          }
          findMany: {
            args: Prisma.LigneEtatAvancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>[]
          }
          create: {
            args: Prisma.LigneEtatAvancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>
          }
          createMany: {
            args: Prisma.LigneEtatAvancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LigneEtatAvancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>
          }
          update: {
            args: Prisma.LigneEtatAvancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>
          }
          deleteMany: {
            args: Prisma.LigneEtatAvancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneEtatAvancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneEtatAvancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatAvancementPayload>
          }
          aggregate: {
            args: Prisma.LigneEtatAvancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneEtatAvancement>
          }
          groupBy: {
            args: Prisma.LigneEtatAvancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneEtatAvancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneEtatAvancementCountArgs<ExtArgs>
            result: $Utils.Optional<LigneEtatAvancementCountAggregateOutputType> | number
          }
        }
      }
      AvenantEtatAvancement: {
        payload: Prisma.$AvenantEtatAvancementPayload<ExtArgs>
        fields: Prisma.AvenantEtatAvancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvenantEtatAvancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvenantEtatAvancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>
          }
          findFirst: {
            args: Prisma.AvenantEtatAvancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvenantEtatAvancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>
          }
          findMany: {
            args: Prisma.AvenantEtatAvancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>[]
          }
          create: {
            args: Prisma.AvenantEtatAvancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>
          }
          createMany: {
            args: Prisma.AvenantEtatAvancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AvenantEtatAvancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>
          }
          update: {
            args: Prisma.AvenantEtatAvancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>
          }
          deleteMany: {
            args: Prisma.AvenantEtatAvancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvenantEtatAvancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvenantEtatAvancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantEtatAvancementPayload>
          }
          aggregate: {
            args: Prisma.AvenantEtatAvancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvenantEtatAvancement>
          }
          groupBy: {
            args: Prisma.AvenantEtatAvancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvenantEtatAvancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvenantEtatAvancementCountArgs<ExtArgs>
            result: $Utils.Optional<AvenantEtatAvancementCountAggregateOutputType> | number
          }
        }
      }
      companysettings: {
        payload: Prisma.$companysettingsPayload<ExtArgs>
        fields: Prisma.companysettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companysettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companysettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>
          }
          findFirst: {
            args: Prisma.companysettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companysettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>
          }
          findMany: {
            args: Prisma.companysettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>[]
          }
          create: {
            args: Prisma.companysettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>
          }
          createMany: {
            args: Prisma.companysettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.companysettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>
          }
          update: {
            args: Prisma.companysettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>
          }
          deleteMany: {
            args: Prisma.companysettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companysettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.companysettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companysettingsPayload>
          }
          aggregate: {
            args: Prisma.CompanysettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanysettings>
          }
          groupBy: {
            args: Prisma.companysettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanysettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.companysettingsCountArgs<ExtArgs>
            result: $Utils.Optional<CompanysettingsCountAggregateOutputType> | number
          }
        }
      }
      CommandeSousTraitant: {
        payload: Prisma.$CommandeSousTraitantPayload<ExtArgs>
        fields: Prisma.CommandeSousTraitantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandeSousTraitantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandeSousTraitantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>
          }
          findFirst: {
            args: Prisma.CommandeSousTraitantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandeSousTraitantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>
          }
          findMany: {
            args: Prisma.CommandeSousTraitantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>[]
          }
          create: {
            args: Prisma.CommandeSousTraitantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>
          }
          createMany: {
            args: Prisma.CommandeSousTraitantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommandeSousTraitantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>
          }
          update: {
            args: Prisma.CommandeSousTraitantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>
          }
          deleteMany: {
            args: Prisma.CommandeSousTraitantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandeSousTraitantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommandeSousTraitantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandeSousTraitantPayload>
          }
          aggregate: {
            args: Prisma.CommandeSousTraitantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommandeSousTraitant>
          }
          groupBy: {
            args: Prisma.CommandeSousTraitantGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandeSousTraitantGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandeSousTraitantCountArgs<ExtArgs>
            result: $Utils.Optional<CommandeSousTraitantCountAggregateOutputType> | number
          }
        }
      }
      LigneCommandeSousTraitant: {
        payload: Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>
        fields: Prisma.LigneCommandeSousTraitantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneCommandeSousTraitantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneCommandeSousTraitantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>
          }
          findFirst: {
            args: Prisma.LigneCommandeSousTraitantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneCommandeSousTraitantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>
          }
          findMany: {
            args: Prisma.LigneCommandeSousTraitantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>[]
          }
          create: {
            args: Prisma.LigneCommandeSousTraitantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>
          }
          createMany: {
            args: Prisma.LigneCommandeSousTraitantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LigneCommandeSousTraitantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>
          }
          update: {
            args: Prisma.LigneCommandeSousTraitantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>
          }
          deleteMany: {
            args: Prisma.LigneCommandeSousTraitantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneCommandeSousTraitantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneCommandeSousTraitantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandeSousTraitantPayload>
          }
          aggregate: {
            args: Prisma.LigneCommandeSousTraitantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneCommandeSousTraitant>
          }
          groupBy: {
            args: Prisma.LigneCommandeSousTraitantGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneCommandeSousTraitantGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneCommandeSousTraitantCountArgs<ExtArgs>
            result: $Utils.Optional<LigneCommandeSousTraitantCountAggregateOutputType> | number
          }
        }
      }
      avenant_soustraitant_etat_avancement: {
        payload: Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>
        fields: Prisma.avenant_soustraitant_etat_avancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.avenant_soustraitant_etat_avancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.avenant_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>
          }
          findFirst: {
            args: Prisma.avenant_soustraitant_etat_avancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.avenant_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>
          }
          findMany: {
            args: Prisma.avenant_soustraitant_etat_avancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>[]
          }
          create: {
            args: Prisma.avenant_soustraitant_etat_avancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>
          }
          createMany: {
            args: Prisma.avenant_soustraitant_etat_avancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.avenant_soustraitant_etat_avancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>
          }
          update: {
            args: Prisma.avenant_soustraitant_etat_avancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>
          }
          deleteMany: {
            args: Prisma.avenant_soustraitant_etat_avancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.avenant_soustraitant_etat_avancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.avenant_soustraitant_etat_avancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avenant_soustraitant_etat_avancementPayload>
          }
          aggregate: {
            args: Prisma.Avenant_soustraitant_etat_avancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvenant_soustraitant_etat_avancement>
          }
          groupBy: {
            args: Prisma.avenant_soustraitant_etat_avancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Avenant_soustraitant_etat_avancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.avenant_soustraitant_etat_avancementCountArgs<ExtArgs>
            result: $Utils.Optional<Avenant_soustraitant_etat_avancementCountAggregateOutputType> | number
          }
        }
      }
      ligne_soustraitant_etat_avancement: {
        payload: Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>
        fields: Prisma.ligne_soustraitant_etat_avancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ligne_soustraitant_etat_avancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ligne_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>
          }
          findFirst: {
            args: Prisma.ligne_soustraitant_etat_avancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ligne_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>
          }
          findMany: {
            args: Prisma.ligne_soustraitant_etat_avancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>[]
          }
          create: {
            args: Prisma.ligne_soustraitant_etat_avancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>
          }
          createMany: {
            args: Prisma.ligne_soustraitant_etat_avancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ligne_soustraitant_etat_avancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>
          }
          update: {
            args: Prisma.ligne_soustraitant_etat_avancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>
          }
          deleteMany: {
            args: Prisma.ligne_soustraitant_etat_avancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ligne_soustraitant_etat_avancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ligne_soustraitant_etat_avancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ligne_soustraitant_etat_avancementPayload>
          }
          aggregate: {
            args: Prisma.Ligne_soustraitant_etat_avancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigne_soustraitant_etat_avancement>
          }
          groupBy: {
            args: Prisma.ligne_soustraitant_etat_avancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ligne_soustraitant_etat_avancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ligne_soustraitant_etat_avancementCountArgs<ExtArgs>
            result: $Utils.Optional<Ligne_soustraitant_etat_avancementCountAggregateOutputType> | number
          }
        }
      }
      soustraitant_etat_avancement: {
        payload: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>
        fields: Prisma.soustraitant_etat_avancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.soustraitant_etat_avancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>
          }
          findFirst: {
            args: Prisma.soustraitant_etat_avancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>
          }
          findMany: {
            args: Prisma.soustraitant_etat_avancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>[]
          }
          create: {
            args: Prisma.soustraitant_etat_avancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>
          }
          createMany: {
            args: Prisma.soustraitant_etat_avancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.soustraitant_etat_avancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>
          }
          update: {
            args: Prisma.soustraitant_etat_avancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>
          }
          deleteMany: {
            args: Prisma.soustraitant_etat_avancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.soustraitant_etat_avancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.soustraitant_etat_avancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soustraitant_etat_avancementPayload>
          }
          aggregate: {
            args: Prisma.Soustraitant_etat_avancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoustraitant_etat_avancement>
          }
          groupBy: {
            args: Prisma.soustraitant_etat_avancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Soustraitant_etat_avancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.soustraitant_etat_avancementCountArgs<ExtArgs>
            result: $Utils.Optional<Soustraitant_etat_avancementCountAggregateOutputType> | number
          }
        }
      }
      photo_soustraitant_etat_avancement: {
        payload: Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>
        fields: Prisma.photo_soustraitant_etat_avancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.photo_soustraitant_etat_avancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.photo_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>
          }
          findFirst: {
            args: Prisma.photo_soustraitant_etat_avancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.photo_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>
          }
          findMany: {
            args: Prisma.photo_soustraitant_etat_avancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>[]
          }
          create: {
            args: Prisma.photo_soustraitant_etat_avancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>
          }
          createMany: {
            args: Prisma.photo_soustraitant_etat_avancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.photo_soustraitant_etat_avancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>
          }
          update: {
            args: Prisma.photo_soustraitant_etat_avancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>
          }
          deleteMany: {
            args: Prisma.photo_soustraitant_etat_avancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.photo_soustraitant_etat_avancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.photo_soustraitant_etat_avancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$photo_soustraitant_etat_avancementPayload>
          }
          aggregate: {
            args: Prisma.Photo_soustraitant_etat_avancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoto_soustraitant_etat_avancement>
          }
          groupBy: {
            args: Prisma.photo_soustraitant_etat_avancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Photo_soustraitant_etat_avancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.photo_soustraitant_etat_avancementCountArgs<ExtArgs>
            result: $Utils.Optional<Photo_soustraitant_etat_avancementCountAggregateOutputType> | number
          }
        }
      }
      Depense: {
        payload: Prisma.$DepensePayload<ExtArgs>
        fields: Prisma.DepenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>
          }
          findFirst: {
            args: Prisma.DepenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>
          }
          findMany: {
            args: Prisma.DepenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>[]
          }
          create: {
            args: Prisma.DepenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>
          }
          createMany: {
            args: Prisma.DepenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>
          }
          update: {
            args: Prisma.DepenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>
          }
          deleteMany: {
            args: Prisma.DepenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepensePayload>
          }
          aggregate: {
            args: Prisma.DepenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepense>
          }
          groupBy: {
            args: Prisma.DepenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepenseCountArgs<ExtArgs>
            result: $Utils.Optional<DepenseCountAggregateOutputType> | number
          }
        }
      }
      UserNotes: {
        payload: Prisma.$UserNotesPayload<ExtArgs>
        fields: Prisma.UserNotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>
          }
          findFirst: {
            args: Prisma.UserNotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>
          }
          findMany: {
            args: Prisma.UserNotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>[]
          }
          create: {
            args: Prisma.UserNotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>
          }
          createMany: {
            args: Prisma.UserNotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserNotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>
          }
          update: {
            args: Prisma.UserNotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>
          }
          deleteMany: {
            args: Prisma.UserNotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserNotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotesPayload>
          }
          aggregate: {
            args: Prisma.UserNotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotes>
          }
          groupBy: {
            args: Prisma.UserNotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotesCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotesCountAggregateOutputType> | number
          }
        }
      }
      Rack: {
        payload: Prisma.$RackPayload<ExtArgs>
        fields: Prisma.RackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          findFirst: {
            args: Prisma.RackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          findMany: {
            args: Prisma.RackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>[]
          }
          create: {
            args: Prisma.RackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          createMany: {
            args: Prisma.RackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          update: {
            args: Prisma.RackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          deleteMany: {
            args: Prisma.RackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          aggregate: {
            args: Prisma.RackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRack>
          }
          groupBy: {
            args: Prisma.RackGroupByArgs<ExtArgs>
            result: $Utils.Optional<RackGroupByOutputType>[]
          }
          count: {
            args: Prisma.RackCountArgs<ExtArgs>
            result: $Utils.Optional<RackCountAggregateOutputType> | number
          }
        }
      }
      Emplacement: {
        payload: Prisma.$EmplacementPayload<ExtArgs>
        fields: Prisma.EmplacementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmplacementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmplacementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>
          }
          findFirst: {
            args: Prisma.EmplacementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmplacementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>
          }
          findMany: {
            args: Prisma.EmplacementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>[]
          }
          create: {
            args: Prisma.EmplacementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>
          }
          createMany: {
            args: Prisma.EmplacementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmplacementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>
          }
          update: {
            args: Prisma.EmplacementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>
          }
          deleteMany: {
            args: Prisma.EmplacementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmplacementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmplacementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmplacementPayload>
          }
          aggregate: {
            args: Prisma.EmplacementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmplacement>
          }
          groupBy: {
            args: Prisma.EmplacementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmplacementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmplacementCountArgs<ExtArgs>
            result: $Utils.Optional<EmplacementCountAggregateOutputType> | number
          }
        }
      }
      Materiau: {
        payload: Prisma.$MateriauPayload<ExtArgs>
        fields: Prisma.MateriauFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MateriauFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MateriauFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>
          }
          findFirst: {
            args: Prisma.MateriauFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MateriauFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>
          }
          findMany: {
            args: Prisma.MateriauFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>[]
          }
          create: {
            args: Prisma.MateriauCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>
          }
          createMany: {
            args: Prisma.MateriauCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MateriauDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>
          }
          update: {
            args: Prisma.MateriauUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>
          }
          deleteMany: {
            args: Prisma.MateriauDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MateriauUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MateriauUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriauPayload>
          }
          aggregate: {
            args: Prisma.MateriauAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateriau>
          }
          groupBy: {
            args: Prisma.MateriauGroupByArgs<ExtArgs>
            result: $Utils.Optional<MateriauGroupByOutputType>[]
          }
          count: {
            args: Prisma.MateriauCountArgs<ExtArgs>
            result: $Utils.Optional<MateriauCountAggregateOutputType> | number
          }
        }
      }
      Avenant: {
        payload: Prisma.$AvenantPayload<ExtArgs>
        fields: Prisma.AvenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>
          }
          findFirst: {
            args: Prisma.AvenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>
          }
          findMany: {
            args: Prisma.AvenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>[]
          }
          create: {
            args: Prisma.AvenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>
          }
          createMany: {
            args: Prisma.AvenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AvenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>
          }
          update: {
            args: Prisma.AvenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>
          }
          deleteMany: {
            args: Prisma.AvenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvenantPayload>
          }
          aggregate: {
            args: Prisma.AvenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvenant>
          }
          groupBy: {
            args: Prisma.AvenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvenantCountArgs<ExtArgs>
            result: $Utils.Optional<AvenantCountAggregateOutputType> | number
          }
        }
      }
      Chantier: {
        payload: Prisma.$ChantierPayload<ExtArgs>
        fields: Prisma.ChantierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChantierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChantierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>
          }
          findFirst: {
            args: Prisma.ChantierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChantierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>
          }
          findMany: {
            args: Prisma.ChantierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>[]
          }
          create: {
            args: Prisma.ChantierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>
          }
          createMany: {
            args: Prisma.ChantierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChantierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>
          }
          update: {
            args: Prisma.ChantierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>
          }
          deleteMany: {
            args: Prisma.ChantierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChantierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChantierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChantierPayload>
          }
          aggregate: {
            args: Prisma.ChantierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChantier>
          }
          groupBy: {
            args: Prisma.ChantierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChantierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChantierCountArgs<ExtArgs>
            result: $Utils.Optional<ChantierCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentOuvrier: {
        payload: Prisma.$DocumentOuvrierPayload<ExtArgs>
        fields: Prisma.DocumentOuvrierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentOuvrierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentOuvrierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>
          }
          findFirst: {
            args: Prisma.DocumentOuvrierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentOuvrierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>
          }
          findMany: {
            args: Prisma.DocumentOuvrierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>[]
          }
          create: {
            args: Prisma.DocumentOuvrierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>
          }
          createMany: {
            args: Prisma.DocumentOuvrierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentOuvrierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>
          }
          update: {
            args: Prisma.DocumentOuvrierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>
          }
          deleteMany: {
            args: Prisma.DocumentOuvrierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentOuvrierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentOuvrierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentOuvrierPayload>
          }
          aggregate: {
            args: Prisma.DocumentOuvrierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentOuvrier>
          }
          groupBy: {
            args: Prisma.DocumentOuvrierGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentOuvrierGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentOuvrierCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentOuvrierCountAggregateOutputType> | number
          }
        }
      }
      Etat: {
        payload: Prisma.$EtatPayload<ExtArgs>
        fields: Prisma.EtatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>
          }
          findFirst: {
            args: Prisma.EtatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>
          }
          findMany: {
            args: Prisma.EtatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>[]
          }
          create: {
            args: Prisma.EtatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>
          }
          createMany: {
            args: Prisma.EtatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EtatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>
          }
          update: {
            args: Prisma.EtatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>
          }
          deleteMany: {
            args: Prisma.EtatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtatPayload>
          }
          aggregate: {
            args: Prisma.EtatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtat>
          }
          groupBy: {
            args: Prisma.EtatGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtatGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtatCountArgs<ExtArgs>
            result: $Utils.Optional<EtatCountAggregateOutputType> | number
          }
        }
      }
      LigneEtat: {
        payload: Prisma.$LigneEtatPayload<ExtArgs>
        fields: Prisma.LigneEtatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneEtatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneEtatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>
          }
          findFirst: {
            args: Prisma.LigneEtatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneEtatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>
          }
          findMany: {
            args: Prisma.LigneEtatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>[]
          }
          create: {
            args: Prisma.LigneEtatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>
          }
          createMany: {
            args: Prisma.LigneEtatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LigneEtatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>
          }
          update: {
            args: Prisma.LigneEtatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>
          }
          deleteMany: {
            args: Prisma.LigneEtatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneEtatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneEtatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneEtatPayload>
          }
          aggregate: {
            args: Prisma.LigneEtatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneEtat>
          }
          groupBy: {
            args: Prisma.LigneEtatGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneEtatGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneEtatCountArgs<ExtArgs>
            result: $Utils.Optional<LigneEtatCountAggregateOutputType> | number
          }
        }
      }
      LigneMarche: {
        payload: Prisma.$LigneMarchePayload<ExtArgs>
        fields: Prisma.LigneMarcheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneMarcheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneMarcheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>
          }
          findFirst: {
            args: Prisma.LigneMarcheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneMarcheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>
          }
          findMany: {
            args: Prisma.LigneMarcheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>[]
          }
          create: {
            args: Prisma.LigneMarcheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>
          }
          createMany: {
            args: Prisma.LigneMarcheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LigneMarcheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>
          }
          update: {
            args: Prisma.LigneMarcheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>
          }
          deleteMany: {
            args: Prisma.LigneMarcheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneMarcheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneMarcheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneMarchePayload>
          }
          aggregate: {
            args: Prisma.LigneMarcheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneMarche>
          }
          groupBy: {
            args: Prisma.LigneMarcheGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneMarcheGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneMarcheCountArgs<ExtArgs>
            result: $Utils.Optional<LigneMarcheCountAggregateOutputType> | number
          }
        }
      }
      Machine: {
        payload: Prisma.$MachinePayload<ExtArgs>
        fields: Prisma.MachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findFirst: {
            args: Prisma.MachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findMany: {
            args: Prisma.MachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          create: {
            args: Prisma.MachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          createMany: {
            args: Prisma.MachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          update: {
            args: Prisma.MachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          deleteMany: {
            args: Prisma.MachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          aggregate: {
            args: Prisma.MachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachine>
          }
          groupBy: {
            args: Prisma.MachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineCountArgs<ExtArgs>
            result: $Utils.Optional<MachineCountAggregateOutputType> | number
          }
        }
      }
      Marche: {
        payload: Prisma.$MarchePayload<ExtArgs>
        fields: Prisma.MarcheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarcheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarcheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>
          }
          findFirst: {
            args: Prisma.MarcheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarcheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>
          }
          findMany: {
            args: Prisma.MarcheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>[]
          }
          create: {
            args: Prisma.MarcheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>
          }
          createMany: {
            args: Prisma.MarcheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarcheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>
          }
          update: {
            args: Prisma.MarcheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>
          }
          deleteMany: {
            args: Prisma.MarcheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarcheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarcheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchePayload>
          }
          aggregate: {
            args: Prisma.MarcheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarche>
          }
          groupBy: {
            args: Prisma.MarcheGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarcheGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarcheCountArgs<ExtArgs>
            result: $Utils.Optional<MarcheCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      Ouvrier: {
        payload: Prisma.$OuvrierPayload<ExtArgs>
        fields: Prisma.OuvrierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OuvrierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OuvrierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>
          }
          findFirst: {
            args: Prisma.OuvrierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OuvrierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>
          }
          findMany: {
            args: Prisma.OuvrierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>[]
          }
          create: {
            args: Prisma.OuvrierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>
          }
          createMany: {
            args: Prisma.OuvrierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OuvrierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>
          }
          update: {
            args: Prisma.OuvrierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>
          }
          deleteMany: {
            args: Prisma.OuvrierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OuvrierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OuvrierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OuvrierPayload>
          }
          aggregate: {
            args: Prisma.OuvrierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOuvrier>
          }
          groupBy: {
            args: Prisma.OuvrierGroupByArgs<ExtArgs>
            result: $Utils.Optional<OuvrierGroupByOutputType>[]
          }
          count: {
            args: Prisma.OuvrierCountArgs<ExtArgs>
            result: $Utils.Optional<OuvrierCountAggregateOutputType> | number
          }
        }
      }
      Tache: {
        payload: Prisma.$TachePayload<ExtArgs>
        fields: Prisma.TacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>
          }
          findFirst: {
            args: Prisma.TacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>
          }
          findMany: {
            args: Prisma.TacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>[]
          }
          create: {
            args: Prisma.TacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>
          }
          createMany: {
            args: Prisma.TacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>
          }
          update: {
            args: Prisma.TacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>
          }
          deleteMany: {
            args: Prisma.TacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TachePayload>
          }
          aggregate: {
            args: Prisma.TacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTache>
          }
          groupBy: {
            args: Prisma.TacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<TacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.TacheCountArgs<ExtArgs>
            result: $Utils.Optional<TacheCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BonRegie: {
        payload: Prisma.$BonRegiePayload<ExtArgs>
        fields: Prisma.BonRegieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BonRegieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BonRegieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>
          }
          findFirst: {
            args: Prisma.BonRegieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BonRegieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>
          }
          findMany: {
            args: Prisma.BonRegieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>[]
          }
          create: {
            args: Prisma.BonRegieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>
          }
          createMany: {
            args: Prisma.BonRegieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BonRegieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>
          }
          update: {
            args: Prisma.BonRegieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>
          }
          deleteMany: {
            args: Prisma.BonRegieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BonRegieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BonRegieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonRegiePayload>
          }
          aggregate: {
            args: Prisma.BonRegieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBonRegie>
          }
          groupBy: {
            args: Prisma.BonRegieGroupByArgs<ExtArgs>
            result: $Utils.Optional<BonRegieGroupByOutputType>[]
          }
          count: {
            args: Prisma.BonRegieCountArgs<ExtArgs>
            result: $Utils.Optional<BonRegieCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    settings?: SettingsOmit
    admintask?: admintaskOmit
    pret?: pretOmit
    soustraitant?: soustraitantOmit
    contrat?: contratOmit
    ficheTechnique?: FicheTechniqueOmit
    commande?: CommandeOmit
    ligneCommande?: LigneCommandeOmit
    etatAvancement?: EtatAvancementOmit
    ligneEtatAvancement?: LigneEtatAvancementOmit
    avenantEtatAvancement?: AvenantEtatAvancementOmit
    companysettings?: companysettingsOmit
    commandeSousTraitant?: CommandeSousTraitantOmit
    ligneCommandeSousTraitant?: LigneCommandeSousTraitantOmit
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementOmit
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementOmit
    soustraitant_etat_avancement?: soustraitant_etat_avancementOmit
    photo_soustraitant_etat_avancement?: photo_soustraitant_etat_avancementOmit
    depense?: DepenseOmit
    userNotes?: UserNotesOmit
    rack?: RackOmit
    emplacement?: EmplacementOmit
    materiau?: MateriauOmit
    avenant?: AvenantOmit
    chantier?: ChantierOmit
    client?: ClientOmit
    document?: DocumentOmit
    documentOuvrier?: DocumentOuvrierOmit
    etat?: EtatOmit
    ligneEtat?: LigneEtatOmit
    ligneMarche?: LigneMarcheOmit
    machine?: MachineOmit
    marche?: MarcheOmit
    note?: NoteOmit
    ouvrier?: OuvrierOmit
    tache?: TacheOmit
    user?: UserOmit
    bonRegie?: BonRegieOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SoustraitantCountOutputType
   */

  export type SoustraitantCountOutputType = {
    commandes: number
    contrats: number
    soustraitant_etat_avancement: number
  }

  export type SoustraitantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandes?: boolean | SoustraitantCountOutputTypeCountCommandesArgs
    contrats?: boolean | SoustraitantCountOutputTypeCountContratsArgs
    soustraitant_etat_avancement?: boolean | SoustraitantCountOutputTypeCountSoustraitant_etat_avancementArgs
  }

  // Custom InputTypes
  /**
   * SoustraitantCountOutputType without action
   */
  export type SoustraitantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoustraitantCountOutputType
     */
    select?: SoustraitantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SoustraitantCountOutputType without action
   */
  export type SoustraitantCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeSousTraitantWhereInput
  }

  /**
   * SoustraitantCountOutputType without action
   */
  export type SoustraitantCountOutputTypeCountContratsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contratWhereInput
  }

  /**
   * SoustraitantCountOutputType without action
   */
  export type SoustraitantCountOutputTypeCountSoustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soustraitant_etat_avancementWhereInput
  }


  /**
   * Count Type CommandeCountOutputType
   */

  export type CommandeCountOutputType = {
    lignes: number
  }

  export type CommandeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | CommandeCountOutputTypeCountLignesArgs
  }

  // Custom InputTypes
  /**
   * CommandeCountOutputType without action
   */
  export type CommandeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeCountOutputType
     */
    select?: CommandeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandeCountOutputType without action
   */
  export type CommandeCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandeWhereInput
  }


  /**
   * Count Type EtatAvancementCountOutputType
   */

  export type EtatAvancementCountOutputType = {
    avenants: number
    lignes: number
    soustraitant_etat_avancement: number
  }

  export type EtatAvancementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avenants?: boolean | EtatAvancementCountOutputTypeCountAvenantsArgs
    lignes?: boolean | EtatAvancementCountOutputTypeCountLignesArgs
    soustraitant_etat_avancement?: boolean | EtatAvancementCountOutputTypeCountSoustraitant_etat_avancementArgs
  }

  // Custom InputTypes
  /**
   * EtatAvancementCountOutputType without action
   */
  export type EtatAvancementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancementCountOutputType
     */
    select?: EtatAvancementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtatAvancementCountOutputType without action
   */
  export type EtatAvancementCountOutputTypeCountAvenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvenantEtatAvancementWhereInput
  }

  /**
   * EtatAvancementCountOutputType without action
   */
  export type EtatAvancementCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneEtatAvancementWhereInput
  }

  /**
   * EtatAvancementCountOutputType without action
   */
  export type EtatAvancementCountOutputTypeCountSoustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soustraitant_etat_avancementWhereInput
  }


  /**
   * Count Type CommandeSousTraitantCountOutputType
   */

  export type CommandeSousTraitantCountOutputType = {
    lignes: number
    soustraitant_etat_avancement: number
  }

  export type CommandeSousTraitantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | CommandeSousTraitantCountOutputTypeCountLignesArgs
    soustraitant_etat_avancement?: boolean | CommandeSousTraitantCountOutputTypeCountSoustraitant_etat_avancementArgs
  }

  // Custom InputTypes
  /**
   * CommandeSousTraitantCountOutputType without action
   */
  export type CommandeSousTraitantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitantCountOutputType
     */
    select?: CommandeSousTraitantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandeSousTraitantCountOutputType without action
   */
  export type CommandeSousTraitantCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandeSousTraitantWhereInput
  }

  /**
   * CommandeSousTraitantCountOutputType without action
   */
  export type CommandeSousTraitantCountOutputTypeCountSoustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soustraitant_etat_avancementWhereInput
  }


  /**
   * Count Type Soustraitant_etat_avancementCountOutputType
   */

  export type Soustraitant_etat_avancementCountOutputType = {
    avenant_soustraitant_etat_avancement: number
    ligne_soustraitant_etat_avancement: number
    photos: number
  }

  export type Soustraitant_etat_avancementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avenant_soustraitant_etat_avancement?: boolean | Soustraitant_etat_avancementCountOutputTypeCountAvenant_soustraitant_etat_avancementArgs
    ligne_soustraitant_etat_avancement?: boolean | Soustraitant_etat_avancementCountOutputTypeCountLigne_soustraitant_etat_avancementArgs
    photos?: boolean | Soustraitant_etat_avancementCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * Soustraitant_etat_avancementCountOutputType without action
   */
  export type Soustraitant_etat_avancementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soustraitant_etat_avancementCountOutputType
     */
    select?: Soustraitant_etat_avancementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Soustraitant_etat_avancementCountOutputType without action
   */
  export type Soustraitant_etat_avancementCountOutputTypeCountAvenant_soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: avenant_soustraitant_etat_avancementWhereInput
  }

  /**
   * Soustraitant_etat_avancementCountOutputType without action
   */
  export type Soustraitant_etat_avancementCountOutputTypeCountLigne_soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ligne_soustraitant_etat_avancementWhereInput
  }

  /**
   * Soustraitant_etat_avancementCountOutputType without action
   */
  export type Soustraitant_etat_avancementCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photo_soustraitant_etat_avancementWhereInput
  }


  /**
   * Count Type RackCountOutputType
   */

  export type RackCountOutputType = {
    emplacements: number
  }

  export type RackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emplacements?: boolean | RackCountOutputTypeCountEmplacementsArgs
  }

  // Custom InputTypes
  /**
   * RackCountOutputType without action
   */
  export type RackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RackCountOutputType
     */
    select?: RackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RackCountOutputType without action
   */
  export type RackCountOutputTypeCountEmplacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmplacementWhereInput
  }


  /**
   * Count Type EmplacementCountOutputType
   */

  export type EmplacementCountOutputType = {
    materiaux: number
  }

  export type EmplacementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiaux?: boolean | EmplacementCountOutputTypeCountMateriauxArgs
  }

  // Custom InputTypes
  /**
   * EmplacementCountOutputType without action
   */
  export type EmplacementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmplacementCountOutputType
     */
    select?: EmplacementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmplacementCountOutputType without action
   */
  export type EmplacementCountOutputTypeCountMateriauxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriauWhereInput
  }


  /**
   * Count Type ChantierCountOutputType
   */

  export type ChantierCountOutputType = {
    avenants: number
    documents: number
    etats: number
    notes: number
    taches: number
    admintasks: number
    bonsRegie: number
  }

  export type ChantierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avenants?: boolean | ChantierCountOutputTypeCountAvenantsArgs
    documents?: boolean | ChantierCountOutputTypeCountDocumentsArgs
    etats?: boolean | ChantierCountOutputTypeCountEtatsArgs
    notes?: boolean | ChantierCountOutputTypeCountNotesArgs
    taches?: boolean | ChantierCountOutputTypeCountTachesArgs
    admintasks?: boolean | ChantierCountOutputTypeCountAdmintasksArgs
    bonsRegie?: boolean | ChantierCountOutputTypeCountBonsRegieArgs
  }

  // Custom InputTypes
  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChantierCountOutputType
     */
    select?: ChantierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountAvenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvenantWhereInput
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountEtatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtatWhereInput
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountTachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TacheWhereInput
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountAdmintasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admintaskWhereInput
  }

  /**
   * ChantierCountOutputType without action
   */
  export type ChantierCountOutputTypeCountBonsRegieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonRegieWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    Chantier: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chantier?: boolean | ClientCountOutputTypeCountChantierArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountChantierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChantierWhereInput
  }


  /**
   * Count Type EtatCountOutputType
   */

  export type EtatCountOutputType = {
    LigneEtat: number
  }

  export type EtatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LigneEtat?: boolean | EtatCountOutputTypeCountLigneEtatArgs
  }

  // Custom InputTypes
  /**
   * EtatCountOutputType without action
   */
  export type EtatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatCountOutputType
     */
    select?: EtatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtatCountOutputType without action
   */
  export type EtatCountOutputTypeCountLigneEtatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneEtatWhereInput
  }


  /**
   * Count Type LigneMarcheCountOutputType
   */

  export type LigneMarcheCountOutputType = {
    LigneEtat: number
  }

  export type LigneMarcheCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LigneEtat?: boolean | LigneMarcheCountOutputTypeCountLigneEtatArgs
  }

  // Custom InputTypes
  /**
   * LigneMarcheCountOutputType without action
   */
  export type LigneMarcheCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarcheCountOutputType
     */
    select?: LigneMarcheCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LigneMarcheCountOutputType without action
   */
  export type LigneMarcheCountOutputTypeCountLigneEtatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneEtatWhereInput
  }


  /**
   * Count Type MachineCountOutputType
   */

  export type MachineCountOutputType = {
    pret: number
  }

  export type MachineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pret?: boolean | MachineCountOutputTypeCountPretArgs
  }

  // Custom InputTypes
  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineCountOutputType
     */
    select?: MachineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountPretArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pretWhereInput
  }


  /**
   * Count Type MarcheCountOutputType
   */

  export type MarcheCountOutputType = {
    Avenant: number
    LigneMarche: number
  }

  export type MarcheCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Avenant?: boolean | MarcheCountOutputTypeCountAvenantArgs
    LigneMarche?: boolean | MarcheCountOutputTypeCountLigneMarcheArgs
  }

  // Custom InputTypes
  /**
   * MarcheCountOutputType without action
   */
  export type MarcheCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcheCountOutputType
     */
    select?: MarcheCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarcheCountOutputType without action
   */
  export type MarcheCountOutputTypeCountAvenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvenantWhereInput
  }

  /**
   * MarcheCountOutputType without action
   */
  export type MarcheCountOutputTypeCountLigneMarcheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneMarcheWhereInput
  }


  /**
   * Count Type OuvrierCountOutputType
   */

  export type OuvrierCountOutputType = {
    DocumentOuvrier: number
  }

  export type OuvrierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DocumentOuvrier?: boolean | OuvrierCountOutputTypeCountDocumentOuvrierArgs
  }

  // Custom InputTypes
  /**
   * OuvrierCountOutputType without action
   */
  export type OuvrierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OuvrierCountOutputType
     */
    select?: OuvrierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OuvrierCountOutputType without action
   */
  export type OuvrierCountOutputTypeCountDocumentOuvrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentOuvrierWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Document: number
    Note: number
    admintask: number
    pret: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | UserCountOutputTypeCountDocumentArgs
    Note?: boolean | UserCountOutputTypeCountNoteArgs
    admintask?: boolean | UserCountOutputTypeCountAdmintaskArgs
    pret?: boolean | UserCountOutputTypeCountPretArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdmintaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admintaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPretArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pretWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    logo: string | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    logo: string | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    logo: number
    updatedAt: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    logo?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    logo?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    logo?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    logo: string | null
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logo?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>



  export type SettingsSelectScalar = {
    id?: boolean
    logo?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logo" | "updatedAt", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logo: string | null
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */ 
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly logo: FieldRef<"Settings", 'String'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model admintask
   */

  export type AggregateAdmintask = {
    _count: AdmintaskCountAggregateOutputType | null
    _avg: AdmintaskAvgAggregateOutputType | null
    _sum: AdmintaskSumAggregateOutputType | null
    _min: AdmintaskMinAggregateOutputType | null
    _max: AdmintaskMaxAggregateOutputType | null
  }

  export type AdmintaskAvgAggregateOutputType = {
    id: number | null
  }

  export type AdmintaskSumAggregateOutputType = {
    id: number | null
  }

  export type AdmintaskMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    completedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completed: boolean | null
    completedAt: Date | null
    taskType: string | null
    title: string | null
  }

  export type AdmintaskMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    completedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completed: boolean | null
    completedAt: Date | null
    taskType: string | null
    title: string | null
  }

  export type AdmintaskCountAggregateOutputType = {
    id: number
    chantierId: number
    completedBy: number
    createdAt: number
    updatedAt: number
    completed: number
    completedAt: number
    taskType: number
    title: number
    _all: number
  }


  export type AdmintaskAvgAggregateInputType = {
    id?: true
  }

  export type AdmintaskSumAggregateInputType = {
    id?: true
  }

  export type AdmintaskMinAggregateInputType = {
    id?: true
    chantierId?: true
    completedBy?: true
    createdAt?: true
    updatedAt?: true
    completed?: true
    completedAt?: true
    taskType?: true
    title?: true
  }

  export type AdmintaskMaxAggregateInputType = {
    id?: true
    chantierId?: true
    completedBy?: true
    createdAt?: true
    updatedAt?: true
    completed?: true
    completedAt?: true
    taskType?: true
    title?: true
  }

  export type AdmintaskCountAggregateInputType = {
    id?: true
    chantierId?: true
    completedBy?: true
    createdAt?: true
    updatedAt?: true
    completed?: true
    completedAt?: true
    taskType?: true
    title?: true
    _all?: true
  }

  export type AdmintaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admintask to aggregate.
     */
    where?: admintaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admintasks to fetch.
     */
    orderBy?: admintaskOrderByWithRelationInput | admintaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admintaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admintasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admintasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admintasks
    **/
    _count?: true | AdmintaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmintaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmintaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmintaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmintaskMaxAggregateInputType
  }

  export type GetAdmintaskAggregateType<T extends AdmintaskAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmintask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmintask[P]>
      : GetScalarType<T[P], AggregateAdmintask[P]>
  }




  export type admintaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admintaskWhereInput
    orderBy?: admintaskOrderByWithAggregationInput | admintaskOrderByWithAggregationInput[]
    by: AdmintaskScalarFieldEnum[] | AdmintaskScalarFieldEnum
    having?: admintaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmintaskCountAggregateInputType | true
    _avg?: AdmintaskAvgAggregateInputType
    _sum?: AdmintaskSumAggregateInputType
    _min?: AdmintaskMinAggregateInputType
    _max?: AdmintaskMaxAggregateInputType
  }

  export type AdmintaskGroupByOutputType = {
    id: number
    chantierId: string
    completedBy: string | null
    createdAt: Date
    updatedAt: Date
    completed: boolean
    completedAt: Date | null
    taskType: string
    title: string | null
    _count: AdmintaskCountAggregateOutputType | null
    _avg: AdmintaskAvgAggregateOutputType | null
    _sum: AdmintaskSumAggregateOutputType | null
    _min: AdmintaskMinAggregateOutputType | null
    _max: AdmintaskMaxAggregateOutputType | null
  }

  type GetAdmintaskGroupByPayload<T extends admintaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmintaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmintaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmintaskGroupByOutputType[P]>
            : GetScalarType<T[P], AdmintaskGroupByOutputType[P]>
        }
      >
    >


  export type admintaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    completedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completed?: boolean
    completedAt?: boolean
    taskType?: boolean
    title?: boolean
    chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    user?: boolean | admintask$userArgs<ExtArgs>
  }, ExtArgs["result"]["admintask"]>



  export type admintaskSelectScalar = {
    id?: boolean
    chantierId?: boolean
    completedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completed?: boolean
    completedAt?: boolean
    taskType?: boolean
    title?: boolean
  }

  export type admintaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "completedBy" | "createdAt" | "updatedAt" | "completed" | "completedAt" | "taskType" | "title", ExtArgs["result"]["admintask"]>
  export type admintaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    user?: boolean | admintask$userArgs<ExtArgs>
  }

  export type $admintaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admintask"
    objects: {
      chantier: Prisma.$ChantierPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      completedBy: string | null
      createdAt: Date
      updatedAt: Date
      completed: boolean
      completedAt: Date | null
      taskType: string
      title: string | null
    }, ExtArgs["result"]["admintask"]>
    composites: {}
  }

  type admintaskGetPayload<S extends boolean | null | undefined | admintaskDefaultArgs> = $Result.GetResult<Prisma.$admintaskPayload, S>

  type admintaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admintaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmintaskCountAggregateInputType | true
    }

  export interface admintaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admintask'], meta: { name: 'admintask' } }
    /**
     * Find zero or one Admintask that matches the filter.
     * @param {admintaskFindUniqueArgs} args - Arguments to find a Admintask
     * @example
     * // Get one Admintask
     * const admintask = await prisma.admintask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admintaskFindUniqueArgs>(args: SelectSubset<T, admintaskFindUniqueArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admintask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admintaskFindUniqueOrThrowArgs} args - Arguments to find a Admintask
     * @example
     * // Get one Admintask
     * const admintask = await prisma.admintask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admintaskFindUniqueOrThrowArgs>(args: SelectSubset<T, admintaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admintask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admintaskFindFirstArgs} args - Arguments to find a Admintask
     * @example
     * // Get one Admintask
     * const admintask = await prisma.admintask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admintaskFindFirstArgs>(args?: SelectSubset<T, admintaskFindFirstArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admintask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admintaskFindFirstOrThrowArgs} args - Arguments to find a Admintask
     * @example
     * // Get one Admintask
     * const admintask = await prisma.admintask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admintaskFindFirstOrThrowArgs>(args?: SelectSubset<T, admintaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admintasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admintaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admintasks
     * const admintasks = await prisma.admintask.findMany()
     * 
     * // Get first 10 Admintasks
     * const admintasks = await prisma.admintask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admintaskWithIdOnly = await prisma.admintask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admintaskFindManyArgs>(args?: SelectSubset<T, admintaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admintask.
     * @param {admintaskCreateArgs} args - Arguments to create a Admintask.
     * @example
     * // Create one Admintask
     * const Admintask = await prisma.admintask.create({
     *   data: {
     *     // ... data to create a Admintask
     *   }
     * })
     * 
     */
    create<T extends admintaskCreateArgs>(args: SelectSubset<T, admintaskCreateArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admintasks.
     * @param {admintaskCreateManyArgs} args - Arguments to create many Admintasks.
     * @example
     * // Create many Admintasks
     * const admintask = await prisma.admintask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admintaskCreateManyArgs>(args?: SelectSubset<T, admintaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admintask.
     * @param {admintaskDeleteArgs} args - Arguments to delete one Admintask.
     * @example
     * // Delete one Admintask
     * const Admintask = await prisma.admintask.delete({
     *   where: {
     *     // ... filter to delete one Admintask
     *   }
     * })
     * 
     */
    delete<T extends admintaskDeleteArgs>(args: SelectSubset<T, admintaskDeleteArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admintask.
     * @param {admintaskUpdateArgs} args - Arguments to update one Admintask.
     * @example
     * // Update one Admintask
     * const admintask = await prisma.admintask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admintaskUpdateArgs>(args: SelectSubset<T, admintaskUpdateArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admintasks.
     * @param {admintaskDeleteManyArgs} args - Arguments to filter Admintasks to delete.
     * @example
     * // Delete a few Admintasks
     * const { count } = await prisma.admintask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admintaskDeleteManyArgs>(args?: SelectSubset<T, admintaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admintasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admintaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admintasks
     * const admintask = await prisma.admintask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admintaskUpdateManyArgs>(args: SelectSubset<T, admintaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admintask.
     * @param {admintaskUpsertArgs} args - Arguments to update or create a Admintask.
     * @example
     * // Update or create a Admintask
     * const admintask = await prisma.admintask.upsert({
     *   create: {
     *     // ... data to create a Admintask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admintask we want to update
     *   }
     * })
     */
    upsert<T extends admintaskUpsertArgs>(args: SelectSubset<T, admintaskUpsertArgs<ExtArgs>>): Prisma__admintaskClient<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admintasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admintaskCountArgs} args - Arguments to filter Admintasks to count.
     * @example
     * // Count the number of Admintasks
     * const count = await prisma.admintask.count({
     *   where: {
     *     // ... the filter for the Admintasks we want to count
     *   }
     * })
    **/
    count<T extends admintaskCountArgs>(
      args?: Subset<T, admintaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmintaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admintask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmintaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmintaskAggregateArgs>(args: Subset<T, AdmintaskAggregateArgs>): Prisma.PrismaPromise<GetAdmintaskAggregateType<T>>

    /**
     * Group by Admintask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admintaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admintaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admintaskGroupByArgs['orderBy'] }
        : { orderBy?: admintaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admintaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmintaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admintask model
   */
  readonly fields: admintaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admintask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admintaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends admintask$userArgs<ExtArgs> = {}>(args?: Subset<T, admintask$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admintask model
   */ 
  interface admintaskFieldRefs {
    readonly id: FieldRef<"admintask", 'Int'>
    readonly chantierId: FieldRef<"admintask", 'String'>
    readonly completedBy: FieldRef<"admintask", 'String'>
    readonly createdAt: FieldRef<"admintask", 'DateTime'>
    readonly updatedAt: FieldRef<"admintask", 'DateTime'>
    readonly completed: FieldRef<"admintask", 'Boolean'>
    readonly completedAt: FieldRef<"admintask", 'DateTime'>
    readonly taskType: FieldRef<"admintask", 'String'>
    readonly title: FieldRef<"admintask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * admintask findUnique
   */
  export type admintaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * Filter, which admintask to fetch.
     */
    where: admintaskWhereUniqueInput
  }

  /**
   * admintask findUniqueOrThrow
   */
  export type admintaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * Filter, which admintask to fetch.
     */
    where: admintaskWhereUniqueInput
  }

  /**
   * admintask findFirst
   */
  export type admintaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * Filter, which admintask to fetch.
     */
    where?: admintaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admintasks to fetch.
     */
    orderBy?: admintaskOrderByWithRelationInput | admintaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admintasks.
     */
    cursor?: admintaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admintasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admintasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admintasks.
     */
    distinct?: AdmintaskScalarFieldEnum | AdmintaskScalarFieldEnum[]
  }

  /**
   * admintask findFirstOrThrow
   */
  export type admintaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * Filter, which admintask to fetch.
     */
    where?: admintaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admintasks to fetch.
     */
    orderBy?: admintaskOrderByWithRelationInput | admintaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admintasks.
     */
    cursor?: admintaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admintasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admintasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admintasks.
     */
    distinct?: AdmintaskScalarFieldEnum | AdmintaskScalarFieldEnum[]
  }

  /**
   * admintask findMany
   */
  export type admintaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * Filter, which admintasks to fetch.
     */
    where?: admintaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admintasks to fetch.
     */
    orderBy?: admintaskOrderByWithRelationInput | admintaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admintasks.
     */
    cursor?: admintaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admintasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admintasks.
     */
    skip?: number
    distinct?: AdmintaskScalarFieldEnum | AdmintaskScalarFieldEnum[]
  }

  /**
   * admintask create
   */
  export type admintaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * The data needed to create a admintask.
     */
    data: XOR<admintaskCreateInput, admintaskUncheckedCreateInput>
  }

  /**
   * admintask createMany
   */
  export type admintaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admintasks.
     */
    data: admintaskCreateManyInput | admintaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admintask update
   */
  export type admintaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * The data needed to update a admintask.
     */
    data: XOR<admintaskUpdateInput, admintaskUncheckedUpdateInput>
    /**
     * Choose, which admintask to update.
     */
    where: admintaskWhereUniqueInput
  }

  /**
   * admintask updateMany
   */
  export type admintaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admintasks.
     */
    data: XOR<admintaskUpdateManyMutationInput, admintaskUncheckedUpdateManyInput>
    /**
     * Filter which admintasks to update
     */
    where?: admintaskWhereInput
    /**
     * Limit how many admintasks to update.
     */
    limit?: number
  }

  /**
   * admintask upsert
   */
  export type admintaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * The filter to search for the admintask to update in case it exists.
     */
    where: admintaskWhereUniqueInput
    /**
     * In case the admintask found by the `where` argument doesn't exist, create a new admintask with this data.
     */
    create: XOR<admintaskCreateInput, admintaskUncheckedCreateInput>
    /**
     * In case the admintask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admintaskUpdateInput, admintaskUncheckedUpdateInput>
  }

  /**
   * admintask delete
   */
  export type admintaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    /**
     * Filter which admintask to delete.
     */
    where: admintaskWhereUniqueInput
  }

  /**
   * admintask deleteMany
   */
  export type admintaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admintasks to delete
     */
    where?: admintaskWhereInput
    /**
     * Limit how many admintasks to delete.
     */
    limit?: number
  }

  /**
   * admintask.user
   */
  export type admintask$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * admintask without action
   */
  export type admintaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
  }


  /**
   * Model pret
   */

  export type AggregatePret = {
    _count: PretCountAggregateOutputType | null
    _min: PretMinAggregateOutputType | null
    _max: PretMaxAggregateOutputType | null
  }

  export type PretMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    userId: string | null
    datePret: Date | null
    dateRetourPrevue: Date | null
    dateRetourEffective: Date | null
    statut: $Enums.pret_statut | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emprunteur: string | null
  }

  export type PretMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    userId: string | null
    datePret: Date | null
    dateRetourPrevue: Date | null
    dateRetourEffective: Date | null
    statut: $Enums.pret_statut | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emprunteur: string | null
  }

  export type PretCountAggregateOutputType = {
    id: number
    machineId: number
    userId: number
    datePret: number
    dateRetourPrevue: number
    dateRetourEffective: number
    statut: number
    commentaire: number
    createdAt: number
    updatedAt: number
    emprunteur: number
    _all: number
  }


  export type PretMinAggregateInputType = {
    id?: true
    machineId?: true
    userId?: true
    datePret?: true
    dateRetourPrevue?: true
    dateRetourEffective?: true
    statut?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
    emprunteur?: true
  }

  export type PretMaxAggregateInputType = {
    id?: true
    machineId?: true
    userId?: true
    datePret?: true
    dateRetourPrevue?: true
    dateRetourEffective?: true
    statut?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
    emprunteur?: true
  }

  export type PretCountAggregateInputType = {
    id?: true
    machineId?: true
    userId?: true
    datePret?: true
    dateRetourPrevue?: true
    dateRetourEffective?: true
    statut?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
    emprunteur?: true
    _all?: true
  }

  export type PretAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pret to aggregate.
     */
    where?: pretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prets to fetch.
     */
    orderBy?: pretOrderByWithRelationInput | pretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prets
    **/
    _count?: true | PretCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PretMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PretMaxAggregateInputType
  }

  export type GetPretAggregateType<T extends PretAggregateArgs> = {
        [P in keyof T & keyof AggregatePret]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePret[P]>
      : GetScalarType<T[P], AggregatePret[P]>
  }




  export type pretGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pretWhereInput
    orderBy?: pretOrderByWithAggregationInput | pretOrderByWithAggregationInput[]
    by: PretScalarFieldEnum[] | PretScalarFieldEnum
    having?: pretScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PretCountAggregateInputType | true
    _min?: PretMinAggregateInputType
    _max?: PretMaxAggregateInputType
  }

  export type PretGroupByOutputType = {
    id: string
    machineId: string
    userId: string
    datePret: Date
    dateRetourPrevue: Date
    dateRetourEffective: Date | null
    statut: $Enums.pret_statut
    commentaire: string | null
    createdAt: Date
    updatedAt: Date
    emprunteur: string
    _count: PretCountAggregateOutputType | null
    _min: PretMinAggregateOutputType | null
    _max: PretMaxAggregateOutputType | null
  }

  type GetPretGroupByPayload<T extends pretGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PretGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PretGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PretGroupByOutputType[P]>
            : GetScalarType<T[P], PretGroupByOutputType[P]>
        }
      >
    >


  export type pretSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    userId?: boolean
    datePret?: boolean
    dateRetourPrevue?: boolean
    dateRetourEffective?: boolean
    statut?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprunteur?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pret"]>



  export type pretSelectScalar = {
    id?: boolean
    machineId?: boolean
    userId?: boolean
    datePret?: boolean
    dateRetourPrevue?: boolean
    dateRetourEffective?: boolean
    statut?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprunteur?: boolean
  }

  export type pretOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "machineId" | "userId" | "datePret" | "dateRetourPrevue" | "dateRetourEffective" | "statut" | "commentaire" | "createdAt" | "updatedAt" | "emprunteur", ExtArgs["result"]["pret"]>
  export type pretInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $pretPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pret"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string
      userId: string
      datePret: Date
      dateRetourPrevue: Date
      dateRetourEffective: Date | null
      statut: $Enums.pret_statut
      commentaire: string | null
      createdAt: Date
      updatedAt: Date
      emprunteur: string
    }, ExtArgs["result"]["pret"]>
    composites: {}
  }

  type pretGetPayload<S extends boolean | null | undefined | pretDefaultArgs> = $Result.GetResult<Prisma.$pretPayload, S>

  type pretCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pretFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PretCountAggregateInputType | true
    }

  export interface pretDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pret'], meta: { name: 'pret' } }
    /**
     * Find zero or one Pret that matches the filter.
     * @param {pretFindUniqueArgs} args - Arguments to find a Pret
     * @example
     * // Get one Pret
     * const pret = await prisma.pret.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pretFindUniqueArgs>(args: SelectSubset<T, pretFindUniqueArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pret that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pretFindUniqueOrThrowArgs} args - Arguments to find a Pret
     * @example
     * // Get one Pret
     * const pret = await prisma.pret.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pretFindUniqueOrThrowArgs>(args: SelectSubset<T, pretFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pret that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pretFindFirstArgs} args - Arguments to find a Pret
     * @example
     * // Get one Pret
     * const pret = await prisma.pret.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pretFindFirstArgs>(args?: SelectSubset<T, pretFindFirstArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pret that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pretFindFirstOrThrowArgs} args - Arguments to find a Pret
     * @example
     * // Get one Pret
     * const pret = await prisma.pret.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pretFindFirstOrThrowArgs>(args?: SelectSubset<T, pretFindFirstOrThrowArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pretFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prets
     * const prets = await prisma.pret.findMany()
     * 
     * // Get first 10 Prets
     * const prets = await prisma.pret.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pretWithIdOnly = await prisma.pret.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pretFindManyArgs>(args?: SelectSubset<T, pretFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pret.
     * @param {pretCreateArgs} args - Arguments to create a Pret.
     * @example
     * // Create one Pret
     * const Pret = await prisma.pret.create({
     *   data: {
     *     // ... data to create a Pret
     *   }
     * })
     * 
     */
    create<T extends pretCreateArgs>(args: SelectSubset<T, pretCreateArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prets.
     * @param {pretCreateManyArgs} args - Arguments to create many Prets.
     * @example
     * // Create many Prets
     * const pret = await prisma.pret.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pretCreateManyArgs>(args?: SelectSubset<T, pretCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pret.
     * @param {pretDeleteArgs} args - Arguments to delete one Pret.
     * @example
     * // Delete one Pret
     * const Pret = await prisma.pret.delete({
     *   where: {
     *     // ... filter to delete one Pret
     *   }
     * })
     * 
     */
    delete<T extends pretDeleteArgs>(args: SelectSubset<T, pretDeleteArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pret.
     * @param {pretUpdateArgs} args - Arguments to update one Pret.
     * @example
     * // Update one Pret
     * const pret = await prisma.pret.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pretUpdateArgs>(args: SelectSubset<T, pretUpdateArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prets.
     * @param {pretDeleteManyArgs} args - Arguments to filter Prets to delete.
     * @example
     * // Delete a few Prets
     * const { count } = await prisma.pret.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pretDeleteManyArgs>(args?: SelectSubset<T, pretDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pretUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prets
     * const pret = await prisma.pret.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pretUpdateManyArgs>(args: SelectSubset<T, pretUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pret.
     * @param {pretUpsertArgs} args - Arguments to update or create a Pret.
     * @example
     * // Update or create a Pret
     * const pret = await prisma.pret.upsert({
     *   create: {
     *     // ... data to create a Pret
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pret we want to update
     *   }
     * })
     */
    upsert<T extends pretUpsertArgs>(args: SelectSubset<T, pretUpsertArgs<ExtArgs>>): Prisma__pretClient<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pretCountArgs} args - Arguments to filter Prets to count.
     * @example
     * // Count the number of Prets
     * const count = await prisma.pret.count({
     *   where: {
     *     // ... the filter for the Prets we want to count
     *   }
     * })
    **/
    count<T extends pretCountArgs>(
      args?: Subset<T, pretCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PretCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pret.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PretAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PretAggregateArgs>(args: Subset<T, PretAggregateArgs>): Prisma.PrismaPromise<GetPretAggregateType<T>>

    /**
     * Group by Pret.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pretGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pretGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pretGroupByArgs['orderBy'] }
        : { orderBy?: pretGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pretGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPretGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pret model
   */
  readonly fields: pretFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pret.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pretClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pret model
   */ 
  interface pretFieldRefs {
    readonly id: FieldRef<"pret", 'String'>
    readonly machineId: FieldRef<"pret", 'String'>
    readonly userId: FieldRef<"pret", 'String'>
    readonly datePret: FieldRef<"pret", 'DateTime'>
    readonly dateRetourPrevue: FieldRef<"pret", 'DateTime'>
    readonly dateRetourEffective: FieldRef<"pret", 'DateTime'>
    readonly statut: FieldRef<"pret", 'pret_statut'>
    readonly commentaire: FieldRef<"pret", 'String'>
    readonly createdAt: FieldRef<"pret", 'DateTime'>
    readonly updatedAt: FieldRef<"pret", 'DateTime'>
    readonly emprunteur: FieldRef<"pret", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pret findUnique
   */
  export type pretFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * Filter, which pret to fetch.
     */
    where: pretWhereUniqueInput
  }

  /**
   * pret findUniqueOrThrow
   */
  export type pretFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * Filter, which pret to fetch.
     */
    where: pretWhereUniqueInput
  }

  /**
   * pret findFirst
   */
  export type pretFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * Filter, which pret to fetch.
     */
    where?: pretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prets to fetch.
     */
    orderBy?: pretOrderByWithRelationInput | pretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prets.
     */
    cursor?: pretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prets.
     */
    distinct?: PretScalarFieldEnum | PretScalarFieldEnum[]
  }

  /**
   * pret findFirstOrThrow
   */
  export type pretFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * Filter, which pret to fetch.
     */
    where?: pretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prets to fetch.
     */
    orderBy?: pretOrderByWithRelationInput | pretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prets.
     */
    cursor?: pretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prets.
     */
    distinct?: PretScalarFieldEnum | PretScalarFieldEnum[]
  }

  /**
   * pret findMany
   */
  export type pretFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * Filter, which prets to fetch.
     */
    where?: pretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prets to fetch.
     */
    orderBy?: pretOrderByWithRelationInput | pretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prets.
     */
    cursor?: pretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prets.
     */
    skip?: number
    distinct?: PretScalarFieldEnum | PretScalarFieldEnum[]
  }

  /**
   * pret create
   */
  export type pretCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * The data needed to create a pret.
     */
    data: XOR<pretCreateInput, pretUncheckedCreateInput>
  }

  /**
   * pret createMany
   */
  export type pretCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prets.
     */
    data: pretCreateManyInput | pretCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pret update
   */
  export type pretUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * The data needed to update a pret.
     */
    data: XOR<pretUpdateInput, pretUncheckedUpdateInput>
    /**
     * Choose, which pret to update.
     */
    where: pretWhereUniqueInput
  }

  /**
   * pret updateMany
   */
  export type pretUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prets.
     */
    data: XOR<pretUpdateManyMutationInput, pretUncheckedUpdateManyInput>
    /**
     * Filter which prets to update
     */
    where?: pretWhereInput
    /**
     * Limit how many prets to update.
     */
    limit?: number
  }

  /**
   * pret upsert
   */
  export type pretUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * The filter to search for the pret to update in case it exists.
     */
    where: pretWhereUniqueInput
    /**
     * In case the pret found by the `where` argument doesn't exist, create a new pret with this data.
     */
    create: XOR<pretCreateInput, pretUncheckedCreateInput>
    /**
     * In case the pret was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pretUpdateInput, pretUncheckedUpdateInput>
  }

  /**
   * pret delete
   */
  export type pretDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    /**
     * Filter which pret to delete.
     */
    where: pretWhereUniqueInput
  }

  /**
   * pret deleteMany
   */
  export type pretDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prets to delete
     */
    where?: pretWhereInput
    /**
     * Limit how many prets to delete.
     */
    limit?: number
  }

  /**
   * pret without action
   */
  export type pretDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
  }


  /**
   * Model soustraitant
   */

  export type AggregateSoustraitant = {
    _count: SoustraitantCountAggregateOutputType | null
    _min: SoustraitantMinAggregateOutputType | null
    _max: SoustraitantMaxAggregateOutputType | null
  }

  export type SoustraitantMinAggregateOutputType = {
    id: string | null
    nom: string | null
    email: string | null
    contact: string | null
    adresse: string | null
    telephone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tva: string | null
  }

  export type SoustraitantMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    email: string | null
    contact: string | null
    adresse: string | null
    telephone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tva: string | null
  }

  export type SoustraitantCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    contact: number
    adresse: number
    telephone: number
    createdAt: number
    updatedAt: number
    tva: number
    _all: number
  }


  export type SoustraitantMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    contact?: true
    adresse?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
    tva?: true
  }

  export type SoustraitantMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    contact?: true
    adresse?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
    tva?: true
  }

  export type SoustraitantCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    contact?: true
    adresse?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
    tva?: true
    _all?: true
  }

  export type SoustraitantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which soustraitant to aggregate.
     */
    where?: soustraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitants to fetch.
     */
    orderBy?: soustraitantOrderByWithRelationInput | soustraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: soustraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned soustraitants
    **/
    _count?: true | SoustraitantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoustraitantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoustraitantMaxAggregateInputType
  }

  export type GetSoustraitantAggregateType<T extends SoustraitantAggregateArgs> = {
        [P in keyof T & keyof AggregateSoustraitant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoustraitant[P]>
      : GetScalarType<T[P], AggregateSoustraitant[P]>
  }




  export type soustraitantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soustraitantWhereInput
    orderBy?: soustraitantOrderByWithAggregationInput | soustraitantOrderByWithAggregationInput[]
    by: SoustraitantScalarFieldEnum[] | SoustraitantScalarFieldEnum
    having?: soustraitantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoustraitantCountAggregateInputType | true
    _min?: SoustraitantMinAggregateInputType
    _max?: SoustraitantMaxAggregateInputType
  }

  export type SoustraitantGroupByOutputType = {
    id: string
    nom: string
    email: string
    contact: string | null
    adresse: string | null
    telephone: string | null
    createdAt: Date
    updatedAt: Date
    tva: string | null
    _count: SoustraitantCountAggregateOutputType | null
    _min: SoustraitantMinAggregateOutputType | null
    _max: SoustraitantMaxAggregateOutputType | null
  }

  type GetSoustraitantGroupByPayload<T extends soustraitantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoustraitantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoustraitantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoustraitantGroupByOutputType[P]>
            : GetScalarType<T[P], SoustraitantGroupByOutputType[P]>
        }
      >
    >


  export type soustraitantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    contact?: boolean
    adresse?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tva?: boolean
    commandes?: boolean | soustraitant$commandesArgs<ExtArgs>
    contrats?: boolean | soustraitant$contratsArgs<ExtArgs>
    soustraitant_etat_avancement?: boolean | soustraitant$soustraitant_etat_avancementArgs<ExtArgs>
    _count?: boolean | SoustraitantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soustraitant"]>



  export type soustraitantSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    contact?: boolean
    adresse?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tva?: boolean
  }

  export type soustraitantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "email" | "contact" | "adresse" | "telephone" | "createdAt" | "updatedAt" | "tva", ExtArgs["result"]["soustraitant"]>
  export type soustraitantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandes?: boolean | soustraitant$commandesArgs<ExtArgs>
    contrats?: boolean | soustraitant$contratsArgs<ExtArgs>
    soustraitant_etat_avancement?: boolean | soustraitant$soustraitant_etat_avancementArgs<ExtArgs>
    _count?: boolean | SoustraitantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $soustraitantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "soustraitant"
    objects: {
      commandes: Prisma.$CommandeSousTraitantPayload<ExtArgs>[]
      contrats: Prisma.$contratPayload<ExtArgs>[]
      soustraitant_etat_avancement: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      email: string
      contact: string | null
      adresse: string | null
      telephone: string | null
      createdAt: Date
      updatedAt: Date
      tva: string | null
    }, ExtArgs["result"]["soustraitant"]>
    composites: {}
  }

  type soustraitantGetPayload<S extends boolean | null | undefined | soustraitantDefaultArgs> = $Result.GetResult<Prisma.$soustraitantPayload, S>

  type soustraitantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<soustraitantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SoustraitantCountAggregateInputType | true
    }

  export interface soustraitantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['soustraitant'], meta: { name: 'soustraitant' } }
    /**
     * Find zero or one Soustraitant that matches the filter.
     * @param {soustraitantFindUniqueArgs} args - Arguments to find a Soustraitant
     * @example
     * // Get one Soustraitant
     * const soustraitant = await prisma.soustraitant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends soustraitantFindUniqueArgs>(args: SelectSubset<T, soustraitantFindUniqueArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Soustraitant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {soustraitantFindUniqueOrThrowArgs} args - Arguments to find a Soustraitant
     * @example
     * // Get one Soustraitant
     * const soustraitant = await prisma.soustraitant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends soustraitantFindUniqueOrThrowArgs>(args: SelectSubset<T, soustraitantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Soustraitant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitantFindFirstArgs} args - Arguments to find a Soustraitant
     * @example
     * // Get one Soustraitant
     * const soustraitant = await prisma.soustraitant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends soustraitantFindFirstArgs>(args?: SelectSubset<T, soustraitantFindFirstArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Soustraitant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitantFindFirstOrThrowArgs} args - Arguments to find a Soustraitant
     * @example
     * // Get one Soustraitant
     * const soustraitant = await prisma.soustraitant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends soustraitantFindFirstOrThrowArgs>(args?: SelectSubset<T, soustraitantFindFirstOrThrowArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Soustraitants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Soustraitants
     * const soustraitants = await prisma.soustraitant.findMany()
     * 
     * // Get first 10 Soustraitants
     * const soustraitants = await prisma.soustraitant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soustraitantWithIdOnly = await prisma.soustraitant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends soustraitantFindManyArgs>(args?: SelectSubset<T, soustraitantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Soustraitant.
     * @param {soustraitantCreateArgs} args - Arguments to create a Soustraitant.
     * @example
     * // Create one Soustraitant
     * const Soustraitant = await prisma.soustraitant.create({
     *   data: {
     *     // ... data to create a Soustraitant
     *   }
     * })
     * 
     */
    create<T extends soustraitantCreateArgs>(args: SelectSubset<T, soustraitantCreateArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Soustraitants.
     * @param {soustraitantCreateManyArgs} args - Arguments to create many Soustraitants.
     * @example
     * // Create many Soustraitants
     * const soustraitant = await prisma.soustraitant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends soustraitantCreateManyArgs>(args?: SelectSubset<T, soustraitantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Soustraitant.
     * @param {soustraitantDeleteArgs} args - Arguments to delete one Soustraitant.
     * @example
     * // Delete one Soustraitant
     * const Soustraitant = await prisma.soustraitant.delete({
     *   where: {
     *     // ... filter to delete one Soustraitant
     *   }
     * })
     * 
     */
    delete<T extends soustraitantDeleteArgs>(args: SelectSubset<T, soustraitantDeleteArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Soustraitant.
     * @param {soustraitantUpdateArgs} args - Arguments to update one Soustraitant.
     * @example
     * // Update one Soustraitant
     * const soustraitant = await prisma.soustraitant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends soustraitantUpdateArgs>(args: SelectSubset<T, soustraitantUpdateArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Soustraitants.
     * @param {soustraitantDeleteManyArgs} args - Arguments to filter Soustraitants to delete.
     * @example
     * // Delete a few Soustraitants
     * const { count } = await prisma.soustraitant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends soustraitantDeleteManyArgs>(args?: SelectSubset<T, soustraitantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Soustraitants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Soustraitants
     * const soustraitant = await prisma.soustraitant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends soustraitantUpdateManyArgs>(args: SelectSubset<T, soustraitantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Soustraitant.
     * @param {soustraitantUpsertArgs} args - Arguments to update or create a Soustraitant.
     * @example
     * // Update or create a Soustraitant
     * const soustraitant = await prisma.soustraitant.upsert({
     *   create: {
     *     // ... data to create a Soustraitant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Soustraitant we want to update
     *   }
     * })
     */
    upsert<T extends soustraitantUpsertArgs>(args: SelectSubset<T, soustraitantUpsertArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Soustraitants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitantCountArgs} args - Arguments to filter Soustraitants to count.
     * @example
     * // Count the number of Soustraitants
     * const count = await prisma.soustraitant.count({
     *   where: {
     *     // ... the filter for the Soustraitants we want to count
     *   }
     * })
    **/
    count<T extends soustraitantCountArgs>(
      args?: Subset<T, soustraitantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoustraitantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Soustraitant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoustraitantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoustraitantAggregateArgs>(args: Subset<T, SoustraitantAggregateArgs>): Prisma.PrismaPromise<GetSoustraitantAggregateType<T>>

    /**
     * Group by Soustraitant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends soustraitantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: soustraitantGroupByArgs['orderBy'] }
        : { orderBy?: soustraitantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, soustraitantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoustraitantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the soustraitant model
   */
  readonly fields: soustraitantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for soustraitant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__soustraitantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commandes<T extends soustraitant$commandesArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contrats<T extends soustraitant$contratsArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant$contratsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soustraitant_etat_avancement<T extends soustraitant$soustraitant_etat_avancementArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant$soustraitant_etat_avancementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the soustraitant model
   */ 
  interface soustraitantFieldRefs {
    readonly id: FieldRef<"soustraitant", 'String'>
    readonly nom: FieldRef<"soustraitant", 'String'>
    readonly email: FieldRef<"soustraitant", 'String'>
    readonly contact: FieldRef<"soustraitant", 'String'>
    readonly adresse: FieldRef<"soustraitant", 'String'>
    readonly telephone: FieldRef<"soustraitant", 'String'>
    readonly createdAt: FieldRef<"soustraitant", 'DateTime'>
    readonly updatedAt: FieldRef<"soustraitant", 'DateTime'>
    readonly tva: FieldRef<"soustraitant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * soustraitant findUnique
   */
  export type soustraitantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant to fetch.
     */
    where: soustraitantWhereUniqueInput
  }

  /**
   * soustraitant findUniqueOrThrow
   */
  export type soustraitantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant to fetch.
     */
    where: soustraitantWhereUniqueInput
  }

  /**
   * soustraitant findFirst
   */
  export type soustraitantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant to fetch.
     */
    where?: soustraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitants to fetch.
     */
    orderBy?: soustraitantOrderByWithRelationInput | soustraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for soustraitants.
     */
    cursor?: soustraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of soustraitants.
     */
    distinct?: SoustraitantScalarFieldEnum | SoustraitantScalarFieldEnum[]
  }

  /**
   * soustraitant findFirstOrThrow
   */
  export type soustraitantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant to fetch.
     */
    where?: soustraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitants to fetch.
     */
    orderBy?: soustraitantOrderByWithRelationInput | soustraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for soustraitants.
     */
    cursor?: soustraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of soustraitants.
     */
    distinct?: SoustraitantScalarFieldEnum | SoustraitantScalarFieldEnum[]
  }

  /**
   * soustraitant findMany
   */
  export type soustraitantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * Filter, which soustraitants to fetch.
     */
    where?: soustraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitants to fetch.
     */
    orderBy?: soustraitantOrderByWithRelationInput | soustraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing soustraitants.
     */
    cursor?: soustraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitants.
     */
    skip?: number
    distinct?: SoustraitantScalarFieldEnum | SoustraitantScalarFieldEnum[]
  }

  /**
   * soustraitant create
   */
  export type soustraitantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * The data needed to create a soustraitant.
     */
    data: XOR<soustraitantCreateInput, soustraitantUncheckedCreateInput>
  }

  /**
   * soustraitant createMany
   */
  export type soustraitantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many soustraitants.
     */
    data: soustraitantCreateManyInput | soustraitantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * soustraitant update
   */
  export type soustraitantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * The data needed to update a soustraitant.
     */
    data: XOR<soustraitantUpdateInput, soustraitantUncheckedUpdateInput>
    /**
     * Choose, which soustraitant to update.
     */
    where: soustraitantWhereUniqueInput
  }

  /**
   * soustraitant updateMany
   */
  export type soustraitantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update soustraitants.
     */
    data: XOR<soustraitantUpdateManyMutationInput, soustraitantUncheckedUpdateManyInput>
    /**
     * Filter which soustraitants to update
     */
    where?: soustraitantWhereInput
    /**
     * Limit how many soustraitants to update.
     */
    limit?: number
  }

  /**
   * soustraitant upsert
   */
  export type soustraitantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * The filter to search for the soustraitant to update in case it exists.
     */
    where: soustraitantWhereUniqueInput
    /**
     * In case the soustraitant found by the `where` argument doesn't exist, create a new soustraitant with this data.
     */
    create: XOR<soustraitantCreateInput, soustraitantUncheckedCreateInput>
    /**
     * In case the soustraitant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<soustraitantUpdateInput, soustraitantUncheckedUpdateInput>
  }

  /**
   * soustraitant delete
   */
  export type soustraitantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
    /**
     * Filter which soustraitant to delete.
     */
    where: soustraitantWhereUniqueInput
  }

  /**
   * soustraitant deleteMany
   */
  export type soustraitantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which soustraitants to delete
     */
    where?: soustraitantWhereInput
    /**
     * Limit how many soustraitants to delete.
     */
    limit?: number
  }

  /**
   * soustraitant.commandes
   */
  export type soustraitant$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    where?: CommandeSousTraitantWhereInput
    orderBy?: CommandeSousTraitantOrderByWithRelationInput | CommandeSousTraitantOrderByWithRelationInput[]
    cursor?: CommandeSousTraitantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeSousTraitantScalarFieldEnum | CommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * soustraitant.contrats
   */
  export type soustraitant$contratsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    where?: contratWhereInput
    orderBy?: contratOrderByWithRelationInput | contratOrderByWithRelationInput[]
    cursor?: contratWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * soustraitant.soustraitant_etat_avancement
   */
  export type soustraitant$soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    where?: soustraitant_etat_avancementWhereInput
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Soustraitant_etat_avancementScalarFieldEnum | Soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant without action
   */
  export type soustraitantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant
     */
    select?: soustraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant
     */
    omit?: soustraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitantInclude<ExtArgs> | null
  }


  /**
   * Model contrat
   */

  export type AggregateContrat = {
    _count: ContratCountAggregateOutputType | null
    _min: ContratMinAggregateOutputType | null
    _max: ContratMaxAggregateOutputType | null
  }

  export type ContratMinAggregateOutputType = {
    id: string | null
    soustraitantId: string | null
    url: string | null
    dateGeneration: Date | null
    dateSignature: Date | null
    estSigne: boolean | null
    token: string | null
  }

  export type ContratMaxAggregateOutputType = {
    id: string | null
    soustraitantId: string | null
    url: string | null
    dateGeneration: Date | null
    dateSignature: Date | null
    estSigne: boolean | null
    token: string | null
  }

  export type ContratCountAggregateOutputType = {
    id: number
    soustraitantId: number
    url: number
    dateGeneration: number
    dateSignature: number
    estSigne: number
    token: number
    _all: number
  }


  export type ContratMinAggregateInputType = {
    id?: true
    soustraitantId?: true
    url?: true
    dateGeneration?: true
    dateSignature?: true
    estSigne?: true
    token?: true
  }

  export type ContratMaxAggregateInputType = {
    id?: true
    soustraitantId?: true
    url?: true
    dateGeneration?: true
    dateSignature?: true
    estSigne?: true
    token?: true
  }

  export type ContratCountAggregateInputType = {
    id?: true
    soustraitantId?: true
    url?: true
    dateGeneration?: true
    dateSignature?: true
    estSigne?: true
    token?: true
    _all?: true
  }

  export type ContratAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contrat to aggregate.
     */
    where?: contratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contrats to fetch.
     */
    orderBy?: contratOrderByWithRelationInput | contratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contrats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contrats
    **/
    _count?: true | ContratCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratMaxAggregateInputType
  }

  export type GetContratAggregateType<T extends ContratAggregateArgs> = {
        [P in keyof T & keyof AggregateContrat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContrat[P]>
      : GetScalarType<T[P], AggregateContrat[P]>
  }




  export type contratGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contratWhereInput
    orderBy?: contratOrderByWithAggregationInput | contratOrderByWithAggregationInput[]
    by: ContratScalarFieldEnum[] | ContratScalarFieldEnum
    having?: contratScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratCountAggregateInputType | true
    _min?: ContratMinAggregateInputType
    _max?: ContratMaxAggregateInputType
  }

  export type ContratGroupByOutputType = {
    id: string
    soustraitantId: string
    url: string
    dateGeneration: Date
    dateSignature: Date | null
    estSigne: boolean
    token: string | null
    _count: ContratCountAggregateOutputType | null
    _min: ContratMinAggregateOutputType | null
    _max: ContratMaxAggregateOutputType | null
  }

  type GetContratGroupByPayload<T extends contratGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratGroupByOutputType[P]>
            : GetScalarType<T[P], ContratGroupByOutputType[P]>
        }
      >
    >


  export type contratSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    soustraitantId?: boolean
    url?: boolean
    dateGeneration?: boolean
    dateSignature?: boolean
    estSigne?: boolean
    token?: boolean
    soustraitant?: boolean | soustraitantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contrat"]>



  export type contratSelectScalar = {
    id?: boolean
    soustraitantId?: boolean
    url?: boolean
    dateGeneration?: boolean
    dateSignature?: boolean
    estSigne?: boolean
    token?: boolean
  }

  export type contratOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "soustraitantId" | "url" | "dateGeneration" | "dateSignature" | "estSigne" | "token", ExtArgs["result"]["contrat"]>
  export type contratInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soustraitant?: boolean | soustraitantDefaultArgs<ExtArgs>
  }

  export type $contratPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contrat"
    objects: {
      soustraitant: Prisma.$soustraitantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      soustraitantId: string
      url: string
      dateGeneration: Date
      dateSignature: Date | null
      estSigne: boolean
      token: string | null
    }, ExtArgs["result"]["contrat"]>
    composites: {}
  }

  type contratGetPayload<S extends boolean | null | undefined | contratDefaultArgs> = $Result.GetResult<Prisma.$contratPayload, S>

  type contratCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contratFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContratCountAggregateInputType | true
    }

  export interface contratDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contrat'], meta: { name: 'contrat' } }
    /**
     * Find zero or one Contrat that matches the filter.
     * @param {contratFindUniqueArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contratFindUniqueArgs>(args: SelectSubset<T, contratFindUniqueArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contrat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contratFindUniqueOrThrowArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contratFindUniqueOrThrowArgs>(args: SelectSubset<T, contratFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contrat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratFindFirstArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contratFindFirstArgs>(args?: SelectSubset<T, contratFindFirstArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contrat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratFindFirstOrThrowArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contratFindFirstOrThrowArgs>(args?: SelectSubset<T, contratFindFirstOrThrowArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contrats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contrats
     * const contrats = await prisma.contrat.findMany()
     * 
     * // Get first 10 Contrats
     * const contrats = await prisma.contrat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contratWithIdOnly = await prisma.contrat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contratFindManyArgs>(args?: SelectSubset<T, contratFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contrat.
     * @param {contratCreateArgs} args - Arguments to create a Contrat.
     * @example
     * // Create one Contrat
     * const Contrat = await prisma.contrat.create({
     *   data: {
     *     // ... data to create a Contrat
     *   }
     * })
     * 
     */
    create<T extends contratCreateArgs>(args: SelectSubset<T, contratCreateArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contrats.
     * @param {contratCreateManyArgs} args - Arguments to create many Contrats.
     * @example
     * // Create many Contrats
     * const contrat = await prisma.contrat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contratCreateManyArgs>(args?: SelectSubset<T, contratCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contrat.
     * @param {contratDeleteArgs} args - Arguments to delete one Contrat.
     * @example
     * // Delete one Contrat
     * const Contrat = await prisma.contrat.delete({
     *   where: {
     *     // ... filter to delete one Contrat
     *   }
     * })
     * 
     */
    delete<T extends contratDeleteArgs>(args: SelectSubset<T, contratDeleteArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contrat.
     * @param {contratUpdateArgs} args - Arguments to update one Contrat.
     * @example
     * // Update one Contrat
     * const contrat = await prisma.contrat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contratUpdateArgs>(args: SelectSubset<T, contratUpdateArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contrats.
     * @param {contratDeleteManyArgs} args - Arguments to filter Contrats to delete.
     * @example
     * // Delete a few Contrats
     * const { count } = await prisma.contrat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contratDeleteManyArgs>(args?: SelectSubset<T, contratDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contrats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contrats
     * const contrat = await prisma.contrat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contratUpdateManyArgs>(args: SelectSubset<T, contratUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contrat.
     * @param {contratUpsertArgs} args - Arguments to update or create a Contrat.
     * @example
     * // Update or create a Contrat
     * const contrat = await prisma.contrat.upsert({
     *   create: {
     *     // ... data to create a Contrat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contrat we want to update
     *   }
     * })
     */
    upsert<T extends contratUpsertArgs>(args: SelectSubset<T, contratUpsertArgs<ExtArgs>>): Prisma__contratClient<$Result.GetResult<Prisma.$contratPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contrats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratCountArgs} args - Arguments to filter Contrats to count.
     * @example
     * // Count the number of Contrats
     * const count = await prisma.contrat.count({
     *   where: {
     *     // ... the filter for the Contrats we want to count
     *   }
     * })
    **/
    count<T extends contratCountArgs>(
      args?: Subset<T, contratCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contrat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratAggregateArgs>(args: Subset<T, ContratAggregateArgs>): Prisma.PrismaPromise<GetContratAggregateType<T>>

    /**
     * Group by Contrat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contratGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contratGroupByArgs['orderBy'] }
        : { orderBy?: contratGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contratGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contrat model
   */
  readonly fields: contratFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contrat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contratClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soustraitant<T extends soustraitantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, soustraitantDefaultArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contrat model
   */ 
  interface contratFieldRefs {
    readonly id: FieldRef<"contrat", 'String'>
    readonly soustraitantId: FieldRef<"contrat", 'String'>
    readonly url: FieldRef<"contrat", 'String'>
    readonly dateGeneration: FieldRef<"contrat", 'DateTime'>
    readonly dateSignature: FieldRef<"contrat", 'DateTime'>
    readonly estSigne: FieldRef<"contrat", 'Boolean'>
    readonly token: FieldRef<"contrat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * contrat findUnique
   */
  export type contratFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * Filter, which contrat to fetch.
     */
    where: contratWhereUniqueInput
  }

  /**
   * contrat findUniqueOrThrow
   */
  export type contratFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * Filter, which contrat to fetch.
     */
    where: contratWhereUniqueInput
  }

  /**
   * contrat findFirst
   */
  export type contratFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * Filter, which contrat to fetch.
     */
    where?: contratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contrats to fetch.
     */
    orderBy?: contratOrderByWithRelationInput | contratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contrats.
     */
    cursor?: contratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contrats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contrats.
     */
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * contrat findFirstOrThrow
   */
  export type contratFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * Filter, which contrat to fetch.
     */
    where?: contratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contrats to fetch.
     */
    orderBy?: contratOrderByWithRelationInput | contratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contrats.
     */
    cursor?: contratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contrats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contrats.
     */
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * contrat findMany
   */
  export type contratFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * Filter, which contrats to fetch.
     */
    where?: contratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contrats to fetch.
     */
    orderBy?: contratOrderByWithRelationInput | contratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contrats.
     */
    cursor?: contratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contrats.
     */
    skip?: number
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * contrat create
   */
  export type contratCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * The data needed to create a contrat.
     */
    data: XOR<contratCreateInput, contratUncheckedCreateInput>
  }

  /**
   * contrat createMany
   */
  export type contratCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contrats.
     */
    data: contratCreateManyInput | contratCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contrat update
   */
  export type contratUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * The data needed to update a contrat.
     */
    data: XOR<contratUpdateInput, contratUncheckedUpdateInput>
    /**
     * Choose, which contrat to update.
     */
    where: contratWhereUniqueInput
  }

  /**
   * contrat updateMany
   */
  export type contratUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contrats.
     */
    data: XOR<contratUpdateManyMutationInput, contratUncheckedUpdateManyInput>
    /**
     * Filter which contrats to update
     */
    where?: contratWhereInput
    /**
     * Limit how many contrats to update.
     */
    limit?: number
  }

  /**
   * contrat upsert
   */
  export type contratUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * The filter to search for the contrat to update in case it exists.
     */
    where: contratWhereUniqueInput
    /**
     * In case the contrat found by the `where` argument doesn't exist, create a new contrat with this data.
     */
    create: XOR<contratCreateInput, contratUncheckedCreateInput>
    /**
     * In case the contrat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contratUpdateInput, contratUncheckedUpdateInput>
  }

  /**
   * contrat delete
   */
  export type contratDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
    /**
     * Filter which contrat to delete.
     */
    where: contratWhereUniqueInput
  }

  /**
   * contrat deleteMany
   */
  export type contratDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contrats to delete
     */
    where?: contratWhereInput
    /**
     * Limit how many contrats to delete.
     */
    limit?: number
  }

  /**
   * contrat without action
   */
  export type contratDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contrat
     */
    select?: contratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contrat
     */
    omit?: contratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contratInclude<ExtArgs> | null
  }


  /**
   * Model FicheTechnique
   */

  export type AggregateFicheTechnique = {
    _count: FicheTechniqueCountAggregateOutputType | null
    _min: FicheTechniqueMinAggregateOutputType | null
    _max: FicheTechniqueMaxAggregateOutputType | null
  }

  export type FicheTechniqueMinAggregateOutputType = {
    id: string | null
    titre: string | null
    categorie: string | null
    sousCategorie: string | null
    fichierUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceCSC: string | null
  }

  export type FicheTechniqueMaxAggregateOutputType = {
    id: string | null
    titre: string | null
    categorie: string | null
    sousCategorie: string | null
    fichierUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceCSC: string | null
  }

  export type FicheTechniqueCountAggregateOutputType = {
    id: number
    titre: number
    categorie: number
    sousCategorie: number
    fichierUrl: number
    description: number
    createdAt: number
    updatedAt: number
    referenceCSC: number
    _all: number
  }


  export type FicheTechniqueMinAggregateInputType = {
    id?: true
    titre?: true
    categorie?: true
    sousCategorie?: true
    fichierUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    referenceCSC?: true
  }

  export type FicheTechniqueMaxAggregateInputType = {
    id?: true
    titre?: true
    categorie?: true
    sousCategorie?: true
    fichierUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    referenceCSC?: true
  }

  export type FicheTechniqueCountAggregateInputType = {
    id?: true
    titre?: true
    categorie?: true
    sousCategorie?: true
    fichierUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    referenceCSC?: true
    _all?: true
  }

  export type FicheTechniqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FicheTechnique to aggregate.
     */
    where?: FicheTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheTechniques to fetch.
     */
    orderBy?: FicheTechniqueOrderByWithRelationInput | FicheTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FicheTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FicheTechniques
    **/
    _count?: true | FicheTechniqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FicheTechniqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FicheTechniqueMaxAggregateInputType
  }

  export type GetFicheTechniqueAggregateType<T extends FicheTechniqueAggregateArgs> = {
        [P in keyof T & keyof AggregateFicheTechnique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFicheTechnique[P]>
      : GetScalarType<T[P], AggregateFicheTechnique[P]>
  }




  export type FicheTechniqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FicheTechniqueWhereInput
    orderBy?: FicheTechniqueOrderByWithAggregationInput | FicheTechniqueOrderByWithAggregationInput[]
    by: FicheTechniqueScalarFieldEnum[] | FicheTechniqueScalarFieldEnum
    having?: FicheTechniqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FicheTechniqueCountAggregateInputType | true
    _min?: FicheTechniqueMinAggregateInputType
    _max?: FicheTechniqueMaxAggregateInputType
  }

  export type FicheTechniqueGroupByOutputType = {
    id: string
    titre: string
    categorie: string
    sousCategorie: string | null
    fichierUrl: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    referenceCSC: string | null
    _count: FicheTechniqueCountAggregateOutputType | null
    _min: FicheTechniqueMinAggregateOutputType | null
    _max: FicheTechniqueMaxAggregateOutputType | null
  }

  type GetFicheTechniqueGroupByPayload<T extends FicheTechniqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FicheTechniqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FicheTechniqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FicheTechniqueGroupByOutputType[P]>
            : GetScalarType<T[P], FicheTechniqueGroupByOutputType[P]>
        }
      >
    >


  export type FicheTechniqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    categorie?: boolean
    sousCategorie?: boolean
    fichierUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceCSC?: boolean
  }, ExtArgs["result"]["ficheTechnique"]>



  export type FicheTechniqueSelectScalar = {
    id?: boolean
    titre?: boolean
    categorie?: boolean
    sousCategorie?: boolean
    fichierUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceCSC?: boolean
  }

  export type FicheTechniqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titre" | "categorie" | "sousCategorie" | "fichierUrl" | "description" | "createdAt" | "updatedAt" | "referenceCSC", ExtArgs["result"]["ficheTechnique"]>

  export type $FicheTechniquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FicheTechnique"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titre: string
      categorie: string
      sousCategorie: string | null
      fichierUrl: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      referenceCSC: string | null
    }, ExtArgs["result"]["ficheTechnique"]>
    composites: {}
  }

  type FicheTechniqueGetPayload<S extends boolean | null | undefined | FicheTechniqueDefaultArgs> = $Result.GetResult<Prisma.$FicheTechniquePayload, S>

  type FicheTechniqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FicheTechniqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FicheTechniqueCountAggregateInputType | true
    }

  export interface FicheTechniqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FicheTechnique'], meta: { name: 'FicheTechnique' } }
    /**
     * Find zero or one FicheTechnique that matches the filter.
     * @param {FicheTechniqueFindUniqueArgs} args - Arguments to find a FicheTechnique
     * @example
     * // Get one FicheTechnique
     * const ficheTechnique = await prisma.ficheTechnique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FicheTechniqueFindUniqueArgs>(args: SelectSubset<T, FicheTechniqueFindUniqueArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FicheTechnique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FicheTechniqueFindUniqueOrThrowArgs} args - Arguments to find a FicheTechnique
     * @example
     * // Get one FicheTechnique
     * const ficheTechnique = await prisma.ficheTechnique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FicheTechniqueFindUniqueOrThrowArgs>(args: SelectSubset<T, FicheTechniqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FicheTechnique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueFindFirstArgs} args - Arguments to find a FicheTechnique
     * @example
     * // Get one FicheTechnique
     * const ficheTechnique = await prisma.ficheTechnique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FicheTechniqueFindFirstArgs>(args?: SelectSubset<T, FicheTechniqueFindFirstArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FicheTechnique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueFindFirstOrThrowArgs} args - Arguments to find a FicheTechnique
     * @example
     * // Get one FicheTechnique
     * const ficheTechnique = await prisma.ficheTechnique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FicheTechniqueFindFirstOrThrowArgs>(args?: SelectSubset<T, FicheTechniqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FicheTechniques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FicheTechniques
     * const ficheTechniques = await prisma.ficheTechnique.findMany()
     * 
     * // Get first 10 FicheTechniques
     * const ficheTechniques = await prisma.ficheTechnique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ficheTechniqueWithIdOnly = await prisma.ficheTechnique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FicheTechniqueFindManyArgs>(args?: SelectSubset<T, FicheTechniqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FicheTechnique.
     * @param {FicheTechniqueCreateArgs} args - Arguments to create a FicheTechnique.
     * @example
     * // Create one FicheTechnique
     * const FicheTechnique = await prisma.ficheTechnique.create({
     *   data: {
     *     // ... data to create a FicheTechnique
     *   }
     * })
     * 
     */
    create<T extends FicheTechniqueCreateArgs>(args: SelectSubset<T, FicheTechniqueCreateArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FicheTechniques.
     * @param {FicheTechniqueCreateManyArgs} args - Arguments to create many FicheTechniques.
     * @example
     * // Create many FicheTechniques
     * const ficheTechnique = await prisma.ficheTechnique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FicheTechniqueCreateManyArgs>(args?: SelectSubset<T, FicheTechniqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FicheTechnique.
     * @param {FicheTechniqueDeleteArgs} args - Arguments to delete one FicheTechnique.
     * @example
     * // Delete one FicheTechnique
     * const FicheTechnique = await prisma.ficheTechnique.delete({
     *   where: {
     *     // ... filter to delete one FicheTechnique
     *   }
     * })
     * 
     */
    delete<T extends FicheTechniqueDeleteArgs>(args: SelectSubset<T, FicheTechniqueDeleteArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FicheTechnique.
     * @param {FicheTechniqueUpdateArgs} args - Arguments to update one FicheTechnique.
     * @example
     * // Update one FicheTechnique
     * const ficheTechnique = await prisma.ficheTechnique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FicheTechniqueUpdateArgs>(args: SelectSubset<T, FicheTechniqueUpdateArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FicheTechniques.
     * @param {FicheTechniqueDeleteManyArgs} args - Arguments to filter FicheTechniques to delete.
     * @example
     * // Delete a few FicheTechniques
     * const { count } = await prisma.ficheTechnique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FicheTechniqueDeleteManyArgs>(args?: SelectSubset<T, FicheTechniqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FicheTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FicheTechniques
     * const ficheTechnique = await prisma.ficheTechnique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FicheTechniqueUpdateManyArgs>(args: SelectSubset<T, FicheTechniqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FicheTechnique.
     * @param {FicheTechniqueUpsertArgs} args - Arguments to update or create a FicheTechnique.
     * @example
     * // Update or create a FicheTechnique
     * const ficheTechnique = await prisma.ficheTechnique.upsert({
     *   create: {
     *     // ... data to create a FicheTechnique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FicheTechnique we want to update
     *   }
     * })
     */
    upsert<T extends FicheTechniqueUpsertArgs>(args: SelectSubset<T, FicheTechniqueUpsertArgs<ExtArgs>>): Prisma__FicheTechniqueClient<$Result.GetResult<Prisma.$FicheTechniquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FicheTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueCountArgs} args - Arguments to filter FicheTechniques to count.
     * @example
     * // Count the number of FicheTechniques
     * const count = await prisma.ficheTechnique.count({
     *   where: {
     *     // ... the filter for the FicheTechniques we want to count
     *   }
     * })
    **/
    count<T extends FicheTechniqueCountArgs>(
      args?: Subset<T, FicheTechniqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FicheTechniqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FicheTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FicheTechniqueAggregateArgs>(args: Subset<T, FicheTechniqueAggregateArgs>): Prisma.PrismaPromise<GetFicheTechniqueAggregateType<T>>

    /**
     * Group by FicheTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheTechniqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FicheTechniqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FicheTechniqueGroupByArgs['orderBy'] }
        : { orderBy?: FicheTechniqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FicheTechniqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFicheTechniqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FicheTechnique model
   */
  readonly fields: FicheTechniqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FicheTechnique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FicheTechniqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FicheTechnique model
   */ 
  interface FicheTechniqueFieldRefs {
    readonly id: FieldRef<"FicheTechnique", 'String'>
    readonly titre: FieldRef<"FicheTechnique", 'String'>
    readonly categorie: FieldRef<"FicheTechnique", 'String'>
    readonly sousCategorie: FieldRef<"FicheTechnique", 'String'>
    readonly fichierUrl: FieldRef<"FicheTechnique", 'String'>
    readonly description: FieldRef<"FicheTechnique", 'String'>
    readonly createdAt: FieldRef<"FicheTechnique", 'DateTime'>
    readonly updatedAt: FieldRef<"FicheTechnique", 'DateTime'>
    readonly referenceCSC: FieldRef<"FicheTechnique", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FicheTechnique findUnique
   */
  export type FicheTechniqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * Filter, which FicheTechnique to fetch.
     */
    where: FicheTechniqueWhereUniqueInput
  }

  /**
   * FicheTechnique findUniqueOrThrow
   */
  export type FicheTechniqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * Filter, which FicheTechnique to fetch.
     */
    where: FicheTechniqueWhereUniqueInput
  }

  /**
   * FicheTechnique findFirst
   */
  export type FicheTechniqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * Filter, which FicheTechnique to fetch.
     */
    where?: FicheTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheTechniques to fetch.
     */
    orderBy?: FicheTechniqueOrderByWithRelationInput | FicheTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FicheTechniques.
     */
    cursor?: FicheTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FicheTechniques.
     */
    distinct?: FicheTechniqueScalarFieldEnum | FicheTechniqueScalarFieldEnum[]
  }

  /**
   * FicheTechnique findFirstOrThrow
   */
  export type FicheTechniqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * Filter, which FicheTechnique to fetch.
     */
    where?: FicheTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheTechniques to fetch.
     */
    orderBy?: FicheTechniqueOrderByWithRelationInput | FicheTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FicheTechniques.
     */
    cursor?: FicheTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FicheTechniques.
     */
    distinct?: FicheTechniqueScalarFieldEnum | FicheTechniqueScalarFieldEnum[]
  }

  /**
   * FicheTechnique findMany
   */
  export type FicheTechniqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * Filter, which FicheTechniques to fetch.
     */
    where?: FicheTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheTechniques to fetch.
     */
    orderBy?: FicheTechniqueOrderByWithRelationInput | FicheTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FicheTechniques.
     */
    cursor?: FicheTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheTechniques.
     */
    skip?: number
    distinct?: FicheTechniqueScalarFieldEnum | FicheTechniqueScalarFieldEnum[]
  }

  /**
   * FicheTechnique create
   */
  export type FicheTechniqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * The data needed to create a FicheTechnique.
     */
    data: XOR<FicheTechniqueCreateInput, FicheTechniqueUncheckedCreateInput>
  }

  /**
   * FicheTechnique createMany
   */
  export type FicheTechniqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FicheTechniques.
     */
    data: FicheTechniqueCreateManyInput | FicheTechniqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FicheTechnique update
   */
  export type FicheTechniqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * The data needed to update a FicheTechnique.
     */
    data: XOR<FicheTechniqueUpdateInput, FicheTechniqueUncheckedUpdateInput>
    /**
     * Choose, which FicheTechnique to update.
     */
    where: FicheTechniqueWhereUniqueInput
  }

  /**
   * FicheTechnique updateMany
   */
  export type FicheTechniqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FicheTechniques.
     */
    data: XOR<FicheTechniqueUpdateManyMutationInput, FicheTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which FicheTechniques to update
     */
    where?: FicheTechniqueWhereInput
    /**
     * Limit how many FicheTechniques to update.
     */
    limit?: number
  }

  /**
   * FicheTechnique upsert
   */
  export type FicheTechniqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * The filter to search for the FicheTechnique to update in case it exists.
     */
    where: FicheTechniqueWhereUniqueInput
    /**
     * In case the FicheTechnique found by the `where` argument doesn't exist, create a new FicheTechnique with this data.
     */
    create: XOR<FicheTechniqueCreateInput, FicheTechniqueUncheckedCreateInput>
    /**
     * In case the FicheTechnique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FicheTechniqueUpdateInput, FicheTechniqueUncheckedUpdateInput>
  }

  /**
   * FicheTechnique delete
   */
  export type FicheTechniqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
    /**
     * Filter which FicheTechnique to delete.
     */
    where: FicheTechniqueWhereUniqueInput
  }

  /**
   * FicheTechnique deleteMany
   */
  export type FicheTechniqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FicheTechniques to delete
     */
    where?: FicheTechniqueWhereInput
    /**
     * Limit how many FicheTechniques to delete.
     */
    limit?: number
  }

  /**
   * FicheTechnique without action
   */
  export type FicheTechniqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheTechnique
     */
    select?: FicheTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheTechnique
     */
    omit?: FicheTechniqueOmit<ExtArgs> | null
  }


  /**
   * Model Commande
   */

  export type AggregateCommande = {
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  export type CommandeAvgAggregateOutputType = {
    id: number | null
    tauxTVA: number | null
    sousTotal: number | null
    totalOptions: number | null
    tva: number | null
    total: number | null
  }

  export type CommandeSumAggregateOutputType = {
    id: number | null
    tauxTVA: number | null
    sousTotal: number | null
    totalOptions: number | null
    tva: number | null
    total: number | null
  }

  export type CommandeMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    clientId: string | null
    dateCommande: Date | null
    reference: string | null
    tauxTVA: number | null
    sousTotal: number | null
    totalOptions: number | null
    tva: number | null
    total: number | null
    statut: string | null
    estVerrouillee: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    clientId: string | null
    dateCommande: Date | null
    reference: string | null
    tauxTVA: number | null
    sousTotal: number | null
    totalOptions: number | null
    tva: number | null
    total: number | null
    statut: string | null
    estVerrouillee: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeCountAggregateOutputType = {
    id: number
    chantierId: number
    clientId: number
    dateCommande: number
    reference: number
    tauxTVA: number
    sousTotal: number
    totalOptions: number
    tva: number
    total: number
    statut: number
    estVerrouillee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandeAvgAggregateInputType = {
    id?: true
    tauxTVA?: true
    sousTotal?: true
    totalOptions?: true
    tva?: true
    total?: true
  }

  export type CommandeSumAggregateInputType = {
    id?: true
    tauxTVA?: true
    sousTotal?: true
    totalOptions?: true
    tva?: true
    total?: true
  }

  export type CommandeMinAggregateInputType = {
    id?: true
    chantierId?: true
    clientId?: true
    dateCommande?: true
    reference?: true
    tauxTVA?: true
    sousTotal?: true
    totalOptions?: true
    tva?: true
    total?: true
    statut?: true
    estVerrouillee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeMaxAggregateInputType = {
    id?: true
    chantierId?: true
    clientId?: true
    dateCommande?: true
    reference?: true
    tauxTVA?: true
    sousTotal?: true
    totalOptions?: true
    tva?: true
    total?: true
    statut?: true
    estVerrouillee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeCountAggregateInputType = {
    id?: true
    chantierId?: true
    clientId?: true
    dateCommande?: true
    reference?: true
    tauxTVA?: true
    sousTotal?: true
    totalOptions?: true
    tva?: true
    total?: true
    statut?: true
    estVerrouillee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commande to aggregate.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commandes
    **/
    _count?: true | CommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandeMaxAggregateInputType
  }

  export type GetCommandeAggregateType<T extends CommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommande[P]>
      : GetScalarType<T[P], AggregateCommande[P]>
  }




  export type CommandeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithAggregationInput | CommandeOrderByWithAggregationInput[]
    by: CommandeScalarFieldEnum[] | CommandeScalarFieldEnum
    having?: CommandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandeCountAggregateInputType | true
    _avg?: CommandeAvgAggregateInputType
    _sum?: CommandeSumAggregateInputType
    _min?: CommandeMinAggregateInputType
    _max?: CommandeMaxAggregateInputType
  }

  export type CommandeGroupByOutputType = {
    id: number
    chantierId: string
    clientId: string | null
    dateCommande: Date
    reference: string | null
    tauxTVA: number
    sousTotal: number
    totalOptions: number
    tva: number
    total: number
    statut: string
    estVerrouillee: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  type GetCommandeGroupByPayload<T extends CommandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandeGroupByOutputType[P]>
            : GetScalarType<T[P], CommandeGroupByOutputType[P]>
        }
      >
    >


  export type CommandeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    clientId?: boolean
    dateCommande?: boolean
    reference?: boolean
    tauxTVA?: boolean
    sousTotal?: boolean
    totalOptions?: boolean
    tva?: boolean
    total?: boolean
    statut?: boolean
    estVerrouillee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lignes?: boolean | Commande$lignesArgs<ExtArgs>
    _count?: boolean | CommandeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>



  export type CommandeSelectScalar = {
    id?: boolean
    chantierId?: boolean
    clientId?: boolean
    dateCommande?: boolean
    reference?: boolean
    tauxTVA?: boolean
    sousTotal?: boolean
    totalOptions?: boolean
    tva?: boolean
    total?: boolean
    statut?: boolean
    estVerrouillee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "clientId" | "dateCommande" | "reference" | "tauxTVA" | "sousTotal" | "totalOptions" | "tva" | "total" | "statut" | "estVerrouillee" | "createdAt" | "updatedAt", ExtArgs["result"]["commande"]>
  export type CommandeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | Commande$lignesArgs<ExtArgs>
    _count?: boolean | CommandeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommandePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commande"
    objects: {
      lignes: Prisma.$LigneCommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      clientId: string | null
      dateCommande: Date
      reference: string | null
      tauxTVA: number
      sousTotal: number
      totalOptions: number
      tva: number
      total: number
      statut: string
      estVerrouillee: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commande"]>
    composites: {}
  }

  type CommandeGetPayload<S extends boolean | null | undefined | CommandeDefaultArgs> = $Result.GetResult<Prisma.$CommandePayload, S>

  type CommandeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandeCountAggregateInputType | true
    }

  export interface CommandeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commande'], meta: { name: 'Commande' } }
    /**
     * Find zero or one Commande that matches the filter.
     * @param {CommandeFindUniqueArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandeFindUniqueArgs>(args: SelectSubset<T, CommandeFindUniqueArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Commande that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandeFindUniqueOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandeFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindFirstArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandeFindFirstArgs>(args?: SelectSubset<T, CommandeFindFirstArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commande that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindFirstOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandeFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Commandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commandes
     * const commandes = await prisma.commande.findMany()
     * 
     * // Get first 10 Commandes
     * const commandes = await prisma.commande.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandeWithIdOnly = await prisma.commande.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandeFindManyArgs>(args?: SelectSubset<T, CommandeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Commande.
     * @param {CommandeCreateArgs} args - Arguments to create a Commande.
     * @example
     * // Create one Commande
     * const Commande = await prisma.commande.create({
     *   data: {
     *     // ... data to create a Commande
     *   }
     * })
     * 
     */
    create<T extends CommandeCreateArgs>(args: SelectSubset<T, CommandeCreateArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Commandes.
     * @param {CommandeCreateManyArgs} args - Arguments to create many Commandes.
     * @example
     * // Create many Commandes
     * const commande = await prisma.commande.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandeCreateManyArgs>(args?: SelectSubset<T, CommandeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commande.
     * @param {CommandeDeleteArgs} args - Arguments to delete one Commande.
     * @example
     * // Delete one Commande
     * const Commande = await prisma.commande.delete({
     *   where: {
     *     // ... filter to delete one Commande
     *   }
     * })
     * 
     */
    delete<T extends CommandeDeleteArgs>(args: SelectSubset<T, CommandeDeleteArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Commande.
     * @param {CommandeUpdateArgs} args - Arguments to update one Commande.
     * @example
     * // Update one Commande
     * const commande = await prisma.commande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandeUpdateArgs>(args: SelectSubset<T, CommandeUpdateArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Commandes.
     * @param {CommandeDeleteManyArgs} args - Arguments to filter Commandes to delete.
     * @example
     * // Delete a few Commandes
     * const { count } = await prisma.commande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandeDeleteManyArgs>(args?: SelectSubset<T, CommandeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandeUpdateManyArgs>(args: SelectSubset<T, CommandeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commande.
     * @param {CommandeUpsertArgs} args - Arguments to update or create a Commande.
     * @example
     * // Update or create a Commande
     * const commande = await prisma.commande.upsert({
     *   create: {
     *     // ... data to create a Commande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commande we want to update
     *   }
     * })
     */
    upsert<T extends CommandeUpsertArgs>(args: SelectSubset<T, CommandeUpsertArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeCountArgs} args - Arguments to filter Commandes to count.
     * @example
     * // Count the number of Commandes
     * const count = await prisma.commande.count({
     *   where: {
     *     // ... the filter for the Commandes we want to count
     *   }
     * })
    **/
    count<T extends CommandeCountArgs>(
      args?: Subset<T, CommandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandeAggregateArgs>(args: Subset<T, CommandeAggregateArgs>): Prisma.PrismaPromise<GetCommandeAggregateType<T>>

    /**
     * Group by Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandeGroupByArgs['orderBy'] }
        : { orderBy?: CommandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commande model
   */
  readonly fields: CommandeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lignes<T extends Commande$lignesArgs<ExtArgs> = {}>(args?: Subset<T, Commande$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commande model
   */ 
  interface CommandeFieldRefs {
    readonly id: FieldRef<"Commande", 'Int'>
    readonly chantierId: FieldRef<"Commande", 'String'>
    readonly clientId: FieldRef<"Commande", 'String'>
    readonly dateCommande: FieldRef<"Commande", 'DateTime'>
    readonly reference: FieldRef<"Commande", 'String'>
    readonly tauxTVA: FieldRef<"Commande", 'Float'>
    readonly sousTotal: FieldRef<"Commande", 'Float'>
    readonly totalOptions: FieldRef<"Commande", 'Float'>
    readonly tva: FieldRef<"Commande", 'Float'>
    readonly total: FieldRef<"Commande", 'Float'>
    readonly statut: FieldRef<"Commande", 'String'>
    readonly estVerrouillee: FieldRef<"Commande", 'Boolean'>
    readonly createdAt: FieldRef<"Commande", 'DateTime'>
    readonly updatedAt: FieldRef<"Commande", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Commande findUnique
   */
  export type CommandeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande findUniqueOrThrow
   */
  export type CommandeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande findFirst
   */
  export type CommandeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande findFirstOrThrow
   */
  export type CommandeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande findMany
   */
  export type CommandeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commandes to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande create
   */
  export type CommandeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The data needed to create a Commande.
     */
    data: XOR<CommandeCreateInput, CommandeUncheckedCreateInput>
  }

  /**
   * Commande createMany
   */
  export type CommandeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commandes.
     */
    data: CommandeCreateManyInput | CommandeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commande update
   */
  export type CommandeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The data needed to update a Commande.
     */
    data: XOR<CommandeUpdateInput, CommandeUncheckedUpdateInput>
    /**
     * Choose, which Commande to update.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande updateMany
   */
  export type CommandeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commandes.
     */
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyInput>
    /**
     * Filter which Commandes to update
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to update.
     */
    limit?: number
  }

  /**
   * Commande upsert
   */
  export type CommandeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The filter to search for the Commande to update in case it exists.
     */
    where: CommandeWhereUniqueInput
    /**
     * In case the Commande found by the `where` argument doesn't exist, create a new Commande with this data.
     */
    create: XOR<CommandeCreateInput, CommandeUncheckedCreateInput>
    /**
     * In case the Commande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandeUpdateInput, CommandeUncheckedUpdateInput>
  }

  /**
   * Commande delete
   */
  export type CommandeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter which Commande to delete.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande deleteMany
   */
  export type CommandeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commandes to delete
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to delete.
     */
    limit?: number
  }

  /**
   * Commande.lignes
   */
  export type Commande$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    where?: LigneCommandeWhereInput
    orderBy?: LigneCommandeOrderByWithRelationInput | LigneCommandeOrderByWithRelationInput[]
    cursor?: LigneCommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneCommandeScalarFieldEnum | LigneCommandeScalarFieldEnum[]
  }

  /**
   * Commande without action
   */
  export type CommandeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
  }


  /**
   * Model LigneCommande
   */

  export type AggregateLigneCommande = {
    _count: LigneCommandeCountAggregateOutputType | null
    _avg: LigneCommandeAvgAggregateOutputType | null
    _sum: LigneCommandeSumAggregateOutputType | null
    _min: LigneCommandeMinAggregateOutputType | null
    _max: LigneCommandeMaxAggregateOutputType | null
  }

  export type LigneCommandeAvgAggregateOutputType = {
    id: number | null
    commandeId: number | null
    ordre: number | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
  }

  export type LigneCommandeSumAggregateOutputType = {
    id: number | null
    commandeId: number | null
    ordre: number | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
  }

  export type LigneCommandeMinAggregateOutputType = {
    id: number | null
    commandeId: number | null
    ordre: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
    estOption: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneCommandeMaxAggregateOutputType = {
    id: number | null
    commandeId: number | null
    ordre: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
    estOption: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneCommandeCountAggregateOutputType = {
    id: number
    commandeId: number
    ordre: number
    article: number
    description: number
    type: number
    unite: number
    prixUnitaire: number
    quantite: number
    total: number
    estOption: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LigneCommandeAvgAggregateInputType = {
    id?: true
    commandeId?: true
    ordre?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
  }

  export type LigneCommandeSumAggregateInputType = {
    id?: true
    commandeId?: true
    ordre?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
  }

  export type LigneCommandeMinAggregateInputType = {
    id?: true
    commandeId?: true
    ordre?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
    estOption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneCommandeMaxAggregateInputType = {
    id?: true
    commandeId?: true
    ordre?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
    estOption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneCommandeCountAggregateInputType = {
    id?: true
    commandeId?: true
    ordre?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
    estOption?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LigneCommandeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCommande to aggregate.
     */
    where?: LigneCommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandes to fetch.
     */
    orderBy?: LigneCommandeOrderByWithRelationInput | LigneCommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneCommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneCommandes
    **/
    _count?: true | LigneCommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneCommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneCommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneCommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneCommandeMaxAggregateInputType
  }

  export type GetLigneCommandeAggregateType<T extends LigneCommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneCommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneCommande[P]>
      : GetScalarType<T[P], AggregateLigneCommande[P]>
  }




  export type LigneCommandeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandeWhereInput
    orderBy?: LigneCommandeOrderByWithAggregationInput | LigneCommandeOrderByWithAggregationInput[]
    by: LigneCommandeScalarFieldEnum[] | LigneCommandeScalarFieldEnum
    having?: LigneCommandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneCommandeCountAggregateInputType | true
    _avg?: LigneCommandeAvgAggregateInputType
    _sum?: LigneCommandeSumAggregateInputType
    _min?: LigneCommandeMinAggregateInputType
    _max?: LigneCommandeMaxAggregateInputType
  }

  export type LigneCommandeGroupByOutputType = {
    id: number
    commandeId: number
    ordre: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption: boolean
    createdAt: Date
    updatedAt: Date
    _count: LigneCommandeCountAggregateOutputType | null
    _avg: LigneCommandeAvgAggregateOutputType | null
    _sum: LigneCommandeSumAggregateOutputType | null
    _min: LigneCommandeMinAggregateOutputType | null
    _max: LigneCommandeMaxAggregateOutputType | null
  }

  type GetLigneCommandeGroupByPayload<T extends LigneCommandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneCommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneCommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneCommandeGroupByOutputType[P]>
            : GetScalarType<T[P], LigneCommandeGroupByOutputType[P]>
        }
      >
    >


  export type LigneCommandeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandeId?: boolean
    ordre?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    total?: boolean
    estOption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commande?: boolean | CommandeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneCommande"]>



  export type LigneCommandeSelectScalar = {
    id?: boolean
    commandeId?: boolean
    ordre?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    total?: boolean
    estOption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LigneCommandeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commandeId" | "ordre" | "article" | "description" | "type" | "unite" | "prixUnitaire" | "quantite" | "total" | "estOption" | "createdAt" | "updatedAt", ExtArgs["result"]["ligneCommande"]>
  export type LigneCommandeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commande?: boolean | CommandeDefaultArgs<ExtArgs>
  }

  export type $LigneCommandePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneCommande"
    objects: {
      commande: Prisma.$CommandePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commandeId: number
      ordre: number
      article: string
      description: string
      type: string
      unite: string
      prixUnitaire: number
      quantite: number
      total: number
      estOption: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ligneCommande"]>
    composites: {}
  }

  type LigneCommandeGetPayload<S extends boolean | null | undefined | LigneCommandeDefaultArgs> = $Result.GetResult<Prisma.$LigneCommandePayload, S>

  type LigneCommandeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneCommandeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneCommandeCountAggregateInputType | true
    }

  export interface LigneCommandeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneCommande'], meta: { name: 'LigneCommande' } }
    /**
     * Find zero or one LigneCommande that matches the filter.
     * @param {LigneCommandeFindUniqueArgs} args - Arguments to find a LigneCommande
     * @example
     * // Get one LigneCommande
     * const ligneCommande = await prisma.ligneCommande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneCommandeFindUniqueArgs>(args: SelectSubset<T, LigneCommandeFindUniqueArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LigneCommande that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneCommandeFindUniqueOrThrowArgs} args - Arguments to find a LigneCommande
     * @example
     * // Get one LigneCommande
     * const ligneCommande = await prisma.ligneCommande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneCommandeFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneCommandeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneCommande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeFindFirstArgs} args - Arguments to find a LigneCommande
     * @example
     * // Get one LigneCommande
     * const ligneCommande = await prisma.ligneCommande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneCommandeFindFirstArgs>(args?: SelectSubset<T, LigneCommandeFindFirstArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneCommande that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeFindFirstOrThrowArgs} args - Arguments to find a LigneCommande
     * @example
     * // Get one LigneCommande
     * const ligneCommande = await prisma.ligneCommande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneCommandeFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneCommandeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LigneCommandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneCommandes
     * const ligneCommandes = await prisma.ligneCommande.findMany()
     * 
     * // Get first 10 LigneCommandes
     * const ligneCommandes = await prisma.ligneCommande.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneCommandeWithIdOnly = await prisma.ligneCommande.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneCommandeFindManyArgs>(args?: SelectSubset<T, LigneCommandeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LigneCommande.
     * @param {LigneCommandeCreateArgs} args - Arguments to create a LigneCommande.
     * @example
     * // Create one LigneCommande
     * const LigneCommande = await prisma.ligneCommande.create({
     *   data: {
     *     // ... data to create a LigneCommande
     *   }
     * })
     * 
     */
    create<T extends LigneCommandeCreateArgs>(args: SelectSubset<T, LigneCommandeCreateArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LigneCommandes.
     * @param {LigneCommandeCreateManyArgs} args - Arguments to create many LigneCommandes.
     * @example
     * // Create many LigneCommandes
     * const ligneCommande = await prisma.ligneCommande.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneCommandeCreateManyArgs>(args?: SelectSubset<T, LigneCommandeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LigneCommande.
     * @param {LigneCommandeDeleteArgs} args - Arguments to delete one LigneCommande.
     * @example
     * // Delete one LigneCommande
     * const LigneCommande = await prisma.ligneCommande.delete({
     *   where: {
     *     // ... filter to delete one LigneCommande
     *   }
     * })
     * 
     */
    delete<T extends LigneCommandeDeleteArgs>(args: SelectSubset<T, LigneCommandeDeleteArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LigneCommande.
     * @param {LigneCommandeUpdateArgs} args - Arguments to update one LigneCommande.
     * @example
     * // Update one LigneCommande
     * const ligneCommande = await prisma.ligneCommande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneCommandeUpdateArgs>(args: SelectSubset<T, LigneCommandeUpdateArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LigneCommandes.
     * @param {LigneCommandeDeleteManyArgs} args - Arguments to filter LigneCommandes to delete.
     * @example
     * // Delete a few LigneCommandes
     * const { count } = await prisma.ligneCommande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneCommandeDeleteManyArgs>(args?: SelectSubset<T, LigneCommandeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneCommandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneCommandes
     * const ligneCommande = await prisma.ligneCommande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneCommandeUpdateManyArgs>(args: SelectSubset<T, LigneCommandeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneCommande.
     * @param {LigneCommandeUpsertArgs} args - Arguments to update or create a LigneCommande.
     * @example
     * // Update or create a LigneCommande
     * const ligneCommande = await prisma.ligneCommande.upsert({
     *   create: {
     *     // ... data to create a LigneCommande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneCommande we want to update
     *   }
     * })
     */
    upsert<T extends LigneCommandeUpsertArgs>(args: SelectSubset<T, LigneCommandeUpsertArgs<ExtArgs>>): Prisma__LigneCommandeClient<$Result.GetResult<Prisma.$LigneCommandePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LigneCommandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeCountArgs} args - Arguments to filter LigneCommandes to count.
     * @example
     * // Count the number of LigneCommandes
     * const count = await prisma.ligneCommande.count({
     *   where: {
     *     // ... the filter for the LigneCommandes we want to count
     *   }
     * })
    **/
    count<T extends LigneCommandeCountArgs>(
      args?: Subset<T, LigneCommandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneCommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneCommande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneCommandeAggregateArgs>(args: Subset<T, LigneCommandeAggregateArgs>): Prisma.PrismaPromise<GetLigneCommandeAggregateType<T>>

    /**
     * Group by LigneCommande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneCommandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneCommandeGroupByArgs['orderBy'] }
        : { orderBy?: LigneCommandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneCommandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneCommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneCommande model
   */
  readonly fields: LigneCommandeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneCommande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneCommandeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commande<T extends CommandeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandeDefaultArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneCommande model
   */ 
  interface LigneCommandeFieldRefs {
    readonly id: FieldRef<"LigneCommande", 'Int'>
    readonly commandeId: FieldRef<"LigneCommande", 'Int'>
    readonly ordre: FieldRef<"LigneCommande", 'Int'>
    readonly article: FieldRef<"LigneCommande", 'String'>
    readonly description: FieldRef<"LigneCommande", 'String'>
    readonly type: FieldRef<"LigneCommande", 'String'>
    readonly unite: FieldRef<"LigneCommande", 'String'>
    readonly prixUnitaire: FieldRef<"LigneCommande", 'Float'>
    readonly quantite: FieldRef<"LigneCommande", 'Float'>
    readonly total: FieldRef<"LigneCommande", 'Float'>
    readonly estOption: FieldRef<"LigneCommande", 'Boolean'>
    readonly createdAt: FieldRef<"LigneCommande", 'DateTime'>
    readonly updatedAt: FieldRef<"LigneCommande", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneCommande findUnique
   */
  export type LigneCommandeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommande to fetch.
     */
    where: LigneCommandeWhereUniqueInput
  }

  /**
   * LigneCommande findUniqueOrThrow
   */
  export type LigneCommandeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommande to fetch.
     */
    where: LigneCommandeWhereUniqueInput
  }

  /**
   * LigneCommande findFirst
   */
  export type LigneCommandeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommande to fetch.
     */
    where?: LigneCommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandes to fetch.
     */
    orderBy?: LigneCommandeOrderByWithRelationInput | LigneCommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCommandes.
     */
    cursor?: LigneCommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCommandes.
     */
    distinct?: LigneCommandeScalarFieldEnum | LigneCommandeScalarFieldEnum[]
  }

  /**
   * LigneCommande findFirstOrThrow
   */
  export type LigneCommandeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommande to fetch.
     */
    where?: LigneCommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandes to fetch.
     */
    orderBy?: LigneCommandeOrderByWithRelationInput | LigneCommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCommandes.
     */
    cursor?: LigneCommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCommandes.
     */
    distinct?: LigneCommandeScalarFieldEnum | LigneCommandeScalarFieldEnum[]
  }

  /**
   * LigneCommande findMany
   */
  export type LigneCommandeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandes to fetch.
     */
    where?: LigneCommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandes to fetch.
     */
    orderBy?: LigneCommandeOrderByWithRelationInput | LigneCommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneCommandes.
     */
    cursor?: LigneCommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandes.
     */
    skip?: number
    distinct?: LigneCommandeScalarFieldEnum | LigneCommandeScalarFieldEnum[]
  }

  /**
   * LigneCommande create
   */
  export type LigneCommandeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneCommande.
     */
    data: XOR<LigneCommandeCreateInput, LigneCommandeUncheckedCreateInput>
  }

  /**
   * LigneCommande createMany
   */
  export type LigneCommandeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneCommandes.
     */
    data: LigneCommandeCreateManyInput | LigneCommandeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneCommande update
   */
  export type LigneCommandeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneCommande.
     */
    data: XOR<LigneCommandeUpdateInput, LigneCommandeUncheckedUpdateInput>
    /**
     * Choose, which LigneCommande to update.
     */
    where: LigneCommandeWhereUniqueInput
  }

  /**
   * LigneCommande updateMany
   */
  export type LigneCommandeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneCommandes.
     */
    data: XOR<LigneCommandeUpdateManyMutationInput, LigneCommandeUncheckedUpdateManyInput>
    /**
     * Filter which LigneCommandes to update
     */
    where?: LigneCommandeWhereInput
    /**
     * Limit how many LigneCommandes to update.
     */
    limit?: number
  }

  /**
   * LigneCommande upsert
   */
  export type LigneCommandeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneCommande to update in case it exists.
     */
    where: LigneCommandeWhereUniqueInput
    /**
     * In case the LigneCommande found by the `where` argument doesn't exist, create a new LigneCommande with this data.
     */
    create: XOR<LigneCommandeCreateInput, LigneCommandeUncheckedCreateInput>
    /**
     * In case the LigneCommande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneCommandeUpdateInput, LigneCommandeUncheckedUpdateInput>
  }

  /**
   * LigneCommande delete
   */
  export type LigneCommandeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
    /**
     * Filter which LigneCommande to delete.
     */
    where: LigneCommandeWhereUniqueInput
  }

  /**
   * LigneCommande deleteMany
   */
  export type LigneCommandeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCommandes to delete
     */
    where?: LigneCommandeWhereInput
    /**
     * Limit how many LigneCommandes to delete.
     */
    limit?: number
  }

  /**
   * LigneCommande without action
   */
  export type LigneCommandeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommande
     */
    select?: LigneCommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommande
     */
    omit?: LigneCommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeInclude<ExtArgs> | null
  }


  /**
   * Model EtatAvancement
   */

  export type AggregateEtatAvancement = {
    _count: EtatAvancementCountAggregateOutputType | null
    _avg: EtatAvancementAvgAggregateOutputType | null
    _sum: EtatAvancementSumAggregateOutputType | null
    _min: EtatAvancementMinAggregateOutputType | null
    _max: EtatAvancementMaxAggregateOutputType | null
  }

  export type EtatAvancementAvgAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type EtatAvancementSumAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type EtatAvancementMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    numero: number | null
    date: Date | null
    commentaires: string | null
    estFinalise: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type EtatAvancementMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    numero: number | null
    date: Date | null
    commentaires: string | null
    estFinalise: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type EtatAvancementCountAggregateOutputType = {
    id: number
    chantierId: number
    numero: number
    date: number
    commentaires: number
    estFinalise: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type EtatAvancementAvgAggregateInputType = {
    id?: true
    numero?: true
  }

  export type EtatAvancementSumAggregateInputType = {
    id?: true
    numero?: true
  }

  export type EtatAvancementMinAggregateInputType = {
    id?: true
    chantierId?: true
    numero?: true
    date?: true
    commentaires?: true
    estFinalise?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type EtatAvancementMaxAggregateInputType = {
    id?: true
    chantierId?: true
    numero?: true
    date?: true
    commentaires?: true
    estFinalise?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type EtatAvancementCountAggregateInputType = {
    id?: true
    chantierId?: true
    numero?: true
    date?: true
    commentaires?: true
    estFinalise?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type EtatAvancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtatAvancement to aggregate.
     */
    where?: EtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtatAvancements to fetch.
     */
    orderBy?: EtatAvancementOrderByWithRelationInput | EtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EtatAvancements
    **/
    _count?: true | EtatAvancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtatAvancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtatAvancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtatAvancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtatAvancementMaxAggregateInputType
  }

  export type GetEtatAvancementAggregateType<T extends EtatAvancementAggregateArgs> = {
        [P in keyof T & keyof AggregateEtatAvancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtatAvancement[P]>
      : GetScalarType<T[P], AggregateEtatAvancement[P]>
  }




  export type EtatAvancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtatAvancementWhereInput
    orderBy?: EtatAvancementOrderByWithAggregationInput | EtatAvancementOrderByWithAggregationInput[]
    by: EtatAvancementScalarFieldEnum[] | EtatAvancementScalarFieldEnum
    having?: EtatAvancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtatAvancementCountAggregateInputType | true
    _avg?: EtatAvancementAvgAggregateInputType
    _sum?: EtatAvancementSumAggregateInputType
    _min?: EtatAvancementMinAggregateInputType
    _max?: EtatAvancementMaxAggregateInputType
  }

  export type EtatAvancementGroupByOutputType = {
    id: number
    chantierId: string
    numero: number
    date: Date
    commentaires: string | null
    estFinalise: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string
    _count: EtatAvancementCountAggregateOutputType | null
    _avg: EtatAvancementAvgAggregateOutputType | null
    _sum: EtatAvancementSumAggregateOutputType | null
    _min: EtatAvancementMinAggregateOutputType | null
    _max: EtatAvancementMaxAggregateOutputType | null
  }

  type GetEtatAvancementGroupByPayload<T extends EtatAvancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtatAvancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtatAvancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtatAvancementGroupByOutputType[P]>
            : GetScalarType<T[P], EtatAvancementGroupByOutputType[P]>
        }
      >
    >


  export type EtatAvancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    numero?: boolean
    date?: boolean
    commentaires?: boolean
    estFinalise?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    avenants?: boolean | EtatAvancement$avenantsArgs<ExtArgs>
    lignes?: boolean | EtatAvancement$lignesArgs<ExtArgs>
    soustraitant_etat_avancement?: boolean | EtatAvancement$soustraitant_etat_avancementArgs<ExtArgs>
    _count?: boolean | EtatAvancementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etatAvancement"]>



  export type EtatAvancementSelectScalar = {
    id?: boolean
    chantierId?: boolean
    numero?: boolean
    date?: boolean
    commentaires?: boolean
    estFinalise?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type EtatAvancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "numero" | "date" | "commentaires" | "estFinalise" | "createdAt" | "updatedAt" | "createdBy", ExtArgs["result"]["etatAvancement"]>
  export type EtatAvancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avenants?: boolean | EtatAvancement$avenantsArgs<ExtArgs>
    lignes?: boolean | EtatAvancement$lignesArgs<ExtArgs>
    soustraitant_etat_avancement?: boolean | EtatAvancement$soustraitant_etat_avancementArgs<ExtArgs>
    _count?: boolean | EtatAvancementCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EtatAvancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EtatAvancement"
    objects: {
      avenants: Prisma.$AvenantEtatAvancementPayload<ExtArgs>[]
      lignes: Prisma.$LigneEtatAvancementPayload<ExtArgs>[]
      soustraitant_etat_avancement: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      numero: number
      date: Date
      commentaires: string | null
      estFinalise: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string
    }, ExtArgs["result"]["etatAvancement"]>
    composites: {}
  }

  type EtatAvancementGetPayload<S extends boolean | null | undefined | EtatAvancementDefaultArgs> = $Result.GetResult<Prisma.$EtatAvancementPayload, S>

  type EtatAvancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EtatAvancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtatAvancementCountAggregateInputType | true
    }

  export interface EtatAvancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EtatAvancement'], meta: { name: 'EtatAvancement' } }
    /**
     * Find zero or one EtatAvancement that matches the filter.
     * @param {EtatAvancementFindUniqueArgs} args - Arguments to find a EtatAvancement
     * @example
     * // Get one EtatAvancement
     * const etatAvancement = await prisma.etatAvancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtatAvancementFindUniqueArgs>(args: SelectSubset<T, EtatAvancementFindUniqueArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EtatAvancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EtatAvancementFindUniqueOrThrowArgs} args - Arguments to find a EtatAvancement
     * @example
     * // Get one EtatAvancement
     * const etatAvancement = await prisma.etatAvancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtatAvancementFindUniqueOrThrowArgs>(args: SelectSubset<T, EtatAvancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EtatAvancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementFindFirstArgs} args - Arguments to find a EtatAvancement
     * @example
     * // Get one EtatAvancement
     * const etatAvancement = await prisma.etatAvancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtatAvancementFindFirstArgs>(args?: SelectSubset<T, EtatAvancementFindFirstArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EtatAvancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementFindFirstOrThrowArgs} args - Arguments to find a EtatAvancement
     * @example
     * // Get one EtatAvancement
     * const etatAvancement = await prisma.etatAvancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtatAvancementFindFirstOrThrowArgs>(args?: SelectSubset<T, EtatAvancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EtatAvancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EtatAvancements
     * const etatAvancements = await prisma.etatAvancement.findMany()
     * 
     * // Get first 10 EtatAvancements
     * const etatAvancements = await prisma.etatAvancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etatAvancementWithIdOnly = await prisma.etatAvancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EtatAvancementFindManyArgs>(args?: SelectSubset<T, EtatAvancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EtatAvancement.
     * @param {EtatAvancementCreateArgs} args - Arguments to create a EtatAvancement.
     * @example
     * // Create one EtatAvancement
     * const EtatAvancement = await prisma.etatAvancement.create({
     *   data: {
     *     // ... data to create a EtatAvancement
     *   }
     * })
     * 
     */
    create<T extends EtatAvancementCreateArgs>(args: SelectSubset<T, EtatAvancementCreateArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EtatAvancements.
     * @param {EtatAvancementCreateManyArgs} args - Arguments to create many EtatAvancements.
     * @example
     * // Create many EtatAvancements
     * const etatAvancement = await prisma.etatAvancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtatAvancementCreateManyArgs>(args?: SelectSubset<T, EtatAvancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EtatAvancement.
     * @param {EtatAvancementDeleteArgs} args - Arguments to delete one EtatAvancement.
     * @example
     * // Delete one EtatAvancement
     * const EtatAvancement = await prisma.etatAvancement.delete({
     *   where: {
     *     // ... filter to delete one EtatAvancement
     *   }
     * })
     * 
     */
    delete<T extends EtatAvancementDeleteArgs>(args: SelectSubset<T, EtatAvancementDeleteArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EtatAvancement.
     * @param {EtatAvancementUpdateArgs} args - Arguments to update one EtatAvancement.
     * @example
     * // Update one EtatAvancement
     * const etatAvancement = await prisma.etatAvancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtatAvancementUpdateArgs>(args: SelectSubset<T, EtatAvancementUpdateArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EtatAvancements.
     * @param {EtatAvancementDeleteManyArgs} args - Arguments to filter EtatAvancements to delete.
     * @example
     * // Delete a few EtatAvancements
     * const { count } = await prisma.etatAvancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtatAvancementDeleteManyArgs>(args?: SelectSubset<T, EtatAvancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EtatAvancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EtatAvancements
     * const etatAvancement = await prisma.etatAvancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtatAvancementUpdateManyArgs>(args: SelectSubset<T, EtatAvancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EtatAvancement.
     * @param {EtatAvancementUpsertArgs} args - Arguments to update or create a EtatAvancement.
     * @example
     * // Update or create a EtatAvancement
     * const etatAvancement = await prisma.etatAvancement.upsert({
     *   create: {
     *     // ... data to create a EtatAvancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EtatAvancement we want to update
     *   }
     * })
     */
    upsert<T extends EtatAvancementUpsertArgs>(args: SelectSubset<T, EtatAvancementUpsertArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EtatAvancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementCountArgs} args - Arguments to filter EtatAvancements to count.
     * @example
     * // Count the number of EtatAvancements
     * const count = await prisma.etatAvancement.count({
     *   where: {
     *     // ... the filter for the EtatAvancements we want to count
     *   }
     * })
    **/
    count<T extends EtatAvancementCountArgs>(
      args?: Subset<T, EtatAvancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtatAvancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EtatAvancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtatAvancementAggregateArgs>(args: Subset<T, EtatAvancementAggregateArgs>): Prisma.PrismaPromise<GetEtatAvancementAggregateType<T>>

    /**
     * Group by EtatAvancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAvancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtatAvancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtatAvancementGroupByArgs['orderBy'] }
        : { orderBy?: EtatAvancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtatAvancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtatAvancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EtatAvancement model
   */
  readonly fields: EtatAvancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EtatAvancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtatAvancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avenants<T extends EtatAvancement$avenantsArgs<ExtArgs> = {}>(args?: Subset<T, EtatAvancement$avenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lignes<T extends EtatAvancement$lignesArgs<ExtArgs> = {}>(args?: Subset<T, EtatAvancement$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soustraitant_etat_avancement<T extends EtatAvancement$soustraitant_etat_avancementArgs<ExtArgs> = {}>(args?: Subset<T, EtatAvancement$soustraitant_etat_avancementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EtatAvancement model
   */ 
  interface EtatAvancementFieldRefs {
    readonly id: FieldRef<"EtatAvancement", 'Int'>
    readonly chantierId: FieldRef<"EtatAvancement", 'String'>
    readonly numero: FieldRef<"EtatAvancement", 'Int'>
    readonly date: FieldRef<"EtatAvancement", 'DateTime'>
    readonly commentaires: FieldRef<"EtatAvancement", 'String'>
    readonly estFinalise: FieldRef<"EtatAvancement", 'Boolean'>
    readonly createdAt: FieldRef<"EtatAvancement", 'DateTime'>
    readonly updatedAt: FieldRef<"EtatAvancement", 'DateTime'>
    readonly createdBy: FieldRef<"EtatAvancement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EtatAvancement findUnique
   */
  export type EtatAvancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which EtatAvancement to fetch.
     */
    where: EtatAvancementWhereUniqueInput
  }

  /**
   * EtatAvancement findUniqueOrThrow
   */
  export type EtatAvancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which EtatAvancement to fetch.
     */
    where: EtatAvancementWhereUniqueInput
  }

  /**
   * EtatAvancement findFirst
   */
  export type EtatAvancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which EtatAvancement to fetch.
     */
    where?: EtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtatAvancements to fetch.
     */
    orderBy?: EtatAvancementOrderByWithRelationInput | EtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtatAvancements.
     */
    cursor?: EtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtatAvancements.
     */
    distinct?: EtatAvancementScalarFieldEnum | EtatAvancementScalarFieldEnum[]
  }

  /**
   * EtatAvancement findFirstOrThrow
   */
  export type EtatAvancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which EtatAvancement to fetch.
     */
    where?: EtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtatAvancements to fetch.
     */
    orderBy?: EtatAvancementOrderByWithRelationInput | EtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtatAvancements.
     */
    cursor?: EtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtatAvancements.
     */
    distinct?: EtatAvancementScalarFieldEnum | EtatAvancementScalarFieldEnum[]
  }

  /**
   * EtatAvancement findMany
   */
  export type EtatAvancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which EtatAvancements to fetch.
     */
    where?: EtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtatAvancements to fetch.
     */
    orderBy?: EtatAvancementOrderByWithRelationInput | EtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EtatAvancements.
     */
    cursor?: EtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtatAvancements.
     */
    skip?: number
    distinct?: EtatAvancementScalarFieldEnum | EtatAvancementScalarFieldEnum[]
  }

  /**
   * EtatAvancement create
   */
  export type EtatAvancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * The data needed to create a EtatAvancement.
     */
    data: XOR<EtatAvancementCreateInput, EtatAvancementUncheckedCreateInput>
  }

  /**
   * EtatAvancement createMany
   */
  export type EtatAvancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EtatAvancements.
     */
    data: EtatAvancementCreateManyInput | EtatAvancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EtatAvancement update
   */
  export type EtatAvancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * The data needed to update a EtatAvancement.
     */
    data: XOR<EtatAvancementUpdateInput, EtatAvancementUncheckedUpdateInput>
    /**
     * Choose, which EtatAvancement to update.
     */
    where: EtatAvancementWhereUniqueInput
  }

  /**
   * EtatAvancement updateMany
   */
  export type EtatAvancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EtatAvancements.
     */
    data: XOR<EtatAvancementUpdateManyMutationInput, EtatAvancementUncheckedUpdateManyInput>
    /**
     * Filter which EtatAvancements to update
     */
    where?: EtatAvancementWhereInput
    /**
     * Limit how many EtatAvancements to update.
     */
    limit?: number
  }

  /**
   * EtatAvancement upsert
   */
  export type EtatAvancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * The filter to search for the EtatAvancement to update in case it exists.
     */
    where: EtatAvancementWhereUniqueInput
    /**
     * In case the EtatAvancement found by the `where` argument doesn't exist, create a new EtatAvancement with this data.
     */
    create: XOR<EtatAvancementCreateInput, EtatAvancementUncheckedCreateInput>
    /**
     * In case the EtatAvancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtatAvancementUpdateInput, EtatAvancementUncheckedUpdateInput>
  }

  /**
   * EtatAvancement delete
   */
  export type EtatAvancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
    /**
     * Filter which EtatAvancement to delete.
     */
    where: EtatAvancementWhereUniqueInput
  }

  /**
   * EtatAvancement deleteMany
   */
  export type EtatAvancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtatAvancements to delete
     */
    where?: EtatAvancementWhereInput
    /**
     * Limit how many EtatAvancements to delete.
     */
    limit?: number
  }

  /**
   * EtatAvancement.avenants
   */
  export type EtatAvancement$avenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    where?: AvenantEtatAvancementWhereInput
    orderBy?: AvenantEtatAvancementOrderByWithRelationInput | AvenantEtatAvancementOrderByWithRelationInput[]
    cursor?: AvenantEtatAvancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvenantEtatAvancementScalarFieldEnum | AvenantEtatAvancementScalarFieldEnum[]
  }

  /**
   * EtatAvancement.lignes
   */
  export type EtatAvancement$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    where?: LigneEtatAvancementWhereInput
    orderBy?: LigneEtatAvancementOrderByWithRelationInput | LigneEtatAvancementOrderByWithRelationInput[]
    cursor?: LigneEtatAvancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneEtatAvancementScalarFieldEnum | LigneEtatAvancementScalarFieldEnum[]
  }

  /**
   * EtatAvancement.soustraitant_etat_avancement
   */
  export type EtatAvancement$soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    where?: soustraitant_etat_avancementWhereInput
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Soustraitant_etat_avancementScalarFieldEnum | Soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * EtatAvancement without action
   */
  export type EtatAvancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtatAvancement
     */
    select?: EtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtatAvancement
     */
    omit?: EtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatAvancementInclude<ExtArgs> | null
  }


  /**
   * Model LigneEtatAvancement
   */

  export type AggregateLigneEtatAvancement = {
    _count: LigneEtatAvancementCountAggregateOutputType | null
    _avg: LigneEtatAvancementAvgAggregateOutputType | null
    _sum: LigneEtatAvancementSumAggregateOutputType | null
    _min: LigneEtatAvancementMinAggregateOutputType | null
    _max: LigneEtatAvancementMaxAggregateOutputType | null
  }

  export type LigneEtatAvancementAvgAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    ligneCommandeId: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    prixUnitaire: number | null
    quantite: number | null
  }

  export type LigneEtatAvancementSumAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    ligneCommandeId: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    prixUnitaire: number | null
    quantite: number | null
  }

  export type LigneEtatAvancementMinAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    ligneCommandeId: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
    article: string | null
    description: string | null
    prixUnitaire: number | null
    quantite: number | null
    type: string | null
    unite: string | null
  }

  export type LigneEtatAvancementMaxAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    ligneCommandeId: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
    article: string | null
    description: string | null
    prixUnitaire: number | null
    quantite: number | null
    type: string | null
    unite: string | null
  }

  export type LigneEtatAvancementCountAggregateOutputType = {
    id: number
    etatAvancementId: number
    ligneCommandeId: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: number
    updatedAt: number
    article: number
    description: number
    prixUnitaire: number
    quantite: number
    type: number
    unite: number
    _all: number
  }


  export type LigneEtatAvancementAvgAggregateInputType = {
    id?: true
    etatAvancementId?: true
    ligneCommandeId?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    prixUnitaire?: true
    quantite?: true
  }

  export type LigneEtatAvancementSumAggregateInputType = {
    id?: true
    etatAvancementId?: true
    ligneCommandeId?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    prixUnitaire?: true
    quantite?: true
  }

  export type LigneEtatAvancementMinAggregateInputType = {
    id?: true
    etatAvancementId?: true
    ligneCommandeId?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
    article?: true
    description?: true
    prixUnitaire?: true
    quantite?: true
    type?: true
    unite?: true
  }

  export type LigneEtatAvancementMaxAggregateInputType = {
    id?: true
    etatAvancementId?: true
    ligneCommandeId?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
    article?: true
    description?: true
    prixUnitaire?: true
    quantite?: true
    type?: true
    unite?: true
  }

  export type LigneEtatAvancementCountAggregateInputType = {
    id?: true
    etatAvancementId?: true
    ligneCommandeId?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
    article?: true
    description?: true
    prixUnitaire?: true
    quantite?: true
    type?: true
    unite?: true
    _all?: true
  }

  export type LigneEtatAvancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneEtatAvancement to aggregate.
     */
    where?: LigneEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtatAvancements to fetch.
     */
    orderBy?: LigneEtatAvancementOrderByWithRelationInput | LigneEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneEtatAvancements
    **/
    _count?: true | LigneEtatAvancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneEtatAvancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneEtatAvancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneEtatAvancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneEtatAvancementMaxAggregateInputType
  }

  export type GetLigneEtatAvancementAggregateType<T extends LigneEtatAvancementAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneEtatAvancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneEtatAvancement[P]>
      : GetScalarType<T[P], AggregateLigneEtatAvancement[P]>
  }




  export type LigneEtatAvancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneEtatAvancementWhereInput
    orderBy?: LigneEtatAvancementOrderByWithAggregationInput | LigneEtatAvancementOrderByWithAggregationInput[]
    by: LigneEtatAvancementScalarFieldEnum[] | LigneEtatAvancementScalarFieldEnum
    having?: LigneEtatAvancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneEtatAvancementCountAggregateInputType | true
    _avg?: LigneEtatAvancementAvgAggregateInputType
    _sum?: LigneEtatAvancementSumAggregateInputType
    _min?: LigneEtatAvancementMinAggregateInputType
    _max?: LigneEtatAvancementMaxAggregateInputType
  }

  export type LigneEtatAvancementGroupByOutputType = {
    id: number
    etatAvancementId: number
    ligneCommandeId: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: Date
    updatedAt: Date
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
    _count: LigneEtatAvancementCountAggregateOutputType | null
    _avg: LigneEtatAvancementAvgAggregateOutputType | null
    _sum: LigneEtatAvancementSumAggregateOutputType | null
    _min: LigneEtatAvancementMinAggregateOutputType | null
    _max: LigneEtatAvancementMaxAggregateOutputType | null
  }

  type GetLigneEtatAvancementGroupByPayload<T extends LigneEtatAvancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneEtatAvancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneEtatAvancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneEtatAvancementGroupByOutputType[P]>
            : GetScalarType<T[P], LigneEtatAvancementGroupByOutputType[P]>
        }
      >
    >


  export type LigneEtatAvancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etatAvancementId?: boolean
    ligneCommandeId?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean
    description?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    type?: boolean
    unite?: boolean
    etatAvancement?: boolean | EtatAvancementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneEtatAvancement"]>



  export type LigneEtatAvancementSelectScalar = {
    id?: boolean
    etatAvancementId?: boolean
    ligneCommandeId?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean
    description?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    type?: boolean
    unite?: boolean
  }

  export type LigneEtatAvancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "etatAvancementId" | "ligneCommandeId" | "quantitePrecedente" | "quantiteActuelle" | "quantiteTotale" | "montantPrecedent" | "montantActuel" | "montantTotal" | "createdAt" | "updatedAt" | "article" | "description" | "prixUnitaire" | "quantite" | "type" | "unite", ExtArgs["result"]["ligneEtatAvancement"]>
  export type LigneEtatAvancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etatAvancement?: boolean | EtatAvancementDefaultArgs<ExtArgs>
  }

  export type $LigneEtatAvancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneEtatAvancement"
    objects: {
      etatAvancement: Prisma.$EtatAvancementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etatAvancementId: number
      ligneCommandeId: number
      quantitePrecedente: number
      quantiteActuelle: number
      quantiteTotale: number
      montantPrecedent: number
      montantActuel: number
      montantTotal: number
      createdAt: Date
      updatedAt: Date
      article: string
      description: string
      prixUnitaire: number
      quantite: number
      type: string
      unite: string
    }, ExtArgs["result"]["ligneEtatAvancement"]>
    composites: {}
  }

  type LigneEtatAvancementGetPayload<S extends boolean | null | undefined | LigneEtatAvancementDefaultArgs> = $Result.GetResult<Prisma.$LigneEtatAvancementPayload, S>

  type LigneEtatAvancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneEtatAvancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneEtatAvancementCountAggregateInputType | true
    }

  export interface LigneEtatAvancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneEtatAvancement'], meta: { name: 'LigneEtatAvancement' } }
    /**
     * Find zero or one LigneEtatAvancement that matches the filter.
     * @param {LigneEtatAvancementFindUniqueArgs} args - Arguments to find a LigneEtatAvancement
     * @example
     * // Get one LigneEtatAvancement
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneEtatAvancementFindUniqueArgs>(args: SelectSubset<T, LigneEtatAvancementFindUniqueArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LigneEtatAvancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneEtatAvancementFindUniqueOrThrowArgs} args - Arguments to find a LigneEtatAvancement
     * @example
     * // Get one LigneEtatAvancement
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneEtatAvancementFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneEtatAvancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneEtatAvancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementFindFirstArgs} args - Arguments to find a LigneEtatAvancement
     * @example
     * // Get one LigneEtatAvancement
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneEtatAvancementFindFirstArgs>(args?: SelectSubset<T, LigneEtatAvancementFindFirstArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneEtatAvancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementFindFirstOrThrowArgs} args - Arguments to find a LigneEtatAvancement
     * @example
     * // Get one LigneEtatAvancement
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneEtatAvancementFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneEtatAvancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LigneEtatAvancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneEtatAvancements
     * const ligneEtatAvancements = await prisma.ligneEtatAvancement.findMany()
     * 
     * // Get first 10 LigneEtatAvancements
     * const ligneEtatAvancements = await prisma.ligneEtatAvancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneEtatAvancementWithIdOnly = await prisma.ligneEtatAvancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneEtatAvancementFindManyArgs>(args?: SelectSubset<T, LigneEtatAvancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LigneEtatAvancement.
     * @param {LigneEtatAvancementCreateArgs} args - Arguments to create a LigneEtatAvancement.
     * @example
     * // Create one LigneEtatAvancement
     * const LigneEtatAvancement = await prisma.ligneEtatAvancement.create({
     *   data: {
     *     // ... data to create a LigneEtatAvancement
     *   }
     * })
     * 
     */
    create<T extends LigneEtatAvancementCreateArgs>(args: SelectSubset<T, LigneEtatAvancementCreateArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LigneEtatAvancements.
     * @param {LigneEtatAvancementCreateManyArgs} args - Arguments to create many LigneEtatAvancements.
     * @example
     * // Create many LigneEtatAvancements
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneEtatAvancementCreateManyArgs>(args?: SelectSubset<T, LigneEtatAvancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LigneEtatAvancement.
     * @param {LigneEtatAvancementDeleteArgs} args - Arguments to delete one LigneEtatAvancement.
     * @example
     * // Delete one LigneEtatAvancement
     * const LigneEtatAvancement = await prisma.ligneEtatAvancement.delete({
     *   where: {
     *     // ... filter to delete one LigneEtatAvancement
     *   }
     * })
     * 
     */
    delete<T extends LigneEtatAvancementDeleteArgs>(args: SelectSubset<T, LigneEtatAvancementDeleteArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LigneEtatAvancement.
     * @param {LigneEtatAvancementUpdateArgs} args - Arguments to update one LigneEtatAvancement.
     * @example
     * // Update one LigneEtatAvancement
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneEtatAvancementUpdateArgs>(args: SelectSubset<T, LigneEtatAvancementUpdateArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LigneEtatAvancements.
     * @param {LigneEtatAvancementDeleteManyArgs} args - Arguments to filter LigneEtatAvancements to delete.
     * @example
     * // Delete a few LigneEtatAvancements
     * const { count } = await prisma.ligneEtatAvancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneEtatAvancementDeleteManyArgs>(args?: SelectSubset<T, LigneEtatAvancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneEtatAvancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneEtatAvancements
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneEtatAvancementUpdateManyArgs>(args: SelectSubset<T, LigneEtatAvancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneEtatAvancement.
     * @param {LigneEtatAvancementUpsertArgs} args - Arguments to update or create a LigneEtatAvancement.
     * @example
     * // Update or create a LigneEtatAvancement
     * const ligneEtatAvancement = await prisma.ligneEtatAvancement.upsert({
     *   create: {
     *     // ... data to create a LigneEtatAvancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneEtatAvancement we want to update
     *   }
     * })
     */
    upsert<T extends LigneEtatAvancementUpsertArgs>(args: SelectSubset<T, LigneEtatAvancementUpsertArgs<ExtArgs>>): Prisma__LigneEtatAvancementClient<$Result.GetResult<Prisma.$LigneEtatAvancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LigneEtatAvancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementCountArgs} args - Arguments to filter LigneEtatAvancements to count.
     * @example
     * // Count the number of LigneEtatAvancements
     * const count = await prisma.ligneEtatAvancement.count({
     *   where: {
     *     // ... the filter for the LigneEtatAvancements we want to count
     *   }
     * })
    **/
    count<T extends LigneEtatAvancementCountArgs>(
      args?: Subset<T, LigneEtatAvancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneEtatAvancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneEtatAvancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneEtatAvancementAggregateArgs>(args: Subset<T, LigneEtatAvancementAggregateArgs>): Prisma.PrismaPromise<GetLigneEtatAvancementAggregateType<T>>

    /**
     * Group by LigneEtatAvancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAvancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneEtatAvancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneEtatAvancementGroupByArgs['orderBy'] }
        : { orderBy?: LigneEtatAvancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneEtatAvancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneEtatAvancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneEtatAvancement model
   */
  readonly fields: LigneEtatAvancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneEtatAvancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneEtatAvancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etatAvancement<T extends EtatAvancementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtatAvancementDefaultArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneEtatAvancement model
   */ 
  interface LigneEtatAvancementFieldRefs {
    readonly id: FieldRef<"LigneEtatAvancement", 'Int'>
    readonly etatAvancementId: FieldRef<"LigneEtatAvancement", 'Int'>
    readonly ligneCommandeId: FieldRef<"LigneEtatAvancement", 'Int'>
    readonly quantitePrecedente: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly quantiteActuelle: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly quantiteTotale: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly montantPrecedent: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly montantActuel: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly montantTotal: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly createdAt: FieldRef<"LigneEtatAvancement", 'DateTime'>
    readonly updatedAt: FieldRef<"LigneEtatAvancement", 'DateTime'>
    readonly article: FieldRef<"LigneEtatAvancement", 'String'>
    readonly description: FieldRef<"LigneEtatAvancement", 'String'>
    readonly prixUnitaire: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly quantite: FieldRef<"LigneEtatAvancement", 'Float'>
    readonly type: FieldRef<"LigneEtatAvancement", 'String'>
    readonly unite: FieldRef<"LigneEtatAvancement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LigneEtatAvancement findUnique
   */
  export type LigneEtatAvancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtatAvancement to fetch.
     */
    where: LigneEtatAvancementWhereUniqueInput
  }

  /**
   * LigneEtatAvancement findUniqueOrThrow
   */
  export type LigneEtatAvancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtatAvancement to fetch.
     */
    where: LigneEtatAvancementWhereUniqueInput
  }

  /**
   * LigneEtatAvancement findFirst
   */
  export type LigneEtatAvancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtatAvancement to fetch.
     */
    where?: LigneEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtatAvancements to fetch.
     */
    orderBy?: LigneEtatAvancementOrderByWithRelationInput | LigneEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneEtatAvancements.
     */
    cursor?: LigneEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneEtatAvancements.
     */
    distinct?: LigneEtatAvancementScalarFieldEnum | LigneEtatAvancementScalarFieldEnum[]
  }

  /**
   * LigneEtatAvancement findFirstOrThrow
   */
  export type LigneEtatAvancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtatAvancement to fetch.
     */
    where?: LigneEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtatAvancements to fetch.
     */
    orderBy?: LigneEtatAvancementOrderByWithRelationInput | LigneEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneEtatAvancements.
     */
    cursor?: LigneEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneEtatAvancements.
     */
    distinct?: LigneEtatAvancementScalarFieldEnum | LigneEtatAvancementScalarFieldEnum[]
  }

  /**
   * LigneEtatAvancement findMany
   */
  export type LigneEtatAvancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtatAvancements to fetch.
     */
    where?: LigneEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtatAvancements to fetch.
     */
    orderBy?: LigneEtatAvancementOrderByWithRelationInput | LigneEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneEtatAvancements.
     */
    cursor?: LigneEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtatAvancements.
     */
    skip?: number
    distinct?: LigneEtatAvancementScalarFieldEnum | LigneEtatAvancementScalarFieldEnum[]
  }

  /**
   * LigneEtatAvancement create
   */
  export type LigneEtatAvancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneEtatAvancement.
     */
    data: XOR<LigneEtatAvancementCreateInput, LigneEtatAvancementUncheckedCreateInput>
  }

  /**
   * LigneEtatAvancement createMany
   */
  export type LigneEtatAvancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneEtatAvancements.
     */
    data: LigneEtatAvancementCreateManyInput | LigneEtatAvancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneEtatAvancement update
   */
  export type LigneEtatAvancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneEtatAvancement.
     */
    data: XOR<LigneEtatAvancementUpdateInput, LigneEtatAvancementUncheckedUpdateInput>
    /**
     * Choose, which LigneEtatAvancement to update.
     */
    where: LigneEtatAvancementWhereUniqueInput
  }

  /**
   * LigneEtatAvancement updateMany
   */
  export type LigneEtatAvancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneEtatAvancements.
     */
    data: XOR<LigneEtatAvancementUpdateManyMutationInput, LigneEtatAvancementUncheckedUpdateManyInput>
    /**
     * Filter which LigneEtatAvancements to update
     */
    where?: LigneEtatAvancementWhereInput
    /**
     * Limit how many LigneEtatAvancements to update.
     */
    limit?: number
  }

  /**
   * LigneEtatAvancement upsert
   */
  export type LigneEtatAvancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneEtatAvancement to update in case it exists.
     */
    where: LigneEtatAvancementWhereUniqueInput
    /**
     * In case the LigneEtatAvancement found by the `where` argument doesn't exist, create a new LigneEtatAvancement with this data.
     */
    create: XOR<LigneEtatAvancementCreateInput, LigneEtatAvancementUncheckedCreateInput>
    /**
     * In case the LigneEtatAvancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneEtatAvancementUpdateInput, LigneEtatAvancementUncheckedUpdateInput>
  }

  /**
   * LigneEtatAvancement delete
   */
  export type LigneEtatAvancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter which LigneEtatAvancement to delete.
     */
    where: LigneEtatAvancementWhereUniqueInput
  }

  /**
   * LigneEtatAvancement deleteMany
   */
  export type LigneEtatAvancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneEtatAvancements to delete
     */
    where?: LigneEtatAvancementWhereInput
    /**
     * Limit how many LigneEtatAvancements to delete.
     */
    limit?: number
  }

  /**
   * LigneEtatAvancement without action
   */
  export type LigneEtatAvancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtatAvancement
     */
    select?: LigneEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtatAvancement
     */
    omit?: LigneEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatAvancementInclude<ExtArgs> | null
  }


  /**
   * Model AvenantEtatAvancement
   */

  export type AggregateAvenantEtatAvancement = {
    _count: AvenantEtatAvancementCountAggregateOutputType | null
    _avg: AvenantEtatAvancementAvgAggregateOutputType | null
    _sum: AvenantEtatAvancementSumAggregateOutputType | null
    _min: AvenantEtatAvancementMinAggregateOutputType | null
    _max: AvenantEtatAvancementMaxAggregateOutputType | null
  }

  export type AvenantEtatAvancementAvgAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
  }

  export type AvenantEtatAvancementSumAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
  }

  export type AvenantEtatAvancementMinAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvenantEtatAvancementMaxAggregateOutputType = {
    id: number | null
    etatAvancementId: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvenantEtatAvancementCountAggregateOutputType = {
    id: number
    etatAvancementId: number
    article: number
    description: number
    type: number
    unite: number
    prixUnitaire: number
    quantite: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvenantEtatAvancementAvgAggregateInputType = {
    id?: true
    etatAvancementId?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
  }

  export type AvenantEtatAvancementSumAggregateInputType = {
    id?: true
    etatAvancementId?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
  }

  export type AvenantEtatAvancementMinAggregateInputType = {
    id?: true
    etatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvenantEtatAvancementMaxAggregateInputType = {
    id?: true
    etatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvenantEtatAvancementCountAggregateInputType = {
    id?: true
    etatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvenantEtatAvancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvenantEtatAvancement to aggregate.
     */
    where?: AvenantEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvenantEtatAvancements to fetch.
     */
    orderBy?: AvenantEtatAvancementOrderByWithRelationInput | AvenantEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvenantEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvenantEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvenantEtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvenantEtatAvancements
    **/
    _count?: true | AvenantEtatAvancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvenantEtatAvancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvenantEtatAvancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvenantEtatAvancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvenantEtatAvancementMaxAggregateInputType
  }

  export type GetAvenantEtatAvancementAggregateType<T extends AvenantEtatAvancementAggregateArgs> = {
        [P in keyof T & keyof AggregateAvenantEtatAvancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvenantEtatAvancement[P]>
      : GetScalarType<T[P], AggregateAvenantEtatAvancement[P]>
  }




  export type AvenantEtatAvancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvenantEtatAvancementWhereInput
    orderBy?: AvenantEtatAvancementOrderByWithAggregationInput | AvenantEtatAvancementOrderByWithAggregationInput[]
    by: AvenantEtatAvancementScalarFieldEnum[] | AvenantEtatAvancementScalarFieldEnum
    having?: AvenantEtatAvancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvenantEtatAvancementCountAggregateInputType | true
    _avg?: AvenantEtatAvancementAvgAggregateInputType
    _sum?: AvenantEtatAvancementSumAggregateInputType
    _min?: AvenantEtatAvancementMinAggregateInputType
    _max?: AvenantEtatAvancementMaxAggregateInputType
  }

  export type AvenantEtatAvancementGroupByOutputType = {
    id: number
    etatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: Date
    updatedAt: Date
    _count: AvenantEtatAvancementCountAggregateOutputType | null
    _avg: AvenantEtatAvancementAvgAggregateOutputType | null
    _sum: AvenantEtatAvancementSumAggregateOutputType | null
    _min: AvenantEtatAvancementMinAggregateOutputType | null
    _max: AvenantEtatAvancementMaxAggregateOutputType | null
  }

  type GetAvenantEtatAvancementGroupByPayload<T extends AvenantEtatAvancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvenantEtatAvancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvenantEtatAvancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvenantEtatAvancementGroupByOutputType[P]>
            : GetScalarType<T[P], AvenantEtatAvancementGroupByOutputType[P]>
        }
      >
    >


  export type AvenantEtatAvancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etatAvancementId?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    etatAvancement?: boolean | EtatAvancementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avenantEtatAvancement"]>



  export type AvenantEtatAvancementSelectScalar = {
    id?: boolean
    etatAvancementId?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvenantEtatAvancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "etatAvancementId" | "article" | "description" | "type" | "unite" | "prixUnitaire" | "quantite" | "quantitePrecedente" | "quantiteActuelle" | "quantiteTotale" | "montantPrecedent" | "montantActuel" | "montantTotal" | "createdAt" | "updatedAt", ExtArgs["result"]["avenantEtatAvancement"]>
  export type AvenantEtatAvancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etatAvancement?: boolean | EtatAvancementDefaultArgs<ExtArgs>
  }

  export type $AvenantEtatAvancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvenantEtatAvancement"
    objects: {
      etatAvancement: Prisma.$EtatAvancementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etatAvancementId: number
      article: string
      description: string
      type: string
      unite: string
      prixUnitaire: number
      quantite: number
      quantitePrecedente: number
      quantiteActuelle: number
      quantiteTotale: number
      montantPrecedent: number
      montantActuel: number
      montantTotal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["avenantEtatAvancement"]>
    composites: {}
  }

  type AvenantEtatAvancementGetPayload<S extends boolean | null | undefined | AvenantEtatAvancementDefaultArgs> = $Result.GetResult<Prisma.$AvenantEtatAvancementPayload, S>

  type AvenantEtatAvancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvenantEtatAvancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvenantEtatAvancementCountAggregateInputType | true
    }

  export interface AvenantEtatAvancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvenantEtatAvancement'], meta: { name: 'AvenantEtatAvancement' } }
    /**
     * Find zero or one AvenantEtatAvancement that matches the filter.
     * @param {AvenantEtatAvancementFindUniqueArgs} args - Arguments to find a AvenantEtatAvancement
     * @example
     * // Get one AvenantEtatAvancement
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvenantEtatAvancementFindUniqueArgs>(args: SelectSubset<T, AvenantEtatAvancementFindUniqueArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvenantEtatAvancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvenantEtatAvancementFindUniqueOrThrowArgs} args - Arguments to find a AvenantEtatAvancement
     * @example
     * // Get one AvenantEtatAvancement
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvenantEtatAvancementFindUniqueOrThrowArgs>(args: SelectSubset<T, AvenantEtatAvancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvenantEtatAvancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementFindFirstArgs} args - Arguments to find a AvenantEtatAvancement
     * @example
     * // Get one AvenantEtatAvancement
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvenantEtatAvancementFindFirstArgs>(args?: SelectSubset<T, AvenantEtatAvancementFindFirstArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvenantEtatAvancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementFindFirstOrThrowArgs} args - Arguments to find a AvenantEtatAvancement
     * @example
     * // Get one AvenantEtatAvancement
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvenantEtatAvancementFindFirstOrThrowArgs>(args?: SelectSubset<T, AvenantEtatAvancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvenantEtatAvancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvenantEtatAvancements
     * const avenantEtatAvancements = await prisma.avenantEtatAvancement.findMany()
     * 
     * // Get first 10 AvenantEtatAvancements
     * const avenantEtatAvancements = await prisma.avenantEtatAvancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avenantEtatAvancementWithIdOnly = await prisma.avenantEtatAvancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvenantEtatAvancementFindManyArgs>(args?: SelectSubset<T, AvenantEtatAvancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvenantEtatAvancement.
     * @param {AvenantEtatAvancementCreateArgs} args - Arguments to create a AvenantEtatAvancement.
     * @example
     * // Create one AvenantEtatAvancement
     * const AvenantEtatAvancement = await prisma.avenantEtatAvancement.create({
     *   data: {
     *     // ... data to create a AvenantEtatAvancement
     *   }
     * })
     * 
     */
    create<T extends AvenantEtatAvancementCreateArgs>(args: SelectSubset<T, AvenantEtatAvancementCreateArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvenantEtatAvancements.
     * @param {AvenantEtatAvancementCreateManyArgs} args - Arguments to create many AvenantEtatAvancements.
     * @example
     * // Create many AvenantEtatAvancements
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvenantEtatAvancementCreateManyArgs>(args?: SelectSubset<T, AvenantEtatAvancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AvenantEtatAvancement.
     * @param {AvenantEtatAvancementDeleteArgs} args - Arguments to delete one AvenantEtatAvancement.
     * @example
     * // Delete one AvenantEtatAvancement
     * const AvenantEtatAvancement = await prisma.avenantEtatAvancement.delete({
     *   where: {
     *     // ... filter to delete one AvenantEtatAvancement
     *   }
     * })
     * 
     */
    delete<T extends AvenantEtatAvancementDeleteArgs>(args: SelectSubset<T, AvenantEtatAvancementDeleteArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvenantEtatAvancement.
     * @param {AvenantEtatAvancementUpdateArgs} args - Arguments to update one AvenantEtatAvancement.
     * @example
     * // Update one AvenantEtatAvancement
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvenantEtatAvancementUpdateArgs>(args: SelectSubset<T, AvenantEtatAvancementUpdateArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvenantEtatAvancements.
     * @param {AvenantEtatAvancementDeleteManyArgs} args - Arguments to filter AvenantEtatAvancements to delete.
     * @example
     * // Delete a few AvenantEtatAvancements
     * const { count } = await prisma.avenantEtatAvancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvenantEtatAvancementDeleteManyArgs>(args?: SelectSubset<T, AvenantEtatAvancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvenantEtatAvancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvenantEtatAvancements
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvenantEtatAvancementUpdateManyArgs>(args: SelectSubset<T, AvenantEtatAvancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AvenantEtatAvancement.
     * @param {AvenantEtatAvancementUpsertArgs} args - Arguments to update or create a AvenantEtatAvancement.
     * @example
     * // Update or create a AvenantEtatAvancement
     * const avenantEtatAvancement = await prisma.avenantEtatAvancement.upsert({
     *   create: {
     *     // ... data to create a AvenantEtatAvancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvenantEtatAvancement we want to update
     *   }
     * })
     */
    upsert<T extends AvenantEtatAvancementUpsertArgs>(args: SelectSubset<T, AvenantEtatAvancementUpsertArgs<ExtArgs>>): Prisma__AvenantEtatAvancementClient<$Result.GetResult<Prisma.$AvenantEtatAvancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvenantEtatAvancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementCountArgs} args - Arguments to filter AvenantEtatAvancements to count.
     * @example
     * // Count the number of AvenantEtatAvancements
     * const count = await prisma.avenantEtatAvancement.count({
     *   where: {
     *     // ... the filter for the AvenantEtatAvancements we want to count
     *   }
     * })
    **/
    count<T extends AvenantEtatAvancementCountArgs>(
      args?: Subset<T, AvenantEtatAvancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvenantEtatAvancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvenantEtatAvancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvenantEtatAvancementAggregateArgs>(args: Subset<T, AvenantEtatAvancementAggregateArgs>): Prisma.PrismaPromise<GetAvenantEtatAvancementAggregateType<T>>

    /**
     * Group by AvenantEtatAvancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantEtatAvancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvenantEtatAvancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvenantEtatAvancementGroupByArgs['orderBy'] }
        : { orderBy?: AvenantEtatAvancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvenantEtatAvancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvenantEtatAvancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvenantEtatAvancement model
   */
  readonly fields: AvenantEtatAvancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvenantEtatAvancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvenantEtatAvancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etatAvancement<T extends EtatAvancementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtatAvancementDefaultArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvenantEtatAvancement model
   */ 
  interface AvenantEtatAvancementFieldRefs {
    readonly id: FieldRef<"AvenantEtatAvancement", 'Int'>
    readonly etatAvancementId: FieldRef<"AvenantEtatAvancement", 'Int'>
    readonly article: FieldRef<"AvenantEtatAvancement", 'String'>
    readonly description: FieldRef<"AvenantEtatAvancement", 'String'>
    readonly type: FieldRef<"AvenantEtatAvancement", 'String'>
    readonly unite: FieldRef<"AvenantEtatAvancement", 'String'>
    readonly prixUnitaire: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly quantite: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly quantitePrecedente: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly quantiteActuelle: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly quantiteTotale: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly montantPrecedent: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly montantActuel: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly montantTotal: FieldRef<"AvenantEtatAvancement", 'Float'>
    readonly createdAt: FieldRef<"AvenantEtatAvancement", 'DateTime'>
    readonly updatedAt: FieldRef<"AvenantEtatAvancement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AvenantEtatAvancement findUnique
   */
  export type AvenantEtatAvancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which AvenantEtatAvancement to fetch.
     */
    where: AvenantEtatAvancementWhereUniqueInput
  }

  /**
   * AvenantEtatAvancement findUniqueOrThrow
   */
  export type AvenantEtatAvancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which AvenantEtatAvancement to fetch.
     */
    where: AvenantEtatAvancementWhereUniqueInput
  }

  /**
   * AvenantEtatAvancement findFirst
   */
  export type AvenantEtatAvancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which AvenantEtatAvancement to fetch.
     */
    where?: AvenantEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvenantEtatAvancements to fetch.
     */
    orderBy?: AvenantEtatAvancementOrderByWithRelationInput | AvenantEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvenantEtatAvancements.
     */
    cursor?: AvenantEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvenantEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvenantEtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvenantEtatAvancements.
     */
    distinct?: AvenantEtatAvancementScalarFieldEnum | AvenantEtatAvancementScalarFieldEnum[]
  }

  /**
   * AvenantEtatAvancement findFirstOrThrow
   */
  export type AvenantEtatAvancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which AvenantEtatAvancement to fetch.
     */
    where?: AvenantEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvenantEtatAvancements to fetch.
     */
    orderBy?: AvenantEtatAvancementOrderByWithRelationInput | AvenantEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvenantEtatAvancements.
     */
    cursor?: AvenantEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvenantEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvenantEtatAvancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvenantEtatAvancements.
     */
    distinct?: AvenantEtatAvancementScalarFieldEnum | AvenantEtatAvancementScalarFieldEnum[]
  }

  /**
   * AvenantEtatAvancement findMany
   */
  export type AvenantEtatAvancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter, which AvenantEtatAvancements to fetch.
     */
    where?: AvenantEtatAvancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvenantEtatAvancements to fetch.
     */
    orderBy?: AvenantEtatAvancementOrderByWithRelationInput | AvenantEtatAvancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvenantEtatAvancements.
     */
    cursor?: AvenantEtatAvancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvenantEtatAvancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvenantEtatAvancements.
     */
    skip?: number
    distinct?: AvenantEtatAvancementScalarFieldEnum | AvenantEtatAvancementScalarFieldEnum[]
  }

  /**
   * AvenantEtatAvancement create
   */
  export type AvenantEtatAvancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * The data needed to create a AvenantEtatAvancement.
     */
    data: XOR<AvenantEtatAvancementCreateInput, AvenantEtatAvancementUncheckedCreateInput>
  }

  /**
   * AvenantEtatAvancement createMany
   */
  export type AvenantEtatAvancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvenantEtatAvancements.
     */
    data: AvenantEtatAvancementCreateManyInput | AvenantEtatAvancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvenantEtatAvancement update
   */
  export type AvenantEtatAvancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * The data needed to update a AvenantEtatAvancement.
     */
    data: XOR<AvenantEtatAvancementUpdateInput, AvenantEtatAvancementUncheckedUpdateInput>
    /**
     * Choose, which AvenantEtatAvancement to update.
     */
    where: AvenantEtatAvancementWhereUniqueInput
  }

  /**
   * AvenantEtatAvancement updateMany
   */
  export type AvenantEtatAvancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvenantEtatAvancements.
     */
    data: XOR<AvenantEtatAvancementUpdateManyMutationInput, AvenantEtatAvancementUncheckedUpdateManyInput>
    /**
     * Filter which AvenantEtatAvancements to update
     */
    where?: AvenantEtatAvancementWhereInput
    /**
     * Limit how many AvenantEtatAvancements to update.
     */
    limit?: number
  }

  /**
   * AvenantEtatAvancement upsert
   */
  export type AvenantEtatAvancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * The filter to search for the AvenantEtatAvancement to update in case it exists.
     */
    where: AvenantEtatAvancementWhereUniqueInput
    /**
     * In case the AvenantEtatAvancement found by the `where` argument doesn't exist, create a new AvenantEtatAvancement with this data.
     */
    create: XOR<AvenantEtatAvancementCreateInput, AvenantEtatAvancementUncheckedCreateInput>
    /**
     * In case the AvenantEtatAvancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvenantEtatAvancementUpdateInput, AvenantEtatAvancementUncheckedUpdateInput>
  }

  /**
   * AvenantEtatAvancement delete
   */
  export type AvenantEtatAvancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
    /**
     * Filter which AvenantEtatAvancement to delete.
     */
    where: AvenantEtatAvancementWhereUniqueInput
  }

  /**
   * AvenantEtatAvancement deleteMany
   */
  export type AvenantEtatAvancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvenantEtatAvancements to delete
     */
    where?: AvenantEtatAvancementWhereInput
    /**
     * Limit how many AvenantEtatAvancements to delete.
     */
    limit?: number
  }

  /**
   * AvenantEtatAvancement without action
   */
  export type AvenantEtatAvancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvenantEtatAvancement
     */
    select?: AvenantEtatAvancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvenantEtatAvancement
     */
    omit?: AvenantEtatAvancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantEtatAvancementInclude<ExtArgs> | null
  }


  /**
   * Model companysettings
   */

  export type AggregateCompanysettings = {
    _count: CompanysettingsCountAggregateOutputType | null
    _min: CompanysettingsMinAggregateOutputType | null
    _max: CompanysettingsMaxAggregateOutputType | null
  }

  export type CompanysettingsMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    zipCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    tva: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailFrom: string | null
    emailFromName: string | null
    emailHost: string | null
    emailPassword: string | null
    emailPort: string | null
    emailSecure: boolean | null
    emailUser: string | null
    iban: string | null
  }

  export type CompanysettingsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    zipCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    tva: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailFrom: string | null
    emailFromName: string | null
    emailHost: string | null
    emailPassword: string | null
    emailPort: string | null
    emailSecure: boolean | null
    emailUser: string | null
    iban: string | null
  }

  export type CompanysettingsCountAggregateOutputType = {
    id: number
    name: number
    address: number
    zipCode: number
    city: number
    phone: number
    email: number
    tva: number
    logo: number
    createdAt: number
    updatedAt: number
    emailFrom: number
    emailFromName: number
    emailHost: number
    emailPassword: number
    emailPort: number
    emailSecure: number
    emailUser: number
    iban: number
    _all: number
  }


  export type CompanysettingsMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    zipCode?: true
    city?: true
    phone?: true
    email?: true
    tva?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    emailFrom?: true
    emailFromName?: true
    emailHost?: true
    emailPassword?: true
    emailPort?: true
    emailSecure?: true
    emailUser?: true
    iban?: true
  }

  export type CompanysettingsMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    zipCode?: true
    city?: true
    phone?: true
    email?: true
    tva?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    emailFrom?: true
    emailFromName?: true
    emailHost?: true
    emailPassword?: true
    emailPort?: true
    emailSecure?: true
    emailUser?: true
    iban?: true
  }

  export type CompanysettingsCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    zipCode?: true
    city?: true
    phone?: true
    email?: true
    tva?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    emailFrom?: true
    emailFromName?: true
    emailHost?: true
    emailPassword?: true
    emailPort?: true
    emailSecure?: true
    emailUser?: true
    iban?: true
    _all?: true
  }

  export type CompanysettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companysettings to aggregate.
     */
    where?: companysettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companysettings to fetch.
     */
    orderBy?: companysettingsOrderByWithRelationInput | companysettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companysettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companysettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companysettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companysettings
    **/
    _count?: true | CompanysettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanysettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanysettingsMaxAggregateInputType
  }

  export type GetCompanysettingsAggregateType<T extends CompanysettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanysettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanysettings[P]>
      : GetScalarType<T[P], AggregateCompanysettings[P]>
  }




  export type companysettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companysettingsWhereInput
    orderBy?: companysettingsOrderByWithAggregationInput | companysettingsOrderByWithAggregationInput[]
    by: CompanysettingsScalarFieldEnum[] | CompanysettingsScalarFieldEnum
    having?: companysettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanysettingsCountAggregateInputType | true
    _min?: CompanysettingsMinAggregateInputType
    _max?: CompanysettingsMaxAggregateInputType
  }

  export type CompanysettingsGroupByOutputType = {
    id: string
    name: string
    address: string
    zipCode: string
    city: string
    phone: string
    email: string
    tva: string
    logo: string | null
    createdAt: Date
    updatedAt: Date
    emailFrom: string | null
    emailFromName: string | null
    emailHost: string | null
    emailPassword: string | null
    emailPort: string | null
    emailSecure: boolean | null
    emailUser: string | null
    iban: string
    _count: CompanysettingsCountAggregateOutputType | null
    _min: CompanysettingsMinAggregateOutputType | null
    _max: CompanysettingsMaxAggregateOutputType | null
  }

  type GetCompanysettingsGroupByPayload<T extends companysettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanysettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanysettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanysettingsGroupByOutputType[P]>
            : GetScalarType<T[P], CompanysettingsGroupByOutputType[P]>
        }
      >
    >


  export type companysettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    zipCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    tva?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailFrom?: boolean
    emailFromName?: boolean
    emailHost?: boolean
    emailPassword?: boolean
    emailPort?: boolean
    emailSecure?: boolean
    emailUser?: boolean
    iban?: boolean
  }, ExtArgs["result"]["companysettings"]>



  export type companysettingsSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    zipCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    tva?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailFrom?: boolean
    emailFromName?: boolean
    emailHost?: boolean
    emailPassword?: boolean
    emailPort?: boolean
    emailSecure?: boolean
    emailUser?: boolean
    iban?: boolean
  }

  export type companysettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "zipCode" | "city" | "phone" | "email" | "tva" | "logo" | "createdAt" | "updatedAt" | "emailFrom" | "emailFromName" | "emailHost" | "emailPassword" | "emailPort" | "emailSecure" | "emailUser" | "iban", ExtArgs["result"]["companysettings"]>

  export type $companysettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companysettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      zipCode: string
      city: string
      phone: string
      email: string
      tva: string
      logo: string | null
      createdAt: Date
      updatedAt: Date
      emailFrom: string | null
      emailFromName: string | null
      emailHost: string | null
      emailPassword: string | null
      emailPort: string | null
      emailSecure: boolean | null
      emailUser: string | null
      iban: string
    }, ExtArgs["result"]["companysettings"]>
    composites: {}
  }

  type companysettingsGetPayload<S extends boolean | null | undefined | companysettingsDefaultArgs> = $Result.GetResult<Prisma.$companysettingsPayload, S>

  type companysettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companysettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanysettingsCountAggregateInputType | true
    }

  export interface companysettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companysettings'], meta: { name: 'companysettings' } }
    /**
     * Find zero or one Companysettings that matches the filter.
     * @param {companysettingsFindUniqueArgs} args - Arguments to find a Companysettings
     * @example
     * // Get one Companysettings
     * const companysettings = await prisma.companysettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companysettingsFindUniqueArgs>(args: SelectSubset<T, companysettingsFindUniqueArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companysettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companysettingsFindUniqueOrThrowArgs} args - Arguments to find a Companysettings
     * @example
     * // Get one Companysettings
     * const companysettings = await prisma.companysettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companysettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, companysettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companysettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companysettingsFindFirstArgs} args - Arguments to find a Companysettings
     * @example
     * // Get one Companysettings
     * const companysettings = await prisma.companysettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companysettingsFindFirstArgs>(args?: SelectSubset<T, companysettingsFindFirstArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companysettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companysettingsFindFirstOrThrowArgs} args - Arguments to find a Companysettings
     * @example
     * // Get one Companysettings
     * const companysettings = await prisma.companysettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companysettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, companysettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companysettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companysettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companysettings
     * const companysettings = await prisma.companysettings.findMany()
     * 
     * // Get first 10 Companysettings
     * const companysettings = await prisma.companysettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companysettingsWithIdOnly = await prisma.companysettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companysettingsFindManyArgs>(args?: SelectSubset<T, companysettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companysettings.
     * @param {companysettingsCreateArgs} args - Arguments to create a Companysettings.
     * @example
     * // Create one Companysettings
     * const Companysettings = await prisma.companysettings.create({
     *   data: {
     *     // ... data to create a Companysettings
     *   }
     * })
     * 
     */
    create<T extends companysettingsCreateArgs>(args: SelectSubset<T, companysettingsCreateArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companysettings.
     * @param {companysettingsCreateManyArgs} args - Arguments to create many Companysettings.
     * @example
     * // Create many Companysettings
     * const companysettings = await prisma.companysettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companysettingsCreateManyArgs>(args?: SelectSubset<T, companysettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Companysettings.
     * @param {companysettingsDeleteArgs} args - Arguments to delete one Companysettings.
     * @example
     * // Delete one Companysettings
     * const Companysettings = await prisma.companysettings.delete({
     *   where: {
     *     // ... filter to delete one Companysettings
     *   }
     * })
     * 
     */
    delete<T extends companysettingsDeleteArgs>(args: SelectSubset<T, companysettingsDeleteArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companysettings.
     * @param {companysettingsUpdateArgs} args - Arguments to update one Companysettings.
     * @example
     * // Update one Companysettings
     * const companysettings = await prisma.companysettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companysettingsUpdateArgs>(args: SelectSubset<T, companysettingsUpdateArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companysettings.
     * @param {companysettingsDeleteManyArgs} args - Arguments to filter Companysettings to delete.
     * @example
     * // Delete a few Companysettings
     * const { count } = await prisma.companysettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companysettingsDeleteManyArgs>(args?: SelectSubset<T, companysettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companysettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companysettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companysettings
     * const companysettings = await prisma.companysettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companysettingsUpdateManyArgs>(args: SelectSubset<T, companysettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companysettings.
     * @param {companysettingsUpsertArgs} args - Arguments to update or create a Companysettings.
     * @example
     * // Update or create a Companysettings
     * const companysettings = await prisma.companysettings.upsert({
     *   create: {
     *     // ... data to create a Companysettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companysettings we want to update
     *   }
     * })
     */
    upsert<T extends companysettingsUpsertArgs>(args: SelectSubset<T, companysettingsUpsertArgs<ExtArgs>>): Prisma__companysettingsClient<$Result.GetResult<Prisma.$companysettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companysettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companysettingsCountArgs} args - Arguments to filter Companysettings to count.
     * @example
     * // Count the number of Companysettings
     * const count = await prisma.companysettings.count({
     *   where: {
     *     // ... the filter for the Companysettings we want to count
     *   }
     * })
    **/
    count<T extends companysettingsCountArgs>(
      args?: Subset<T, companysettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanysettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companysettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanysettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanysettingsAggregateArgs>(args: Subset<T, CompanysettingsAggregateArgs>): Prisma.PrismaPromise<GetCompanysettingsAggregateType<T>>

    /**
     * Group by Companysettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companysettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companysettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companysettingsGroupByArgs['orderBy'] }
        : { orderBy?: companysettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companysettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanysettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companysettings model
   */
  readonly fields: companysettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companysettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companysettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companysettings model
   */ 
  interface companysettingsFieldRefs {
    readonly id: FieldRef<"companysettings", 'String'>
    readonly name: FieldRef<"companysettings", 'String'>
    readonly address: FieldRef<"companysettings", 'String'>
    readonly zipCode: FieldRef<"companysettings", 'String'>
    readonly city: FieldRef<"companysettings", 'String'>
    readonly phone: FieldRef<"companysettings", 'String'>
    readonly email: FieldRef<"companysettings", 'String'>
    readonly tva: FieldRef<"companysettings", 'String'>
    readonly logo: FieldRef<"companysettings", 'String'>
    readonly createdAt: FieldRef<"companysettings", 'DateTime'>
    readonly updatedAt: FieldRef<"companysettings", 'DateTime'>
    readonly emailFrom: FieldRef<"companysettings", 'String'>
    readonly emailFromName: FieldRef<"companysettings", 'String'>
    readonly emailHost: FieldRef<"companysettings", 'String'>
    readonly emailPassword: FieldRef<"companysettings", 'String'>
    readonly emailPort: FieldRef<"companysettings", 'String'>
    readonly emailSecure: FieldRef<"companysettings", 'Boolean'>
    readonly emailUser: FieldRef<"companysettings", 'String'>
    readonly iban: FieldRef<"companysettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * companysettings findUnique
   */
  export type companysettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * Filter, which companysettings to fetch.
     */
    where: companysettingsWhereUniqueInput
  }

  /**
   * companysettings findUniqueOrThrow
   */
  export type companysettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * Filter, which companysettings to fetch.
     */
    where: companysettingsWhereUniqueInput
  }

  /**
   * companysettings findFirst
   */
  export type companysettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * Filter, which companysettings to fetch.
     */
    where?: companysettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companysettings to fetch.
     */
    orderBy?: companysettingsOrderByWithRelationInput | companysettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companysettings.
     */
    cursor?: companysettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companysettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companysettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companysettings.
     */
    distinct?: CompanysettingsScalarFieldEnum | CompanysettingsScalarFieldEnum[]
  }

  /**
   * companysettings findFirstOrThrow
   */
  export type companysettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * Filter, which companysettings to fetch.
     */
    where?: companysettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companysettings to fetch.
     */
    orderBy?: companysettingsOrderByWithRelationInput | companysettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companysettings.
     */
    cursor?: companysettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companysettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companysettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companysettings.
     */
    distinct?: CompanysettingsScalarFieldEnum | CompanysettingsScalarFieldEnum[]
  }

  /**
   * companysettings findMany
   */
  export type companysettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * Filter, which companysettings to fetch.
     */
    where?: companysettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companysettings to fetch.
     */
    orderBy?: companysettingsOrderByWithRelationInput | companysettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companysettings.
     */
    cursor?: companysettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companysettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companysettings.
     */
    skip?: number
    distinct?: CompanysettingsScalarFieldEnum | CompanysettingsScalarFieldEnum[]
  }

  /**
   * companysettings create
   */
  export type companysettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a companysettings.
     */
    data: XOR<companysettingsCreateInput, companysettingsUncheckedCreateInput>
  }

  /**
   * companysettings createMany
   */
  export type companysettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companysettings.
     */
    data: companysettingsCreateManyInput | companysettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companysettings update
   */
  export type companysettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a companysettings.
     */
    data: XOR<companysettingsUpdateInput, companysettingsUncheckedUpdateInput>
    /**
     * Choose, which companysettings to update.
     */
    where: companysettingsWhereUniqueInput
  }

  /**
   * companysettings updateMany
   */
  export type companysettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companysettings.
     */
    data: XOR<companysettingsUpdateManyMutationInput, companysettingsUncheckedUpdateManyInput>
    /**
     * Filter which companysettings to update
     */
    where?: companysettingsWhereInput
    /**
     * Limit how many companysettings to update.
     */
    limit?: number
  }

  /**
   * companysettings upsert
   */
  export type companysettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the companysettings to update in case it exists.
     */
    where: companysettingsWhereUniqueInput
    /**
     * In case the companysettings found by the `where` argument doesn't exist, create a new companysettings with this data.
     */
    create: XOR<companysettingsCreateInput, companysettingsUncheckedCreateInput>
    /**
     * In case the companysettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companysettingsUpdateInput, companysettingsUncheckedUpdateInput>
  }

  /**
   * companysettings delete
   */
  export type companysettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
    /**
     * Filter which companysettings to delete.
     */
    where: companysettingsWhereUniqueInput
  }

  /**
   * companysettings deleteMany
   */
  export type companysettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companysettings to delete
     */
    where?: companysettingsWhereInput
    /**
     * Limit how many companysettings to delete.
     */
    limit?: number
  }

  /**
   * companysettings without action
   */
  export type companysettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companysettings
     */
    select?: companysettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companysettings
     */
    omit?: companysettingsOmit<ExtArgs> | null
  }


  /**
   * Model CommandeSousTraitant
   */

  export type AggregateCommandeSousTraitant = {
    _count: CommandeSousTraitantCountAggregateOutputType | null
    _avg: CommandeSousTraitantAvgAggregateOutputType | null
    _sum: CommandeSousTraitantSumAggregateOutputType | null
    _min: CommandeSousTraitantMinAggregateOutputType | null
    _max: CommandeSousTraitantMaxAggregateOutputType | null
  }

  export type CommandeSousTraitantAvgAggregateOutputType = {
    id: number | null
    tauxTVA: number | null
    sousTotal: number | null
    tva: number | null
    total: number | null
  }

  export type CommandeSousTraitantSumAggregateOutputType = {
    id: number | null
    tauxTVA: number | null
    sousTotal: number | null
    tva: number | null
    total: number | null
  }

  export type CommandeSousTraitantMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    soustraitantId: string | null
    dateCommande: Date | null
    reference: string | null
    tauxTVA: number | null
    sousTotal: number | null
    tva: number | null
    total: number | null
    statut: string | null
    estVerrouillee: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeSousTraitantMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    soustraitantId: string | null
    dateCommande: Date | null
    reference: string | null
    tauxTVA: number | null
    sousTotal: number | null
    tva: number | null
    total: number | null
    statut: string | null
    estVerrouillee: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeSousTraitantCountAggregateOutputType = {
    id: number
    chantierId: number
    soustraitantId: number
    dateCommande: number
    reference: number
    tauxTVA: number
    sousTotal: number
    tva: number
    total: number
    statut: number
    estVerrouillee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandeSousTraitantAvgAggregateInputType = {
    id?: true
    tauxTVA?: true
    sousTotal?: true
    tva?: true
    total?: true
  }

  export type CommandeSousTraitantSumAggregateInputType = {
    id?: true
    tauxTVA?: true
    sousTotal?: true
    tva?: true
    total?: true
  }

  export type CommandeSousTraitantMinAggregateInputType = {
    id?: true
    chantierId?: true
    soustraitantId?: true
    dateCommande?: true
    reference?: true
    tauxTVA?: true
    sousTotal?: true
    tva?: true
    total?: true
    statut?: true
    estVerrouillee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeSousTraitantMaxAggregateInputType = {
    id?: true
    chantierId?: true
    soustraitantId?: true
    dateCommande?: true
    reference?: true
    tauxTVA?: true
    sousTotal?: true
    tva?: true
    total?: true
    statut?: true
    estVerrouillee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeSousTraitantCountAggregateInputType = {
    id?: true
    chantierId?: true
    soustraitantId?: true
    dateCommande?: true
    reference?: true
    tauxTVA?: true
    sousTotal?: true
    tva?: true
    total?: true
    statut?: true
    estVerrouillee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandeSousTraitantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandeSousTraitant to aggregate.
     */
    where?: CommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandeSousTraitants to fetch.
     */
    orderBy?: CommandeSousTraitantOrderByWithRelationInput | CommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandeSousTraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandeSousTraitants
    **/
    _count?: true | CommandeSousTraitantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandeSousTraitantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandeSousTraitantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandeSousTraitantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandeSousTraitantMaxAggregateInputType
  }

  export type GetCommandeSousTraitantAggregateType<T extends CommandeSousTraitantAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandeSousTraitant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandeSousTraitant[P]>
      : GetScalarType<T[P], AggregateCommandeSousTraitant[P]>
  }




  export type CommandeSousTraitantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeSousTraitantWhereInput
    orderBy?: CommandeSousTraitantOrderByWithAggregationInput | CommandeSousTraitantOrderByWithAggregationInput[]
    by: CommandeSousTraitantScalarFieldEnum[] | CommandeSousTraitantScalarFieldEnum
    having?: CommandeSousTraitantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandeSousTraitantCountAggregateInputType | true
    _avg?: CommandeSousTraitantAvgAggregateInputType
    _sum?: CommandeSousTraitantSumAggregateInputType
    _min?: CommandeSousTraitantMinAggregateInputType
    _max?: CommandeSousTraitantMaxAggregateInputType
  }

  export type CommandeSousTraitantGroupByOutputType = {
    id: number
    chantierId: string
    soustraitantId: string
    dateCommande: Date
    reference: string | null
    tauxTVA: number
    sousTotal: number
    tva: number
    total: number
    statut: string
    estVerrouillee: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommandeSousTraitantCountAggregateOutputType | null
    _avg: CommandeSousTraitantAvgAggregateOutputType | null
    _sum: CommandeSousTraitantSumAggregateOutputType | null
    _min: CommandeSousTraitantMinAggregateOutputType | null
    _max: CommandeSousTraitantMaxAggregateOutputType | null
  }

  type GetCommandeSousTraitantGroupByPayload<T extends CommandeSousTraitantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandeSousTraitantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandeSousTraitantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandeSousTraitantGroupByOutputType[P]>
            : GetScalarType<T[P], CommandeSousTraitantGroupByOutputType[P]>
        }
      >
    >


  export type CommandeSousTraitantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    soustraitantId?: boolean
    dateCommande?: boolean
    reference?: boolean
    tauxTVA?: boolean
    sousTotal?: boolean
    tva?: boolean
    total?: boolean
    statut?: boolean
    estVerrouillee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    soustraitant?: boolean | soustraitantDefaultArgs<ExtArgs>
    lignes?: boolean | CommandeSousTraitant$lignesArgs<ExtArgs>
    soustraitant_etat_avancement?: boolean | CommandeSousTraitant$soustraitant_etat_avancementArgs<ExtArgs>
    _count?: boolean | CommandeSousTraitantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandeSousTraitant"]>



  export type CommandeSousTraitantSelectScalar = {
    id?: boolean
    chantierId?: boolean
    soustraitantId?: boolean
    dateCommande?: boolean
    reference?: boolean
    tauxTVA?: boolean
    sousTotal?: boolean
    tva?: boolean
    total?: boolean
    statut?: boolean
    estVerrouillee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandeSousTraitantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "soustraitantId" | "dateCommande" | "reference" | "tauxTVA" | "sousTotal" | "tva" | "total" | "statut" | "estVerrouillee" | "createdAt" | "updatedAt", ExtArgs["result"]["commandeSousTraitant"]>
  export type CommandeSousTraitantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soustraitant?: boolean | soustraitantDefaultArgs<ExtArgs>
    lignes?: boolean | CommandeSousTraitant$lignesArgs<ExtArgs>
    soustraitant_etat_avancement?: boolean | CommandeSousTraitant$soustraitant_etat_avancementArgs<ExtArgs>
    _count?: boolean | CommandeSousTraitantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommandeSousTraitantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommandeSousTraitant"
    objects: {
      soustraitant: Prisma.$soustraitantPayload<ExtArgs>
      lignes: Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>[]
      soustraitant_etat_avancement: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      soustraitantId: string
      dateCommande: Date
      reference: string | null
      tauxTVA: number
      sousTotal: number
      tva: number
      total: number
      statut: string
      estVerrouillee: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commandeSousTraitant"]>
    composites: {}
  }

  type CommandeSousTraitantGetPayload<S extends boolean | null | undefined | CommandeSousTraitantDefaultArgs> = $Result.GetResult<Prisma.$CommandeSousTraitantPayload, S>

  type CommandeSousTraitantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandeSousTraitantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandeSousTraitantCountAggregateInputType | true
    }

  export interface CommandeSousTraitantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommandeSousTraitant'], meta: { name: 'CommandeSousTraitant' } }
    /**
     * Find zero or one CommandeSousTraitant that matches the filter.
     * @param {CommandeSousTraitantFindUniqueArgs} args - Arguments to find a CommandeSousTraitant
     * @example
     * // Get one CommandeSousTraitant
     * const commandeSousTraitant = await prisma.commandeSousTraitant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandeSousTraitantFindUniqueArgs>(args: SelectSubset<T, CommandeSousTraitantFindUniqueArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommandeSousTraitant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandeSousTraitantFindUniqueOrThrowArgs} args - Arguments to find a CommandeSousTraitant
     * @example
     * // Get one CommandeSousTraitant
     * const commandeSousTraitant = await prisma.commandeSousTraitant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandeSousTraitantFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandeSousTraitantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommandeSousTraitant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantFindFirstArgs} args - Arguments to find a CommandeSousTraitant
     * @example
     * // Get one CommandeSousTraitant
     * const commandeSousTraitant = await prisma.commandeSousTraitant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandeSousTraitantFindFirstArgs>(args?: SelectSubset<T, CommandeSousTraitantFindFirstArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommandeSousTraitant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantFindFirstOrThrowArgs} args - Arguments to find a CommandeSousTraitant
     * @example
     * // Get one CommandeSousTraitant
     * const commandeSousTraitant = await prisma.commandeSousTraitant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandeSousTraitantFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandeSousTraitantFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommandeSousTraitants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandeSousTraitants
     * const commandeSousTraitants = await prisma.commandeSousTraitant.findMany()
     * 
     * // Get first 10 CommandeSousTraitants
     * const commandeSousTraitants = await prisma.commandeSousTraitant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandeSousTraitantWithIdOnly = await prisma.commandeSousTraitant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandeSousTraitantFindManyArgs>(args?: SelectSubset<T, CommandeSousTraitantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommandeSousTraitant.
     * @param {CommandeSousTraitantCreateArgs} args - Arguments to create a CommandeSousTraitant.
     * @example
     * // Create one CommandeSousTraitant
     * const CommandeSousTraitant = await prisma.commandeSousTraitant.create({
     *   data: {
     *     // ... data to create a CommandeSousTraitant
     *   }
     * })
     * 
     */
    create<T extends CommandeSousTraitantCreateArgs>(args: SelectSubset<T, CommandeSousTraitantCreateArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommandeSousTraitants.
     * @param {CommandeSousTraitantCreateManyArgs} args - Arguments to create many CommandeSousTraitants.
     * @example
     * // Create many CommandeSousTraitants
     * const commandeSousTraitant = await prisma.commandeSousTraitant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandeSousTraitantCreateManyArgs>(args?: SelectSubset<T, CommandeSousTraitantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommandeSousTraitant.
     * @param {CommandeSousTraitantDeleteArgs} args - Arguments to delete one CommandeSousTraitant.
     * @example
     * // Delete one CommandeSousTraitant
     * const CommandeSousTraitant = await prisma.commandeSousTraitant.delete({
     *   where: {
     *     // ... filter to delete one CommandeSousTraitant
     *   }
     * })
     * 
     */
    delete<T extends CommandeSousTraitantDeleteArgs>(args: SelectSubset<T, CommandeSousTraitantDeleteArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommandeSousTraitant.
     * @param {CommandeSousTraitantUpdateArgs} args - Arguments to update one CommandeSousTraitant.
     * @example
     * // Update one CommandeSousTraitant
     * const commandeSousTraitant = await prisma.commandeSousTraitant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandeSousTraitantUpdateArgs>(args: SelectSubset<T, CommandeSousTraitantUpdateArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommandeSousTraitants.
     * @param {CommandeSousTraitantDeleteManyArgs} args - Arguments to filter CommandeSousTraitants to delete.
     * @example
     * // Delete a few CommandeSousTraitants
     * const { count } = await prisma.commandeSousTraitant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandeSousTraitantDeleteManyArgs>(args?: SelectSubset<T, CommandeSousTraitantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandeSousTraitants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandeSousTraitants
     * const commandeSousTraitant = await prisma.commandeSousTraitant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandeSousTraitantUpdateManyArgs>(args: SelectSubset<T, CommandeSousTraitantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommandeSousTraitant.
     * @param {CommandeSousTraitantUpsertArgs} args - Arguments to update or create a CommandeSousTraitant.
     * @example
     * // Update or create a CommandeSousTraitant
     * const commandeSousTraitant = await prisma.commandeSousTraitant.upsert({
     *   create: {
     *     // ... data to create a CommandeSousTraitant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandeSousTraitant we want to update
     *   }
     * })
     */
    upsert<T extends CommandeSousTraitantUpsertArgs>(args: SelectSubset<T, CommandeSousTraitantUpsertArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommandeSousTraitants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantCountArgs} args - Arguments to filter CommandeSousTraitants to count.
     * @example
     * // Count the number of CommandeSousTraitants
     * const count = await prisma.commandeSousTraitant.count({
     *   where: {
     *     // ... the filter for the CommandeSousTraitants we want to count
     *   }
     * })
    **/
    count<T extends CommandeSousTraitantCountArgs>(
      args?: Subset<T, CommandeSousTraitantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandeSousTraitantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandeSousTraitant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandeSousTraitantAggregateArgs>(args: Subset<T, CommandeSousTraitantAggregateArgs>): Prisma.PrismaPromise<GetCommandeSousTraitantAggregateType<T>>

    /**
     * Group by CommandeSousTraitant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeSousTraitantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandeSousTraitantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandeSousTraitantGroupByArgs['orderBy'] }
        : { orderBy?: CommandeSousTraitantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandeSousTraitantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandeSousTraitantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommandeSousTraitant model
   */
  readonly fields: CommandeSousTraitantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandeSousTraitant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandeSousTraitantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soustraitant<T extends soustraitantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, soustraitantDefaultArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lignes<T extends CommandeSousTraitant$lignesArgs<ExtArgs> = {}>(args?: Subset<T, CommandeSousTraitant$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soustraitant_etat_avancement<T extends CommandeSousTraitant$soustraitant_etat_avancementArgs<ExtArgs> = {}>(args?: Subset<T, CommandeSousTraitant$soustraitant_etat_avancementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommandeSousTraitant model
   */ 
  interface CommandeSousTraitantFieldRefs {
    readonly id: FieldRef<"CommandeSousTraitant", 'Int'>
    readonly chantierId: FieldRef<"CommandeSousTraitant", 'String'>
    readonly soustraitantId: FieldRef<"CommandeSousTraitant", 'String'>
    readonly dateCommande: FieldRef<"CommandeSousTraitant", 'DateTime'>
    readonly reference: FieldRef<"CommandeSousTraitant", 'String'>
    readonly tauxTVA: FieldRef<"CommandeSousTraitant", 'Float'>
    readonly sousTotal: FieldRef<"CommandeSousTraitant", 'Float'>
    readonly tva: FieldRef<"CommandeSousTraitant", 'Float'>
    readonly total: FieldRef<"CommandeSousTraitant", 'Float'>
    readonly statut: FieldRef<"CommandeSousTraitant", 'String'>
    readonly estVerrouillee: FieldRef<"CommandeSousTraitant", 'Boolean'>
    readonly createdAt: FieldRef<"CommandeSousTraitant", 'DateTime'>
    readonly updatedAt: FieldRef<"CommandeSousTraitant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommandeSousTraitant findUnique
   */
  export type CommandeSousTraitantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which CommandeSousTraitant to fetch.
     */
    where: CommandeSousTraitantWhereUniqueInput
  }

  /**
   * CommandeSousTraitant findUniqueOrThrow
   */
  export type CommandeSousTraitantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which CommandeSousTraitant to fetch.
     */
    where: CommandeSousTraitantWhereUniqueInput
  }

  /**
   * CommandeSousTraitant findFirst
   */
  export type CommandeSousTraitantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which CommandeSousTraitant to fetch.
     */
    where?: CommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandeSousTraitants to fetch.
     */
    orderBy?: CommandeSousTraitantOrderByWithRelationInput | CommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandeSousTraitants.
     */
    cursor?: CommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandeSousTraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandeSousTraitants.
     */
    distinct?: CommandeSousTraitantScalarFieldEnum | CommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * CommandeSousTraitant findFirstOrThrow
   */
  export type CommandeSousTraitantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which CommandeSousTraitant to fetch.
     */
    where?: CommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandeSousTraitants to fetch.
     */
    orderBy?: CommandeSousTraitantOrderByWithRelationInput | CommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandeSousTraitants.
     */
    cursor?: CommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandeSousTraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandeSousTraitants.
     */
    distinct?: CommandeSousTraitantScalarFieldEnum | CommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * CommandeSousTraitant findMany
   */
  export type CommandeSousTraitantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which CommandeSousTraitants to fetch.
     */
    where?: CommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandeSousTraitants to fetch.
     */
    orderBy?: CommandeSousTraitantOrderByWithRelationInput | CommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandeSousTraitants.
     */
    cursor?: CommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandeSousTraitants.
     */
    skip?: number
    distinct?: CommandeSousTraitantScalarFieldEnum | CommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * CommandeSousTraitant create
   */
  export type CommandeSousTraitantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * The data needed to create a CommandeSousTraitant.
     */
    data: XOR<CommandeSousTraitantCreateInput, CommandeSousTraitantUncheckedCreateInput>
  }

  /**
   * CommandeSousTraitant createMany
   */
  export type CommandeSousTraitantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommandeSousTraitants.
     */
    data: CommandeSousTraitantCreateManyInput | CommandeSousTraitantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommandeSousTraitant update
   */
  export type CommandeSousTraitantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * The data needed to update a CommandeSousTraitant.
     */
    data: XOR<CommandeSousTraitantUpdateInput, CommandeSousTraitantUncheckedUpdateInput>
    /**
     * Choose, which CommandeSousTraitant to update.
     */
    where: CommandeSousTraitantWhereUniqueInput
  }

  /**
   * CommandeSousTraitant updateMany
   */
  export type CommandeSousTraitantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommandeSousTraitants.
     */
    data: XOR<CommandeSousTraitantUpdateManyMutationInput, CommandeSousTraitantUncheckedUpdateManyInput>
    /**
     * Filter which CommandeSousTraitants to update
     */
    where?: CommandeSousTraitantWhereInput
    /**
     * Limit how many CommandeSousTraitants to update.
     */
    limit?: number
  }

  /**
   * CommandeSousTraitant upsert
   */
  export type CommandeSousTraitantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * The filter to search for the CommandeSousTraitant to update in case it exists.
     */
    where: CommandeSousTraitantWhereUniqueInput
    /**
     * In case the CommandeSousTraitant found by the `where` argument doesn't exist, create a new CommandeSousTraitant with this data.
     */
    create: XOR<CommandeSousTraitantCreateInput, CommandeSousTraitantUncheckedCreateInput>
    /**
     * In case the CommandeSousTraitant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandeSousTraitantUpdateInput, CommandeSousTraitantUncheckedUpdateInput>
  }

  /**
   * CommandeSousTraitant delete
   */
  export type CommandeSousTraitantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter which CommandeSousTraitant to delete.
     */
    where: CommandeSousTraitantWhereUniqueInput
  }

  /**
   * CommandeSousTraitant deleteMany
   */
  export type CommandeSousTraitantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandeSousTraitants to delete
     */
    where?: CommandeSousTraitantWhereInput
    /**
     * Limit how many CommandeSousTraitants to delete.
     */
    limit?: number
  }

  /**
   * CommandeSousTraitant.lignes
   */
  export type CommandeSousTraitant$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    where?: LigneCommandeSousTraitantWhereInput
    orderBy?: LigneCommandeSousTraitantOrderByWithRelationInput | LigneCommandeSousTraitantOrderByWithRelationInput[]
    cursor?: LigneCommandeSousTraitantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneCommandeSousTraitantScalarFieldEnum | LigneCommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * CommandeSousTraitant.soustraitant_etat_avancement
   */
  export type CommandeSousTraitant$soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    where?: soustraitant_etat_avancementWhereInput
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Soustraitant_etat_avancementScalarFieldEnum | Soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * CommandeSousTraitant without action
   */
  export type CommandeSousTraitantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
  }


  /**
   * Model LigneCommandeSousTraitant
   */

  export type AggregateLigneCommandeSousTraitant = {
    _count: LigneCommandeSousTraitantCountAggregateOutputType | null
    _avg: LigneCommandeSousTraitantAvgAggregateOutputType | null
    _sum: LigneCommandeSousTraitantSumAggregateOutputType | null
    _min: LigneCommandeSousTraitantMinAggregateOutputType | null
    _max: LigneCommandeSousTraitantMaxAggregateOutputType | null
  }

  export type LigneCommandeSousTraitantAvgAggregateOutputType = {
    id: number | null
    commandeSousTraitantId: number | null
    ordre: number | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
  }

  export type LigneCommandeSousTraitantSumAggregateOutputType = {
    id: number | null
    commandeSousTraitantId: number | null
    ordre: number | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
  }

  export type LigneCommandeSousTraitantMinAggregateOutputType = {
    id: number | null
    commandeSousTraitantId: number | null
    ordre: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneCommandeSousTraitantMaxAggregateOutputType = {
    id: number | null
    commandeSousTraitantId: number | null
    ordre: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneCommandeSousTraitantCountAggregateOutputType = {
    id: number
    commandeSousTraitantId: number
    ordre: number
    article: number
    description: number
    type: number
    unite: number
    prixUnitaire: number
    quantite: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LigneCommandeSousTraitantAvgAggregateInputType = {
    id?: true
    commandeSousTraitantId?: true
    ordre?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
  }

  export type LigneCommandeSousTraitantSumAggregateInputType = {
    id?: true
    commandeSousTraitantId?: true
    ordre?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
  }

  export type LigneCommandeSousTraitantMinAggregateInputType = {
    id?: true
    commandeSousTraitantId?: true
    ordre?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneCommandeSousTraitantMaxAggregateInputType = {
    id?: true
    commandeSousTraitantId?: true
    ordre?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneCommandeSousTraitantCountAggregateInputType = {
    id?: true
    commandeSousTraitantId?: true
    ordre?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LigneCommandeSousTraitantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCommandeSousTraitant to aggregate.
     */
    where?: LigneCommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandeSousTraitants to fetch.
     */
    orderBy?: LigneCommandeSousTraitantOrderByWithRelationInput | LigneCommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneCommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandeSousTraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneCommandeSousTraitants
    **/
    _count?: true | LigneCommandeSousTraitantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneCommandeSousTraitantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneCommandeSousTraitantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneCommandeSousTraitantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneCommandeSousTraitantMaxAggregateInputType
  }

  export type GetLigneCommandeSousTraitantAggregateType<T extends LigneCommandeSousTraitantAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneCommandeSousTraitant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneCommandeSousTraitant[P]>
      : GetScalarType<T[P], AggregateLigneCommandeSousTraitant[P]>
  }




  export type LigneCommandeSousTraitantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandeSousTraitantWhereInput
    orderBy?: LigneCommandeSousTraitantOrderByWithAggregationInput | LigneCommandeSousTraitantOrderByWithAggregationInput[]
    by: LigneCommandeSousTraitantScalarFieldEnum[] | LigneCommandeSousTraitantScalarFieldEnum
    having?: LigneCommandeSousTraitantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneCommandeSousTraitantCountAggregateInputType | true
    _avg?: LigneCommandeSousTraitantAvgAggregateInputType
    _sum?: LigneCommandeSousTraitantSumAggregateInputType
    _min?: LigneCommandeSousTraitantMinAggregateInputType
    _max?: LigneCommandeSousTraitantMaxAggregateInputType
  }

  export type LigneCommandeSousTraitantGroupByOutputType = {
    id: number
    commandeSousTraitantId: number
    ordre: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt: Date
    updatedAt: Date
    _count: LigneCommandeSousTraitantCountAggregateOutputType | null
    _avg: LigneCommandeSousTraitantAvgAggregateOutputType | null
    _sum: LigneCommandeSousTraitantSumAggregateOutputType | null
    _min: LigneCommandeSousTraitantMinAggregateOutputType | null
    _max: LigneCommandeSousTraitantMaxAggregateOutputType | null
  }

  type GetLigneCommandeSousTraitantGroupByPayload<T extends LigneCommandeSousTraitantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneCommandeSousTraitantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneCommandeSousTraitantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneCommandeSousTraitantGroupByOutputType[P]>
            : GetScalarType<T[P], LigneCommandeSousTraitantGroupByOutputType[P]>
        }
      >
    >


  export type LigneCommandeSousTraitantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandeSousTraitantId?: boolean
    ordre?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandeSousTraitant?: boolean | CommandeSousTraitantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneCommandeSousTraitant"]>



  export type LigneCommandeSousTraitantSelectScalar = {
    id?: boolean
    commandeSousTraitantId?: boolean
    ordre?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LigneCommandeSousTraitantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commandeSousTraitantId" | "ordre" | "article" | "description" | "type" | "unite" | "prixUnitaire" | "quantite" | "total" | "createdAt" | "updatedAt", ExtArgs["result"]["ligneCommandeSousTraitant"]>
  export type LigneCommandeSousTraitantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandeSousTraitant?: boolean | CommandeSousTraitantDefaultArgs<ExtArgs>
  }

  export type $LigneCommandeSousTraitantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneCommandeSousTraitant"
    objects: {
      commandeSousTraitant: Prisma.$CommandeSousTraitantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commandeSousTraitantId: number
      ordre: number
      article: string
      description: string
      type: string
      unite: string
      prixUnitaire: number
      quantite: number
      total: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ligneCommandeSousTraitant"]>
    composites: {}
  }

  type LigneCommandeSousTraitantGetPayload<S extends boolean | null | undefined | LigneCommandeSousTraitantDefaultArgs> = $Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload, S>

  type LigneCommandeSousTraitantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneCommandeSousTraitantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneCommandeSousTraitantCountAggregateInputType | true
    }

  export interface LigneCommandeSousTraitantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneCommandeSousTraitant'], meta: { name: 'LigneCommandeSousTraitant' } }
    /**
     * Find zero or one LigneCommandeSousTraitant that matches the filter.
     * @param {LigneCommandeSousTraitantFindUniqueArgs} args - Arguments to find a LigneCommandeSousTraitant
     * @example
     * // Get one LigneCommandeSousTraitant
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneCommandeSousTraitantFindUniqueArgs>(args: SelectSubset<T, LigneCommandeSousTraitantFindUniqueArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LigneCommandeSousTraitant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneCommandeSousTraitantFindUniqueOrThrowArgs} args - Arguments to find a LigneCommandeSousTraitant
     * @example
     * // Get one LigneCommandeSousTraitant
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneCommandeSousTraitantFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneCommandeSousTraitantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneCommandeSousTraitant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantFindFirstArgs} args - Arguments to find a LigneCommandeSousTraitant
     * @example
     * // Get one LigneCommandeSousTraitant
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneCommandeSousTraitantFindFirstArgs>(args?: SelectSubset<T, LigneCommandeSousTraitantFindFirstArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneCommandeSousTraitant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantFindFirstOrThrowArgs} args - Arguments to find a LigneCommandeSousTraitant
     * @example
     * // Get one LigneCommandeSousTraitant
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneCommandeSousTraitantFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneCommandeSousTraitantFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LigneCommandeSousTraitants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneCommandeSousTraitants
     * const ligneCommandeSousTraitants = await prisma.ligneCommandeSousTraitant.findMany()
     * 
     * // Get first 10 LigneCommandeSousTraitants
     * const ligneCommandeSousTraitants = await prisma.ligneCommandeSousTraitant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneCommandeSousTraitantWithIdOnly = await prisma.ligneCommandeSousTraitant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneCommandeSousTraitantFindManyArgs>(args?: SelectSubset<T, LigneCommandeSousTraitantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LigneCommandeSousTraitant.
     * @param {LigneCommandeSousTraitantCreateArgs} args - Arguments to create a LigneCommandeSousTraitant.
     * @example
     * // Create one LigneCommandeSousTraitant
     * const LigneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.create({
     *   data: {
     *     // ... data to create a LigneCommandeSousTraitant
     *   }
     * })
     * 
     */
    create<T extends LigneCommandeSousTraitantCreateArgs>(args: SelectSubset<T, LigneCommandeSousTraitantCreateArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LigneCommandeSousTraitants.
     * @param {LigneCommandeSousTraitantCreateManyArgs} args - Arguments to create many LigneCommandeSousTraitants.
     * @example
     * // Create many LigneCommandeSousTraitants
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneCommandeSousTraitantCreateManyArgs>(args?: SelectSubset<T, LigneCommandeSousTraitantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LigneCommandeSousTraitant.
     * @param {LigneCommandeSousTraitantDeleteArgs} args - Arguments to delete one LigneCommandeSousTraitant.
     * @example
     * // Delete one LigneCommandeSousTraitant
     * const LigneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.delete({
     *   where: {
     *     // ... filter to delete one LigneCommandeSousTraitant
     *   }
     * })
     * 
     */
    delete<T extends LigneCommandeSousTraitantDeleteArgs>(args: SelectSubset<T, LigneCommandeSousTraitantDeleteArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LigneCommandeSousTraitant.
     * @param {LigneCommandeSousTraitantUpdateArgs} args - Arguments to update one LigneCommandeSousTraitant.
     * @example
     * // Update one LigneCommandeSousTraitant
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneCommandeSousTraitantUpdateArgs>(args: SelectSubset<T, LigneCommandeSousTraitantUpdateArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LigneCommandeSousTraitants.
     * @param {LigneCommandeSousTraitantDeleteManyArgs} args - Arguments to filter LigneCommandeSousTraitants to delete.
     * @example
     * // Delete a few LigneCommandeSousTraitants
     * const { count } = await prisma.ligneCommandeSousTraitant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneCommandeSousTraitantDeleteManyArgs>(args?: SelectSubset<T, LigneCommandeSousTraitantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneCommandeSousTraitants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneCommandeSousTraitants
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneCommandeSousTraitantUpdateManyArgs>(args: SelectSubset<T, LigneCommandeSousTraitantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneCommandeSousTraitant.
     * @param {LigneCommandeSousTraitantUpsertArgs} args - Arguments to update or create a LigneCommandeSousTraitant.
     * @example
     * // Update or create a LigneCommandeSousTraitant
     * const ligneCommandeSousTraitant = await prisma.ligneCommandeSousTraitant.upsert({
     *   create: {
     *     // ... data to create a LigneCommandeSousTraitant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneCommandeSousTraitant we want to update
     *   }
     * })
     */
    upsert<T extends LigneCommandeSousTraitantUpsertArgs>(args: SelectSubset<T, LigneCommandeSousTraitantUpsertArgs<ExtArgs>>): Prisma__LigneCommandeSousTraitantClient<$Result.GetResult<Prisma.$LigneCommandeSousTraitantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LigneCommandeSousTraitants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantCountArgs} args - Arguments to filter LigneCommandeSousTraitants to count.
     * @example
     * // Count the number of LigneCommandeSousTraitants
     * const count = await prisma.ligneCommandeSousTraitant.count({
     *   where: {
     *     // ... the filter for the LigneCommandeSousTraitants we want to count
     *   }
     * })
    **/
    count<T extends LigneCommandeSousTraitantCountArgs>(
      args?: Subset<T, LigneCommandeSousTraitantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneCommandeSousTraitantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneCommandeSousTraitant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneCommandeSousTraitantAggregateArgs>(args: Subset<T, LigneCommandeSousTraitantAggregateArgs>): Prisma.PrismaPromise<GetLigneCommandeSousTraitantAggregateType<T>>

    /**
     * Group by LigneCommandeSousTraitant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandeSousTraitantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneCommandeSousTraitantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneCommandeSousTraitantGroupByArgs['orderBy'] }
        : { orderBy?: LigneCommandeSousTraitantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneCommandeSousTraitantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneCommandeSousTraitantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneCommandeSousTraitant model
   */
  readonly fields: LigneCommandeSousTraitantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneCommandeSousTraitant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneCommandeSousTraitantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commandeSousTraitant<T extends CommandeSousTraitantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandeSousTraitantDefaultArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneCommandeSousTraitant model
   */ 
  interface LigneCommandeSousTraitantFieldRefs {
    readonly id: FieldRef<"LigneCommandeSousTraitant", 'Int'>
    readonly commandeSousTraitantId: FieldRef<"LigneCommandeSousTraitant", 'Int'>
    readonly ordre: FieldRef<"LigneCommandeSousTraitant", 'Int'>
    readonly article: FieldRef<"LigneCommandeSousTraitant", 'String'>
    readonly description: FieldRef<"LigneCommandeSousTraitant", 'String'>
    readonly type: FieldRef<"LigneCommandeSousTraitant", 'String'>
    readonly unite: FieldRef<"LigneCommandeSousTraitant", 'String'>
    readonly prixUnitaire: FieldRef<"LigneCommandeSousTraitant", 'Float'>
    readonly quantite: FieldRef<"LigneCommandeSousTraitant", 'Float'>
    readonly total: FieldRef<"LigneCommandeSousTraitant", 'Float'>
    readonly createdAt: FieldRef<"LigneCommandeSousTraitant", 'DateTime'>
    readonly updatedAt: FieldRef<"LigneCommandeSousTraitant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneCommandeSousTraitant findUnique
   */
  export type LigneCommandeSousTraitantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandeSousTraitant to fetch.
     */
    where: LigneCommandeSousTraitantWhereUniqueInput
  }

  /**
   * LigneCommandeSousTraitant findUniqueOrThrow
   */
  export type LigneCommandeSousTraitantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandeSousTraitant to fetch.
     */
    where: LigneCommandeSousTraitantWhereUniqueInput
  }

  /**
   * LigneCommandeSousTraitant findFirst
   */
  export type LigneCommandeSousTraitantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandeSousTraitant to fetch.
     */
    where?: LigneCommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandeSousTraitants to fetch.
     */
    orderBy?: LigneCommandeSousTraitantOrderByWithRelationInput | LigneCommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCommandeSousTraitants.
     */
    cursor?: LigneCommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandeSousTraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCommandeSousTraitants.
     */
    distinct?: LigneCommandeSousTraitantScalarFieldEnum | LigneCommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * LigneCommandeSousTraitant findFirstOrThrow
   */
  export type LigneCommandeSousTraitantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandeSousTraitant to fetch.
     */
    where?: LigneCommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandeSousTraitants to fetch.
     */
    orderBy?: LigneCommandeSousTraitantOrderByWithRelationInput | LigneCommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCommandeSousTraitants.
     */
    cursor?: LigneCommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandeSousTraitants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCommandeSousTraitants.
     */
    distinct?: LigneCommandeSousTraitantScalarFieldEnum | LigneCommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * LigneCommandeSousTraitant findMany
   */
  export type LigneCommandeSousTraitantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandeSousTraitants to fetch.
     */
    where?: LigneCommandeSousTraitantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandeSousTraitants to fetch.
     */
    orderBy?: LigneCommandeSousTraitantOrderByWithRelationInput | LigneCommandeSousTraitantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneCommandeSousTraitants.
     */
    cursor?: LigneCommandeSousTraitantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandeSousTraitants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandeSousTraitants.
     */
    skip?: number
    distinct?: LigneCommandeSousTraitantScalarFieldEnum | LigneCommandeSousTraitantScalarFieldEnum[]
  }

  /**
   * LigneCommandeSousTraitant create
   */
  export type LigneCommandeSousTraitantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneCommandeSousTraitant.
     */
    data: XOR<LigneCommandeSousTraitantCreateInput, LigneCommandeSousTraitantUncheckedCreateInput>
  }

  /**
   * LigneCommandeSousTraitant createMany
   */
  export type LigneCommandeSousTraitantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneCommandeSousTraitants.
     */
    data: LigneCommandeSousTraitantCreateManyInput | LigneCommandeSousTraitantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneCommandeSousTraitant update
   */
  export type LigneCommandeSousTraitantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneCommandeSousTraitant.
     */
    data: XOR<LigneCommandeSousTraitantUpdateInput, LigneCommandeSousTraitantUncheckedUpdateInput>
    /**
     * Choose, which LigneCommandeSousTraitant to update.
     */
    where: LigneCommandeSousTraitantWhereUniqueInput
  }

  /**
   * LigneCommandeSousTraitant updateMany
   */
  export type LigneCommandeSousTraitantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneCommandeSousTraitants.
     */
    data: XOR<LigneCommandeSousTraitantUpdateManyMutationInput, LigneCommandeSousTraitantUncheckedUpdateManyInput>
    /**
     * Filter which LigneCommandeSousTraitants to update
     */
    where?: LigneCommandeSousTraitantWhereInput
    /**
     * Limit how many LigneCommandeSousTraitants to update.
     */
    limit?: number
  }

  /**
   * LigneCommandeSousTraitant upsert
   */
  export type LigneCommandeSousTraitantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneCommandeSousTraitant to update in case it exists.
     */
    where: LigneCommandeSousTraitantWhereUniqueInput
    /**
     * In case the LigneCommandeSousTraitant found by the `where` argument doesn't exist, create a new LigneCommandeSousTraitant with this data.
     */
    create: XOR<LigneCommandeSousTraitantCreateInput, LigneCommandeSousTraitantUncheckedCreateInput>
    /**
     * In case the LigneCommandeSousTraitant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneCommandeSousTraitantUpdateInput, LigneCommandeSousTraitantUncheckedUpdateInput>
  }

  /**
   * LigneCommandeSousTraitant delete
   */
  export type LigneCommandeSousTraitantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
    /**
     * Filter which LigneCommandeSousTraitant to delete.
     */
    where: LigneCommandeSousTraitantWhereUniqueInput
  }

  /**
   * LigneCommandeSousTraitant deleteMany
   */
  export type LigneCommandeSousTraitantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCommandeSousTraitants to delete
     */
    where?: LigneCommandeSousTraitantWhereInput
    /**
     * Limit how many LigneCommandeSousTraitants to delete.
     */
    limit?: number
  }

  /**
   * LigneCommandeSousTraitant without action
   */
  export type LigneCommandeSousTraitantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandeSousTraitant
     */
    select?: LigneCommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandeSousTraitant
     */
    omit?: LigneCommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandeSousTraitantInclude<ExtArgs> | null
  }


  /**
   * Model avenant_soustraitant_etat_avancement
   */

  export type AggregateAvenant_soustraitant_etat_avancement = {
    _count: Avenant_soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Avenant_soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Avenant_soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Avenant_soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Avenant_soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  export type Avenant_soustraitant_etat_avancementAvgAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
  }

  export type Avenant_soustraitant_etat_avancementSumAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
  }

  export type Avenant_soustraitant_etat_avancementMinAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Avenant_soustraitant_etat_avancementMaxAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Avenant_soustraitant_etat_avancementCountAggregateOutputType = {
    id: number
    soustraitantEtatAvancementId: number
    article: number
    description: number
    type: number
    unite: number
    prixUnitaire: number
    quantite: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Avenant_soustraitant_etat_avancementAvgAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
  }

  export type Avenant_soustraitant_etat_avancementSumAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
  }

  export type Avenant_soustraitant_etat_avancementMinAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Avenant_soustraitant_etat_avancementMaxAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Avenant_soustraitant_etat_avancementCountAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Avenant_soustraitant_etat_avancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avenant_soustraitant_etat_avancement to aggregate.
     */
    where?: avenant_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avenant_soustraitant_etat_avancements to fetch.
     */
    orderBy?: avenant_soustraitant_etat_avancementOrderByWithRelationInput | avenant_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: avenant_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avenant_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avenant_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned avenant_soustraitant_etat_avancements
    **/
    _count?: true | Avenant_soustraitant_etat_avancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Avenant_soustraitant_etat_avancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Avenant_soustraitant_etat_avancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Avenant_soustraitant_etat_avancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Avenant_soustraitant_etat_avancementMaxAggregateInputType
  }

  export type GetAvenant_soustraitant_etat_avancementAggregateType<T extends Avenant_soustraitant_etat_avancementAggregateArgs> = {
        [P in keyof T & keyof AggregateAvenant_soustraitant_etat_avancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvenant_soustraitant_etat_avancement[P]>
      : GetScalarType<T[P], AggregateAvenant_soustraitant_etat_avancement[P]>
  }




  export type avenant_soustraitant_etat_avancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: avenant_soustraitant_etat_avancementWhereInput
    orderBy?: avenant_soustraitant_etat_avancementOrderByWithAggregationInput | avenant_soustraitant_etat_avancementOrderByWithAggregationInput[]
    by: Avenant_soustraitant_etat_avancementScalarFieldEnum[] | Avenant_soustraitant_etat_avancementScalarFieldEnum
    having?: avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Avenant_soustraitant_etat_avancementCountAggregateInputType | true
    _avg?: Avenant_soustraitant_etat_avancementAvgAggregateInputType
    _sum?: Avenant_soustraitant_etat_avancementSumAggregateInputType
    _min?: Avenant_soustraitant_etat_avancementMinAggregateInputType
    _max?: Avenant_soustraitant_etat_avancementMaxAggregateInputType
  }

  export type Avenant_soustraitant_etat_avancementGroupByOutputType = {
    id: number
    soustraitantEtatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: Date
    updatedAt: Date
    _count: Avenant_soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Avenant_soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Avenant_soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Avenant_soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Avenant_soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  type GetAvenant_soustraitant_etat_avancementGroupByPayload<T extends avenant_soustraitant_etat_avancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Avenant_soustraitant_etat_avancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Avenant_soustraitant_etat_avancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Avenant_soustraitant_etat_avancementGroupByOutputType[P]>
            : GetScalarType<T[P], Avenant_soustraitant_etat_avancementGroupByOutputType[P]>
        }
      >
    >


  export type avenant_soustraitant_etat_avancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    soustraitantEtatAvancementId?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    soustraitant_etat_avancement?: boolean | soustraitant_etat_avancementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avenant_soustraitant_etat_avancement"]>



  export type avenant_soustraitant_etat_avancementSelectScalar = {
    id?: boolean
    soustraitantEtatAvancementId?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type avenant_soustraitant_etat_avancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "soustraitantEtatAvancementId" | "article" | "description" | "type" | "unite" | "prixUnitaire" | "quantite" | "quantitePrecedente" | "quantiteActuelle" | "quantiteTotale" | "montantPrecedent" | "montantActuel" | "montantTotal" | "createdAt" | "updatedAt", ExtArgs["result"]["avenant_soustraitant_etat_avancement"]>
  export type avenant_soustraitant_etat_avancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soustraitant_etat_avancement?: boolean | soustraitant_etat_avancementDefaultArgs<ExtArgs>
  }

  export type $avenant_soustraitant_etat_avancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "avenant_soustraitant_etat_avancement"
    objects: {
      soustraitant_etat_avancement: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      soustraitantEtatAvancementId: number
      article: string
      description: string
      type: string
      unite: string
      prixUnitaire: number
      quantite: number
      quantitePrecedente: number
      quantiteActuelle: number
      quantiteTotale: number
      montantPrecedent: number
      montantActuel: number
      montantTotal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["avenant_soustraitant_etat_avancement"]>
    composites: {}
  }

  type avenant_soustraitant_etat_avancementGetPayload<S extends boolean | null | undefined | avenant_soustraitant_etat_avancementDefaultArgs> = $Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload, S>

  type avenant_soustraitant_etat_avancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<avenant_soustraitant_etat_avancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Avenant_soustraitant_etat_avancementCountAggregateInputType | true
    }

  export interface avenant_soustraitant_etat_avancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['avenant_soustraitant_etat_avancement'], meta: { name: 'avenant_soustraitant_etat_avancement' } }
    /**
     * Find zero or one Avenant_soustraitant_etat_avancement that matches the filter.
     * @param {avenant_soustraitant_etat_avancementFindUniqueArgs} args - Arguments to find a Avenant_soustraitant_etat_avancement
     * @example
     * // Get one Avenant_soustraitant_etat_avancement
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends avenant_soustraitant_etat_avancementFindUniqueArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementFindUniqueArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Avenant_soustraitant_etat_avancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {avenant_soustraitant_etat_avancementFindUniqueOrThrowArgs} args - Arguments to find a Avenant_soustraitant_etat_avancement
     * @example
     * // Get one Avenant_soustraitant_etat_avancement
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends avenant_soustraitant_etat_avancementFindUniqueOrThrowArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avenant_soustraitant_etat_avancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avenant_soustraitant_etat_avancementFindFirstArgs} args - Arguments to find a Avenant_soustraitant_etat_avancement
     * @example
     * // Get one Avenant_soustraitant_etat_avancement
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends avenant_soustraitant_etat_avancementFindFirstArgs>(args?: SelectSubset<T, avenant_soustraitant_etat_avancementFindFirstArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avenant_soustraitant_etat_avancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avenant_soustraitant_etat_avancementFindFirstOrThrowArgs} args - Arguments to find a Avenant_soustraitant_etat_avancement
     * @example
     * // Get one Avenant_soustraitant_etat_avancement
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends avenant_soustraitant_etat_avancementFindFirstOrThrowArgs>(args?: SelectSubset<T, avenant_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Avenant_soustraitant_etat_avancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avenant_soustraitant_etat_avancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avenant_soustraitant_etat_avancements
     * const avenant_soustraitant_etat_avancements = await prisma.avenant_soustraitant_etat_avancement.findMany()
     * 
     * // Get first 10 Avenant_soustraitant_etat_avancements
     * const avenant_soustraitant_etat_avancements = await prisma.avenant_soustraitant_etat_avancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avenant_soustraitant_etat_avancementWithIdOnly = await prisma.avenant_soustraitant_etat_avancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends avenant_soustraitant_etat_avancementFindManyArgs>(args?: SelectSubset<T, avenant_soustraitant_etat_avancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Avenant_soustraitant_etat_avancement.
     * @param {avenant_soustraitant_etat_avancementCreateArgs} args - Arguments to create a Avenant_soustraitant_etat_avancement.
     * @example
     * // Create one Avenant_soustraitant_etat_avancement
     * const Avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.create({
     *   data: {
     *     // ... data to create a Avenant_soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    create<T extends avenant_soustraitant_etat_avancementCreateArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementCreateArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Avenant_soustraitant_etat_avancements.
     * @param {avenant_soustraitant_etat_avancementCreateManyArgs} args - Arguments to create many Avenant_soustraitant_etat_avancements.
     * @example
     * // Create many Avenant_soustraitant_etat_avancements
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends avenant_soustraitant_etat_avancementCreateManyArgs>(args?: SelectSubset<T, avenant_soustraitant_etat_avancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Avenant_soustraitant_etat_avancement.
     * @param {avenant_soustraitant_etat_avancementDeleteArgs} args - Arguments to delete one Avenant_soustraitant_etat_avancement.
     * @example
     * // Delete one Avenant_soustraitant_etat_avancement
     * const Avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.delete({
     *   where: {
     *     // ... filter to delete one Avenant_soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    delete<T extends avenant_soustraitant_etat_avancementDeleteArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementDeleteArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Avenant_soustraitant_etat_avancement.
     * @param {avenant_soustraitant_etat_avancementUpdateArgs} args - Arguments to update one Avenant_soustraitant_etat_avancement.
     * @example
     * // Update one Avenant_soustraitant_etat_avancement
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends avenant_soustraitant_etat_avancementUpdateArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementUpdateArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Avenant_soustraitant_etat_avancements.
     * @param {avenant_soustraitant_etat_avancementDeleteManyArgs} args - Arguments to filter Avenant_soustraitant_etat_avancements to delete.
     * @example
     * // Delete a few Avenant_soustraitant_etat_avancements
     * const { count } = await prisma.avenant_soustraitant_etat_avancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends avenant_soustraitant_etat_avancementDeleteManyArgs>(args?: SelectSubset<T, avenant_soustraitant_etat_avancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avenant_soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avenant_soustraitant_etat_avancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avenant_soustraitant_etat_avancements
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends avenant_soustraitant_etat_avancementUpdateManyArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avenant_soustraitant_etat_avancement.
     * @param {avenant_soustraitant_etat_avancementUpsertArgs} args - Arguments to update or create a Avenant_soustraitant_etat_avancement.
     * @example
     * // Update or create a Avenant_soustraitant_etat_avancement
     * const avenant_soustraitant_etat_avancement = await prisma.avenant_soustraitant_etat_avancement.upsert({
     *   create: {
     *     // ... data to create a Avenant_soustraitant_etat_avancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avenant_soustraitant_etat_avancement we want to update
     *   }
     * })
     */
    upsert<T extends avenant_soustraitant_etat_avancementUpsertArgs>(args: SelectSubset<T, avenant_soustraitant_etat_avancementUpsertArgs<ExtArgs>>): Prisma__avenant_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Avenant_soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avenant_soustraitant_etat_avancementCountArgs} args - Arguments to filter Avenant_soustraitant_etat_avancements to count.
     * @example
     * // Count the number of Avenant_soustraitant_etat_avancements
     * const count = await prisma.avenant_soustraitant_etat_avancement.count({
     *   where: {
     *     // ... the filter for the Avenant_soustraitant_etat_avancements we want to count
     *   }
     * })
    **/
    count<T extends avenant_soustraitant_etat_avancementCountArgs>(
      args?: Subset<T, avenant_soustraitant_etat_avancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Avenant_soustraitant_etat_avancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avenant_soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Avenant_soustraitant_etat_avancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Avenant_soustraitant_etat_avancementAggregateArgs>(args: Subset<T, Avenant_soustraitant_etat_avancementAggregateArgs>): Prisma.PrismaPromise<GetAvenant_soustraitant_etat_avancementAggregateType<T>>

    /**
     * Group by Avenant_soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avenant_soustraitant_etat_avancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends avenant_soustraitant_etat_avancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avenant_soustraitant_etat_avancementGroupByArgs['orderBy'] }
        : { orderBy?: avenant_soustraitant_etat_avancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, avenant_soustraitant_etat_avancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvenant_soustraitant_etat_avancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the avenant_soustraitant_etat_avancement model
   */
  readonly fields: avenant_soustraitant_etat_avancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avenant_soustraitant_etat_avancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avenant_soustraitant_etat_avancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soustraitant_etat_avancement<T extends soustraitant_etat_avancementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancementDefaultArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the avenant_soustraitant_etat_avancement model
   */ 
  interface avenant_soustraitant_etat_avancementFieldRefs {
    readonly id: FieldRef<"avenant_soustraitant_etat_avancement", 'Int'>
    readonly soustraitantEtatAvancementId: FieldRef<"avenant_soustraitant_etat_avancement", 'Int'>
    readonly article: FieldRef<"avenant_soustraitant_etat_avancement", 'String'>
    readonly description: FieldRef<"avenant_soustraitant_etat_avancement", 'String'>
    readonly type: FieldRef<"avenant_soustraitant_etat_avancement", 'String'>
    readonly unite: FieldRef<"avenant_soustraitant_etat_avancement", 'String'>
    readonly prixUnitaire: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly quantite: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly quantitePrecedente: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly quantiteActuelle: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly quantiteTotale: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly montantPrecedent: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly montantActuel: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly montantTotal: FieldRef<"avenant_soustraitant_etat_avancement", 'Float'>
    readonly createdAt: FieldRef<"avenant_soustraitant_etat_avancement", 'DateTime'>
    readonly updatedAt: FieldRef<"avenant_soustraitant_etat_avancement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * avenant_soustraitant_etat_avancement findUnique
   */
  export type avenant_soustraitant_etat_avancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which avenant_soustraitant_etat_avancement to fetch.
     */
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * avenant_soustraitant_etat_avancement findUniqueOrThrow
   */
  export type avenant_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which avenant_soustraitant_etat_avancement to fetch.
     */
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * avenant_soustraitant_etat_avancement findFirst
   */
  export type avenant_soustraitant_etat_avancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which avenant_soustraitant_etat_avancement to fetch.
     */
    where?: avenant_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avenant_soustraitant_etat_avancements to fetch.
     */
    orderBy?: avenant_soustraitant_etat_avancementOrderByWithRelationInput | avenant_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avenant_soustraitant_etat_avancements.
     */
    cursor?: avenant_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avenant_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avenant_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avenant_soustraitant_etat_avancements.
     */
    distinct?: Avenant_soustraitant_etat_avancementScalarFieldEnum | Avenant_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * avenant_soustraitant_etat_avancement findFirstOrThrow
   */
  export type avenant_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which avenant_soustraitant_etat_avancement to fetch.
     */
    where?: avenant_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avenant_soustraitant_etat_avancements to fetch.
     */
    orderBy?: avenant_soustraitant_etat_avancementOrderByWithRelationInput | avenant_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avenant_soustraitant_etat_avancements.
     */
    cursor?: avenant_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avenant_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avenant_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avenant_soustraitant_etat_avancements.
     */
    distinct?: Avenant_soustraitant_etat_avancementScalarFieldEnum | Avenant_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * avenant_soustraitant_etat_avancement findMany
   */
  export type avenant_soustraitant_etat_avancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which avenant_soustraitant_etat_avancements to fetch.
     */
    where?: avenant_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avenant_soustraitant_etat_avancements to fetch.
     */
    orderBy?: avenant_soustraitant_etat_avancementOrderByWithRelationInput | avenant_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing avenant_soustraitant_etat_avancements.
     */
    cursor?: avenant_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avenant_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avenant_soustraitant_etat_avancements.
     */
    skip?: number
    distinct?: Avenant_soustraitant_etat_avancementScalarFieldEnum | Avenant_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * avenant_soustraitant_etat_avancement create
   */
  export type avenant_soustraitant_etat_avancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to create a avenant_soustraitant_etat_avancement.
     */
    data: XOR<avenant_soustraitant_etat_avancementCreateInput, avenant_soustraitant_etat_avancementUncheckedCreateInput>
  }

  /**
   * avenant_soustraitant_etat_avancement createMany
   */
  export type avenant_soustraitant_etat_avancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many avenant_soustraitant_etat_avancements.
     */
    data: avenant_soustraitant_etat_avancementCreateManyInput | avenant_soustraitant_etat_avancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * avenant_soustraitant_etat_avancement update
   */
  export type avenant_soustraitant_etat_avancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to update a avenant_soustraitant_etat_avancement.
     */
    data: XOR<avenant_soustraitant_etat_avancementUpdateInput, avenant_soustraitant_etat_avancementUncheckedUpdateInput>
    /**
     * Choose, which avenant_soustraitant_etat_avancement to update.
     */
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * avenant_soustraitant_etat_avancement updateMany
   */
  export type avenant_soustraitant_etat_avancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update avenant_soustraitant_etat_avancements.
     */
    data: XOR<avenant_soustraitant_etat_avancementUpdateManyMutationInput, avenant_soustraitant_etat_avancementUncheckedUpdateManyInput>
    /**
     * Filter which avenant_soustraitant_etat_avancements to update
     */
    where?: avenant_soustraitant_etat_avancementWhereInput
    /**
     * Limit how many avenant_soustraitant_etat_avancements to update.
     */
    limit?: number
  }

  /**
   * avenant_soustraitant_etat_avancement upsert
   */
  export type avenant_soustraitant_etat_avancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The filter to search for the avenant_soustraitant_etat_avancement to update in case it exists.
     */
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
    /**
     * In case the avenant_soustraitant_etat_avancement found by the `where` argument doesn't exist, create a new avenant_soustraitant_etat_avancement with this data.
     */
    create: XOR<avenant_soustraitant_etat_avancementCreateInput, avenant_soustraitant_etat_avancementUncheckedCreateInput>
    /**
     * In case the avenant_soustraitant_etat_avancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avenant_soustraitant_etat_avancementUpdateInput, avenant_soustraitant_etat_avancementUncheckedUpdateInput>
  }

  /**
   * avenant_soustraitant_etat_avancement delete
   */
  export type avenant_soustraitant_etat_avancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter which avenant_soustraitant_etat_avancement to delete.
     */
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * avenant_soustraitant_etat_avancement deleteMany
   */
  export type avenant_soustraitant_etat_avancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avenant_soustraitant_etat_avancements to delete
     */
    where?: avenant_soustraitant_etat_avancementWhereInput
    /**
     * Limit how many avenant_soustraitant_etat_avancements to delete.
     */
    limit?: number
  }

  /**
   * avenant_soustraitant_etat_avancement without action
   */
  export type avenant_soustraitant_etat_avancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
  }


  /**
   * Model ligne_soustraitant_etat_avancement
   */

  export type AggregateLigne_soustraitant_etat_avancement = {
    _count: Ligne_soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Ligne_soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Ligne_soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Ligne_soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Ligne_soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  export type Ligne_soustraitant_etat_avancementAvgAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
  }

  export type Ligne_soustraitant_etat_avancementSumAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
  }

  export type Ligne_soustraitant_etat_avancementMinAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Ligne_soustraitant_etat_avancementMaxAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    article: string | null
    description: string | null
    type: string | null
    unite: string | null
    prixUnitaire: number | null
    quantite: number | null
    quantitePrecedente: number | null
    quantiteActuelle: number | null
    quantiteTotale: number | null
    montantPrecedent: number | null
    montantActuel: number | null
    montantTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Ligne_soustraitant_etat_avancementCountAggregateOutputType = {
    id: number
    soustraitantEtatAvancementId: number
    article: number
    description: number
    type: number
    unite: number
    prixUnitaire: number
    quantite: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Ligne_soustraitant_etat_avancementAvgAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
  }

  export type Ligne_soustraitant_etat_avancementSumAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
  }

  export type Ligne_soustraitant_etat_avancementMinAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Ligne_soustraitant_etat_avancementMaxAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Ligne_soustraitant_etat_avancementCountAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    article?: true
    description?: true
    type?: true
    unite?: true
    prixUnitaire?: true
    quantite?: true
    quantitePrecedente?: true
    quantiteActuelle?: true
    quantiteTotale?: true
    montantPrecedent?: true
    montantActuel?: true
    montantTotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Ligne_soustraitant_etat_avancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ligne_soustraitant_etat_avancement to aggregate.
     */
    where?: ligne_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ligne_soustraitant_etat_avancements to fetch.
     */
    orderBy?: ligne_soustraitant_etat_avancementOrderByWithRelationInput | ligne_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ligne_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ligne_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ligne_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ligne_soustraitant_etat_avancements
    **/
    _count?: true | Ligne_soustraitant_etat_avancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ligne_soustraitant_etat_avancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ligne_soustraitant_etat_avancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ligne_soustraitant_etat_avancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ligne_soustraitant_etat_avancementMaxAggregateInputType
  }

  export type GetLigne_soustraitant_etat_avancementAggregateType<T extends Ligne_soustraitant_etat_avancementAggregateArgs> = {
        [P in keyof T & keyof AggregateLigne_soustraitant_etat_avancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigne_soustraitant_etat_avancement[P]>
      : GetScalarType<T[P], AggregateLigne_soustraitant_etat_avancement[P]>
  }




  export type ligne_soustraitant_etat_avancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ligne_soustraitant_etat_avancementWhereInput
    orderBy?: ligne_soustraitant_etat_avancementOrderByWithAggregationInput | ligne_soustraitant_etat_avancementOrderByWithAggregationInput[]
    by: Ligne_soustraitant_etat_avancementScalarFieldEnum[] | Ligne_soustraitant_etat_avancementScalarFieldEnum
    having?: ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ligne_soustraitant_etat_avancementCountAggregateInputType | true
    _avg?: Ligne_soustraitant_etat_avancementAvgAggregateInputType
    _sum?: Ligne_soustraitant_etat_avancementSumAggregateInputType
    _min?: Ligne_soustraitant_etat_avancementMinAggregateInputType
    _max?: Ligne_soustraitant_etat_avancementMaxAggregateInputType
  }

  export type Ligne_soustraitant_etat_avancementGroupByOutputType = {
    id: number
    soustraitantEtatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente: number
    quantiteActuelle: number
    quantiteTotale: number
    montantPrecedent: number
    montantActuel: number
    montantTotal: number
    createdAt: Date
    updatedAt: Date
    _count: Ligne_soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Ligne_soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Ligne_soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Ligne_soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Ligne_soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  type GetLigne_soustraitant_etat_avancementGroupByPayload<T extends ligne_soustraitant_etat_avancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ligne_soustraitant_etat_avancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ligne_soustraitant_etat_avancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ligne_soustraitant_etat_avancementGroupByOutputType[P]>
            : GetScalarType<T[P], Ligne_soustraitant_etat_avancementGroupByOutputType[P]>
        }
      >
    >


  export type ligne_soustraitant_etat_avancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    soustraitantEtatAvancementId?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    soustraitant_etat_avancement?: boolean | soustraitant_etat_avancementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligne_soustraitant_etat_avancement"]>



  export type ligne_soustraitant_etat_avancementSelectScalar = {
    id?: boolean
    soustraitantEtatAvancementId?: boolean
    article?: boolean
    description?: boolean
    type?: boolean
    unite?: boolean
    prixUnitaire?: boolean
    quantite?: boolean
    quantitePrecedente?: boolean
    quantiteActuelle?: boolean
    quantiteTotale?: boolean
    montantPrecedent?: boolean
    montantActuel?: boolean
    montantTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ligne_soustraitant_etat_avancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "soustraitantEtatAvancementId" | "article" | "description" | "type" | "unite" | "prixUnitaire" | "quantite" | "quantitePrecedente" | "quantiteActuelle" | "quantiteTotale" | "montantPrecedent" | "montantActuel" | "montantTotal" | "createdAt" | "updatedAt", ExtArgs["result"]["ligne_soustraitant_etat_avancement"]>
  export type ligne_soustraitant_etat_avancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soustraitant_etat_avancement?: boolean | soustraitant_etat_avancementDefaultArgs<ExtArgs>
  }

  export type $ligne_soustraitant_etat_avancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ligne_soustraitant_etat_avancement"
    objects: {
      soustraitant_etat_avancement: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      soustraitantEtatAvancementId: number
      article: string
      description: string
      type: string
      unite: string
      prixUnitaire: number
      quantite: number
      quantitePrecedente: number
      quantiteActuelle: number
      quantiteTotale: number
      montantPrecedent: number
      montantActuel: number
      montantTotal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ligne_soustraitant_etat_avancement"]>
    composites: {}
  }

  type ligne_soustraitant_etat_avancementGetPayload<S extends boolean | null | undefined | ligne_soustraitant_etat_avancementDefaultArgs> = $Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload, S>

  type ligne_soustraitant_etat_avancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ligne_soustraitant_etat_avancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ligne_soustraitant_etat_avancementCountAggregateInputType | true
    }

  export interface ligne_soustraitant_etat_avancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ligne_soustraitant_etat_avancement'], meta: { name: 'ligne_soustraitant_etat_avancement' } }
    /**
     * Find zero or one Ligne_soustraitant_etat_avancement that matches the filter.
     * @param {ligne_soustraitant_etat_avancementFindUniqueArgs} args - Arguments to find a Ligne_soustraitant_etat_avancement
     * @example
     * // Get one Ligne_soustraitant_etat_avancement
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ligne_soustraitant_etat_avancementFindUniqueArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementFindUniqueArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ligne_soustraitant_etat_avancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ligne_soustraitant_etat_avancementFindUniqueOrThrowArgs} args - Arguments to find a Ligne_soustraitant_etat_avancement
     * @example
     * // Get one Ligne_soustraitant_etat_avancement
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ligne_soustraitant_etat_avancementFindUniqueOrThrowArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ligne_soustraitant_etat_avancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ligne_soustraitant_etat_avancementFindFirstArgs} args - Arguments to find a Ligne_soustraitant_etat_avancement
     * @example
     * // Get one Ligne_soustraitant_etat_avancement
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ligne_soustraitant_etat_avancementFindFirstArgs>(args?: SelectSubset<T, ligne_soustraitant_etat_avancementFindFirstArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ligne_soustraitant_etat_avancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ligne_soustraitant_etat_avancementFindFirstOrThrowArgs} args - Arguments to find a Ligne_soustraitant_etat_avancement
     * @example
     * // Get one Ligne_soustraitant_etat_avancement
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ligne_soustraitant_etat_avancementFindFirstOrThrowArgs>(args?: SelectSubset<T, ligne_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ligne_soustraitant_etat_avancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ligne_soustraitant_etat_avancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ligne_soustraitant_etat_avancements
     * const ligne_soustraitant_etat_avancements = await prisma.ligne_soustraitant_etat_avancement.findMany()
     * 
     * // Get first 10 Ligne_soustraitant_etat_avancements
     * const ligne_soustraitant_etat_avancements = await prisma.ligne_soustraitant_etat_avancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligne_soustraitant_etat_avancementWithIdOnly = await prisma.ligne_soustraitant_etat_avancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ligne_soustraitant_etat_avancementFindManyArgs>(args?: SelectSubset<T, ligne_soustraitant_etat_avancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ligne_soustraitant_etat_avancement.
     * @param {ligne_soustraitant_etat_avancementCreateArgs} args - Arguments to create a Ligne_soustraitant_etat_avancement.
     * @example
     * // Create one Ligne_soustraitant_etat_avancement
     * const Ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.create({
     *   data: {
     *     // ... data to create a Ligne_soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    create<T extends ligne_soustraitant_etat_avancementCreateArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementCreateArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ligne_soustraitant_etat_avancements.
     * @param {ligne_soustraitant_etat_avancementCreateManyArgs} args - Arguments to create many Ligne_soustraitant_etat_avancements.
     * @example
     * // Create many Ligne_soustraitant_etat_avancements
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ligne_soustraitant_etat_avancementCreateManyArgs>(args?: SelectSubset<T, ligne_soustraitant_etat_avancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ligne_soustraitant_etat_avancement.
     * @param {ligne_soustraitant_etat_avancementDeleteArgs} args - Arguments to delete one Ligne_soustraitant_etat_avancement.
     * @example
     * // Delete one Ligne_soustraitant_etat_avancement
     * const Ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.delete({
     *   where: {
     *     // ... filter to delete one Ligne_soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    delete<T extends ligne_soustraitant_etat_avancementDeleteArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementDeleteArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ligne_soustraitant_etat_avancement.
     * @param {ligne_soustraitant_etat_avancementUpdateArgs} args - Arguments to update one Ligne_soustraitant_etat_avancement.
     * @example
     * // Update one Ligne_soustraitant_etat_avancement
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ligne_soustraitant_etat_avancementUpdateArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementUpdateArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ligne_soustraitant_etat_avancements.
     * @param {ligne_soustraitant_etat_avancementDeleteManyArgs} args - Arguments to filter Ligne_soustraitant_etat_avancements to delete.
     * @example
     * // Delete a few Ligne_soustraitant_etat_avancements
     * const { count } = await prisma.ligne_soustraitant_etat_avancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ligne_soustraitant_etat_avancementDeleteManyArgs>(args?: SelectSubset<T, ligne_soustraitant_etat_avancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ligne_soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ligne_soustraitant_etat_avancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ligne_soustraitant_etat_avancements
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ligne_soustraitant_etat_avancementUpdateManyArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ligne_soustraitant_etat_avancement.
     * @param {ligne_soustraitant_etat_avancementUpsertArgs} args - Arguments to update or create a Ligne_soustraitant_etat_avancement.
     * @example
     * // Update or create a Ligne_soustraitant_etat_avancement
     * const ligne_soustraitant_etat_avancement = await prisma.ligne_soustraitant_etat_avancement.upsert({
     *   create: {
     *     // ... data to create a Ligne_soustraitant_etat_avancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ligne_soustraitant_etat_avancement we want to update
     *   }
     * })
     */
    upsert<T extends ligne_soustraitant_etat_avancementUpsertArgs>(args: SelectSubset<T, ligne_soustraitant_etat_avancementUpsertArgs<ExtArgs>>): Prisma__ligne_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ligne_soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ligne_soustraitant_etat_avancementCountArgs} args - Arguments to filter Ligne_soustraitant_etat_avancements to count.
     * @example
     * // Count the number of Ligne_soustraitant_etat_avancements
     * const count = await prisma.ligne_soustraitant_etat_avancement.count({
     *   where: {
     *     // ... the filter for the Ligne_soustraitant_etat_avancements we want to count
     *   }
     * })
    **/
    count<T extends ligne_soustraitant_etat_avancementCountArgs>(
      args?: Subset<T, ligne_soustraitant_etat_avancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ligne_soustraitant_etat_avancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ligne_soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ligne_soustraitant_etat_avancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ligne_soustraitant_etat_avancementAggregateArgs>(args: Subset<T, Ligne_soustraitant_etat_avancementAggregateArgs>): Prisma.PrismaPromise<GetLigne_soustraitant_etat_avancementAggregateType<T>>

    /**
     * Group by Ligne_soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ligne_soustraitant_etat_avancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ligne_soustraitant_etat_avancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ligne_soustraitant_etat_avancementGroupByArgs['orderBy'] }
        : { orderBy?: ligne_soustraitant_etat_avancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ligne_soustraitant_etat_avancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigne_soustraitant_etat_avancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ligne_soustraitant_etat_avancement model
   */
  readonly fields: ligne_soustraitant_etat_avancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ligne_soustraitant_etat_avancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ligne_soustraitant_etat_avancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soustraitant_etat_avancement<T extends soustraitant_etat_avancementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancementDefaultArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ligne_soustraitant_etat_avancement model
   */ 
  interface ligne_soustraitant_etat_avancementFieldRefs {
    readonly id: FieldRef<"ligne_soustraitant_etat_avancement", 'Int'>
    readonly soustraitantEtatAvancementId: FieldRef<"ligne_soustraitant_etat_avancement", 'Int'>
    readonly article: FieldRef<"ligne_soustraitant_etat_avancement", 'String'>
    readonly description: FieldRef<"ligne_soustraitant_etat_avancement", 'String'>
    readonly type: FieldRef<"ligne_soustraitant_etat_avancement", 'String'>
    readonly unite: FieldRef<"ligne_soustraitant_etat_avancement", 'String'>
    readonly prixUnitaire: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly quantite: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly quantitePrecedente: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly quantiteActuelle: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly quantiteTotale: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly montantPrecedent: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly montantActuel: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly montantTotal: FieldRef<"ligne_soustraitant_etat_avancement", 'Float'>
    readonly createdAt: FieldRef<"ligne_soustraitant_etat_avancement", 'DateTime'>
    readonly updatedAt: FieldRef<"ligne_soustraitant_etat_avancement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ligne_soustraitant_etat_avancement findUnique
   */
  export type ligne_soustraitant_etat_avancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which ligne_soustraitant_etat_avancement to fetch.
     */
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * ligne_soustraitant_etat_avancement findUniqueOrThrow
   */
  export type ligne_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which ligne_soustraitant_etat_avancement to fetch.
     */
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * ligne_soustraitant_etat_avancement findFirst
   */
  export type ligne_soustraitant_etat_avancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which ligne_soustraitant_etat_avancement to fetch.
     */
    where?: ligne_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ligne_soustraitant_etat_avancements to fetch.
     */
    orderBy?: ligne_soustraitant_etat_avancementOrderByWithRelationInput | ligne_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ligne_soustraitant_etat_avancements.
     */
    cursor?: ligne_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ligne_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ligne_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ligne_soustraitant_etat_avancements.
     */
    distinct?: Ligne_soustraitant_etat_avancementScalarFieldEnum | Ligne_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * ligne_soustraitant_etat_avancement findFirstOrThrow
   */
  export type ligne_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which ligne_soustraitant_etat_avancement to fetch.
     */
    where?: ligne_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ligne_soustraitant_etat_avancements to fetch.
     */
    orderBy?: ligne_soustraitant_etat_avancementOrderByWithRelationInput | ligne_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ligne_soustraitant_etat_avancements.
     */
    cursor?: ligne_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ligne_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ligne_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ligne_soustraitant_etat_avancements.
     */
    distinct?: Ligne_soustraitant_etat_avancementScalarFieldEnum | Ligne_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * ligne_soustraitant_etat_avancement findMany
   */
  export type ligne_soustraitant_etat_avancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which ligne_soustraitant_etat_avancements to fetch.
     */
    where?: ligne_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ligne_soustraitant_etat_avancements to fetch.
     */
    orderBy?: ligne_soustraitant_etat_avancementOrderByWithRelationInput | ligne_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ligne_soustraitant_etat_avancements.
     */
    cursor?: ligne_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ligne_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ligne_soustraitant_etat_avancements.
     */
    skip?: number
    distinct?: Ligne_soustraitant_etat_avancementScalarFieldEnum | Ligne_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * ligne_soustraitant_etat_avancement create
   */
  export type ligne_soustraitant_etat_avancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to create a ligne_soustraitant_etat_avancement.
     */
    data: XOR<ligne_soustraitant_etat_avancementCreateInput, ligne_soustraitant_etat_avancementUncheckedCreateInput>
  }

  /**
   * ligne_soustraitant_etat_avancement createMany
   */
  export type ligne_soustraitant_etat_avancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ligne_soustraitant_etat_avancements.
     */
    data: ligne_soustraitant_etat_avancementCreateManyInput | ligne_soustraitant_etat_avancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ligne_soustraitant_etat_avancement update
   */
  export type ligne_soustraitant_etat_avancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to update a ligne_soustraitant_etat_avancement.
     */
    data: XOR<ligne_soustraitant_etat_avancementUpdateInput, ligne_soustraitant_etat_avancementUncheckedUpdateInput>
    /**
     * Choose, which ligne_soustraitant_etat_avancement to update.
     */
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * ligne_soustraitant_etat_avancement updateMany
   */
  export type ligne_soustraitant_etat_avancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ligne_soustraitant_etat_avancements.
     */
    data: XOR<ligne_soustraitant_etat_avancementUpdateManyMutationInput, ligne_soustraitant_etat_avancementUncheckedUpdateManyInput>
    /**
     * Filter which ligne_soustraitant_etat_avancements to update
     */
    where?: ligne_soustraitant_etat_avancementWhereInput
    /**
     * Limit how many ligne_soustraitant_etat_avancements to update.
     */
    limit?: number
  }

  /**
   * ligne_soustraitant_etat_avancement upsert
   */
  export type ligne_soustraitant_etat_avancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The filter to search for the ligne_soustraitant_etat_avancement to update in case it exists.
     */
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
    /**
     * In case the ligne_soustraitant_etat_avancement found by the `where` argument doesn't exist, create a new ligne_soustraitant_etat_avancement with this data.
     */
    create: XOR<ligne_soustraitant_etat_avancementCreateInput, ligne_soustraitant_etat_avancementUncheckedCreateInput>
    /**
     * In case the ligne_soustraitant_etat_avancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ligne_soustraitant_etat_avancementUpdateInput, ligne_soustraitant_etat_avancementUncheckedUpdateInput>
  }

  /**
   * ligne_soustraitant_etat_avancement delete
   */
  export type ligne_soustraitant_etat_avancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter which ligne_soustraitant_etat_avancement to delete.
     */
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * ligne_soustraitant_etat_avancement deleteMany
   */
  export type ligne_soustraitant_etat_avancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ligne_soustraitant_etat_avancements to delete
     */
    where?: ligne_soustraitant_etat_avancementWhereInput
    /**
     * Limit how many ligne_soustraitant_etat_avancements to delete.
     */
    limit?: number
  }

  /**
   * ligne_soustraitant_etat_avancement without action
   */
  export type ligne_soustraitant_etat_avancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
  }


  /**
   * Model soustraitant_etat_avancement
   */

  export type AggregateSoustraitant_etat_avancement = {
    _count: Soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  export type Soustraitant_etat_avancementAvgAggregateOutputType = {
    id: number | null
    numero: number | null
    commandeSousTraitantId: number | null
    etatAvancementId: number | null
  }

  export type Soustraitant_etat_avancementSumAggregateOutputType = {
    id: number | null
    numero: number | null
    commandeSousTraitantId: number | null
    etatAvancementId: number | null
  }

  export type Soustraitant_etat_avancementMinAggregateOutputType = {
    id: number | null
    soustraitantId: string | null
    numero: number | null
    date: Date | null
    commentaires: string | null
    estFinalise: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    commandeSousTraitantId: number | null
    etatAvancementId: number | null
  }

  export type Soustraitant_etat_avancementMaxAggregateOutputType = {
    id: number | null
    soustraitantId: string | null
    numero: number | null
    date: Date | null
    commentaires: string | null
    estFinalise: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    commandeSousTraitantId: number | null
    etatAvancementId: number | null
  }

  export type Soustraitant_etat_avancementCountAggregateOutputType = {
    id: number
    soustraitantId: number
    numero: number
    date: number
    commentaires: number
    estFinalise: number
    createdAt: number
    updatedAt: number
    commandeSousTraitantId: number
    etatAvancementId: number
    _all: number
  }


  export type Soustraitant_etat_avancementAvgAggregateInputType = {
    id?: true
    numero?: true
    commandeSousTraitantId?: true
    etatAvancementId?: true
  }

  export type Soustraitant_etat_avancementSumAggregateInputType = {
    id?: true
    numero?: true
    commandeSousTraitantId?: true
    etatAvancementId?: true
  }

  export type Soustraitant_etat_avancementMinAggregateInputType = {
    id?: true
    soustraitantId?: true
    numero?: true
    date?: true
    commentaires?: true
    estFinalise?: true
    createdAt?: true
    updatedAt?: true
    commandeSousTraitantId?: true
    etatAvancementId?: true
  }

  export type Soustraitant_etat_avancementMaxAggregateInputType = {
    id?: true
    soustraitantId?: true
    numero?: true
    date?: true
    commentaires?: true
    estFinalise?: true
    createdAt?: true
    updatedAt?: true
    commandeSousTraitantId?: true
    etatAvancementId?: true
  }

  export type Soustraitant_etat_avancementCountAggregateInputType = {
    id?: true
    soustraitantId?: true
    numero?: true
    date?: true
    commentaires?: true
    estFinalise?: true
    createdAt?: true
    updatedAt?: true
    commandeSousTraitantId?: true
    etatAvancementId?: true
    _all?: true
  }

  export type Soustraitant_etat_avancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which soustraitant_etat_avancement to aggregate.
     */
    where?: soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitant_etat_avancements to fetch.
     */
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned soustraitant_etat_avancements
    **/
    _count?: true | Soustraitant_etat_avancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Soustraitant_etat_avancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Soustraitant_etat_avancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Soustraitant_etat_avancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Soustraitant_etat_avancementMaxAggregateInputType
  }

  export type GetSoustraitant_etat_avancementAggregateType<T extends Soustraitant_etat_avancementAggregateArgs> = {
        [P in keyof T & keyof AggregateSoustraitant_etat_avancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoustraitant_etat_avancement[P]>
      : GetScalarType<T[P], AggregateSoustraitant_etat_avancement[P]>
  }




  export type soustraitant_etat_avancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soustraitant_etat_avancementWhereInput
    orderBy?: soustraitant_etat_avancementOrderByWithAggregationInput | soustraitant_etat_avancementOrderByWithAggregationInput[]
    by: Soustraitant_etat_avancementScalarFieldEnum[] | Soustraitant_etat_avancementScalarFieldEnum
    having?: soustraitant_etat_avancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Soustraitant_etat_avancementCountAggregateInputType | true
    _avg?: Soustraitant_etat_avancementAvgAggregateInputType
    _sum?: Soustraitant_etat_avancementSumAggregateInputType
    _min?: Soustraitant_etat_avancementMinAggregateInputType
    _max?: Soustraitant_etat_avancementMaxAggregateInputType
  }

  export type Soustraitant_etat_avancementGroupByOutputType = {
    id: number
    soustraitantId: string
    numero: number
    date: Date
    commentaires: string | null
    estFinalise: boolean
    createdAt: Date
    updatedAt: Date
    commandeSousTraitantId: number | null
    etatAvancementId: number
    _count: Soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  type GetSoustraitant_etat_avancementGroupByPayload<T extends soustraitant_etat_avancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Soustraitant_etat_avancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Soustraitant_etat_avancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Soustraitant_etat_avancementGroupByOutputType[P]>
            : GetScalarType<T[P], Soustraitant_etat_avancementGroupByOutputType[P]>
        }
      >
    >


  export type soustraitant_etat_avancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    soustraitantId?: boolean
    numero?: boolean
    date?: boolean
    commentaires?: boolean
    estFinalise?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandeSousTraitantId?: boolean
    etatAvancementId?: boolean
    avenant_soustraitant_etat_avancement?: boolean | soustraitant_etat_avancement$avenant_soustraitant_etat_avancementArgs<ExtArgs>
    ligne_soustraitant_etat_avancement?: boolean | soustraitant_etat_avancement$ligne_soustraitant_etat_avancementArgs<ExtArgs>
    photos?: boolean | soustraitant_etat_avancement$photosArgs<ExtArgs>
    commande_soustraitant?: boolean | soustraitant_etat_avancement$commande_soustraitantArgs<ExtArgs>
    etat_avancement?: boolean | EtatAvancementDefaultArgs<ExtArgs>
    soustraitant?: boolean | soustraitantDefaultArgs<ExtArgs>
    _count?: boolean | Soustraitant_etat_avancementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soustraitant_etat_avancement"]>



  export type soustraitant_etat_avancementSelectScalar = {
    id?: boolean
    soustraitantId?: boolean
    numero?: boolean
    date?: boolean
    commentaires?: boolean
    estFinalise?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandeSousTraitantId?: boolean
    etatAvancementId?: boolean
  }

  export type soustraitant_etat_avancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "soustraitantId" | "numero" | "date" | "commentaires" | "estFinalise" | "createdAt" | "updatedAt" | "commandeSousTraitantId" | "etatAvancementId", ExtArgs["result"]["soustraitant_etat_avancement"]>
  export type soustraitant_etat_avancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avenant_soustraitant_etat_avancement?: boolean | soustraitant_etat_avancement$avenant_soustraitant_etat_avancementArgs<ExtArgs>
    ligne_soustraitant_etat_avancement?: boolean | soustraitant_etat_avancement$ligne_soustraitant_etat_avancementArgs<ExtArgs>
    photos?: boolean | soustraitant_etat_avancement$photosArgs<ExtArgs>
    commande_soustraitant?: boolean | soustraitant_etat_avancement$commande_soustraitantArgs<ExtArgs>
    etat_avancement?: boolean | EtatAvancementDefaultArgs<ExtArgs>
    soustraitant?: boolean | soustraitantDefaultArgs<ExtArgs>
    _count?: boolean | Soustraitant_etat_avancementCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $soustraitant_etat_avancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "soustraitant_etat_avancement"
    objects: {
      avenant_soustraitant_etat_avancement: Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>[]
      ligne_soustraitant_etat_avancement: Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>[]
      photos: Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>[]
      commande_soustraitant: Prisma.$CommandeSousTraitantPayload<ExtArgs> | null
      etat_avancement: Prisma.$EtatAvancementPayload<ExtArgs>
      soustraitant: Prisma.$soustraitantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      soustraitantId: string
      numero: number
      date: Date
      commentaires: string | null
      estFinalise: boolean
      createdAt: Date
      updatedAt: Date
      commandeSousTraitantId: number | null
      etatAvancementId: number
    }, ExtArgs["result"]["soustraitant_etat_avancement"]>
    composites: {}
  }

  type soustraitant_etat_avancementGetPayload<S extends boolean | null | undefined | soustraitant_etat_avancementDefaultArgs> = $Result.GetResult<Prisma.$soustraitant_etat_avancementPayload, S>

  type soustraitant_etat_avancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<soustraitant_etat_avancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Soustraitant_etat_avancementCountAggregateInputType | true
    }

  export interface soustraitant_etat_avancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['soustraitant_etat_avancement'], meta: { name: 'soustraitant_etat_avancement' } }
    /**
     * Find zero or one Soustraitant_etat_avancement that matches the filter.
     * @param {soustraitant_etat_avancementFindUniqueArgs} args - Arguments to find a Soustraitant_etat_avancement
     * @example
     * // Get one Soustraitant_etat_avancement
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends soustraitant_etat_avancementFindUniqueArgs>(args: SelectSubset<T, soustraitant_etat_avancementFindUniqueArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Soustraitant_etat_avancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {soustraitant_etat_avancementFindUniqueOrThrowArgs} args - Arguments to find a Soustraitant_etat_avancement
     * @example
     * // Get one Soustraitant_etat_avancement
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends soustraitant_etat_avancementFindUniqueOrThrowArgs>(args: SelectSubset<T, soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Soustraitant_etat_avancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitant_etat_avancementFindFirstArgs} args - Arguments to find a Soustraitant_etat_avancement
     * @example
     * // Get one Soustraitant_etat_avancement
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends soustraitant_etat_avancementFindFirstArgs>(args?: SelectSubset<T, soustraitant_etat_avancementFindFirstArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Soustraitant_etat_avancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitant_etat_avancementFindFirstOrThrowArgs} args - Arguments to find a Soustraitant_etat_avancement
     * @example
     * // Get one Soustraitant_etat_avancement
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends soustraitant_etat_avancementFindFirstOrThrowArgs>(args?: SelectSubset<T, soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Soustraitant_etat_avancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitant_etat_avancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Soustraitant_etat_avancements
     * const soustraitant_etat_avancements = await prisma.soustraitant_etat_avancement.findMany()
     * 
     * // Get first 10 Soustraitant_etat_avancements
     * const soustraitant_etat_avancements = await prisma.soustraitant_etat_avancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soustraitant_etat_avancementWithIdOnly = await prisma.soustraitant_etat_avancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends soustraitant_etat_avancementFindManyArgs>(args?: SelectSubset<T, soustraitant_etat_avancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Soustraitant_etat_avancement.
     * @param {soustraitant_etat_avancementCreateArgs} args - Arguments to create a Soustraitant_etat_avancement.
     * @example
     * // Create one Soustraitant_etat_avancement
     * const Soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.create({
     *   data: {
     *     // ... data to create a Soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    create<T extends soustraitant_etat_avancementCreateArgs>(args: SelectSubset<T, soustraitant_etat_avancementCreateArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Soustraitant_etat_avancements.
     * @param {soustraitant_etat_avancementCreateManyArgs} args - Arguments to create many Soustraitant_etat_avancements.
     * @example
     * // Create many Soustraitant_etat_avancements
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends soustraitant_etat_avancementCreateManyArgs>(args?: SelectSubset<T, soustraitant_etat_avancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Soustraitant_etat_avancement.
     * @param {soustraitant_etat_avancementDeleteArgs} args - Arguments to delete one Soustraitant_etat_avancement.
     * @example
     * // Delete one Soustraitant_etat_avancement
     * const Soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.delete({
     *   where: {
     *     // ... filter to delete one Soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    delete<T extends soustraitant_etat_avancementDeleteArgs>(args: SelectSubset<T, soustraitant_etat_avancementDeleteArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Soustraitant_etat_avancement.
     * @param {soustraitant_etat_avancementUpdateArgs} args - Arguments to update one Soustraitant_etat_avancement.
     * @example
     * // Update one Soustraitant_etat_avancement
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends soustraitant_etat_avancementUpdateArgs>(args: SelectSubset<T, soustraitant_etat_avancementUpdateArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Soustraitant_etat_avancements.
     * @param {soustraitant_etat_avancementDeleteManyArgs} args - Arguments to filter Soustraitant_etat_avancements to delete.
     * @example
     * // Delete a few Soustraitant_etat_avancements
     * const { count } = await prisma.soustraitant_etat_avancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends soustraitant_etat_avancementDeleteManyArgs>(args?: SelectSubset<T, soustraitant_etat_avancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitant_etat_avancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Soustraitant_etat_avancements
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends soustraitant_etat_avancementUpdateManyArgs>(args: SelectSubset<T, soustraitant_etat_avancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Soustraitant_etat_avancement.
     * @param {soustraitant_etat_avancementUpsertArgs} args - Arguments to update or create a Soustraitant_etat_avancement.
     * @example
     * // Update or create a Soustraitant_etat_avancement
     * const soustraitant_etat_avancement = await prisma.soustraitant_etat_avancement.upsert({
     *   create: {
     *     // ... data to create a Soustraitant_etat_avancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Soustraitant_etat_avancement we want to update
     *   }
     * })
     */
    upsert<T extends soustraitant_etat_avancementUpsertArgs>(args: SelectSubset<T, soustraitant_etat_avancementUpsertArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitant_etat_avancementCountArgs} args - Arguments to filter Soustraitant_etat_avancements to count.
     * @example
     * // Count the number of Soustraitant_etat_avancements
     * const count = await prisma.soustraitant_etat_avancement.count({
     *   where: {
     *     // ... the filter for the Soustraitant_etat_avancements we want to count
     *   }
     * })
    **/
    count<T extends soustraitant_etat_avancementCountArgs>(
      args?: Subset<T, soustraitant_etat_avancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Soustraitant_etat_avancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Soustraitant_etat_avancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Soustraitant_etat_avancementAggregateArgs>(args: Subset<T, Soustraitant_etat_avancementAggregateArgs>): Prisma.PrismaPromise<GetSoustraitant_etat_avancementAggregateType<T>>

    /**
     * Group by Soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soustraitant_etat_avancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends soustraitant_etat_avancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: soustraitant_etat_avancementGroupByArgs['orderBy'] }
        : { orderBy?: soustraitant_etat_avancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, soustraitant_etat_avancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoustraitant_etat_avancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the soustraitant_etat_avancement model
   */
  readonly fields: soustraitant_etat_avancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for soustraitant_etat_avancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__soustraitant_etat_avancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avenant_soustraitant_etat_avancement<T extends soustraitant_etat_avancement$avenant_soustraitant_etat_avancementArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancement$avenant_soustraitant_etat_avancementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avenant_soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ligne_soustraitant_etat_avancement<T extends soustraitant_etat_avancement$ligne_soustraitant_etat_avancementArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancement$ligne_soustraitant_etat_avancementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ligne_soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends soustraitant_etat_avancement$photosArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancement$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commande_soustraitant<T extends soustraitant_etat_avancement$commande_soustraitantArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancement$commande_soustraitantArgs<ExtArgs>>): Prisma__CommandeSousTraitantClient<$Result.GetResult<Prisma.$CommandeSousTraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    etat_avancement<T extends EtatAvancementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtatAvancementDefaultArgs<ExtArgs>>): Prisma__EtatAvancementClient<$Result.GetResult<Prisma.$EtatAvancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    soustraitant<T extends soustraitantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, soustraitantDefaultArgs<ExtArgs>>): Prisma__soustraitantClient<$Result.GetResult<Prisma.$soustraitantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the soustraitant_etat_avancement model
   */ 
  interface soustraitant_etat_avancementFieldRefs {
    readonly id: FieldRef<"soustraitant_etat_avancement", 'Int'>
    readonly soustraitantId: FieldRef<"soustraitant_etat_avancement", 'String'>
    readonly numero: FieldRef<"soustraitant_etat_avancement", 'Int'>
    readonly date: FieldRef<"soustraitant_etat_avancement", 'DateTime'>
    readonly commentaires: FieldRef<"soustraitant_etat_avancement", 'String'>
    readonly estFinalise: FieldRef<"soustraitant_etat_avancement", 'Boolean'>
    readonly createdAt: FieldRef<"soustraitant_etat_avancement", 'DateTime'>
    readonly updatedAt: FieldRef<"soustraitant_etat_avancement", 'DateTime'>
    readonly commandeSousTraitantId: FieldRef<"soustraitant_etat_avancement", 'Int'>
    readonly etatAvancementId: FieldRef<"soustraitant_etat_avancement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * soustraitant_etat_avancement findUnique
   */
  export type soustraitant_etat_avancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant_etat_avancement to fetch.
     */
    where: soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * soustraitant_etat_avancement findUniqueOrThrow
   */
  export type soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant_etat_avancement to fetch.
     */
    where: soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * soustraitant_etat_avancement findFirst
   */
  export type soustraitant_etat_avancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant_etat_avancement to fetch.
     */
    where?: soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitant_etat_avancements to fetch.
     */
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for soustraitant_etat_avancements.
     */
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of soustraitant_etat_avancements.
     */
    distinct?: Soustraitant_etat_avancementScalarFieldEnum | Soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant_etat_avancement findFirstOrThrow
   */
  export type soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant_etat_avancement to fetch.
     */
    where?: soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitant_etat_avancements to fetch.
     */
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for soustraitant_etat_avancements.
     */
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of soustraitant_etat_avancements.
     */
    distinct?: Soustraitant_etat_avancementScalarFieldEnum | Soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant_etat_avancement findMany
   */
  export type soustraitant_etat_avancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which soustraitant_etat_avancements to fetch.
     */
    where?: soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soustraitant_etat_avancements to fetch.
     */
    orderBy?: soustraitant_etat_avancementOrderByWithRelationInput | soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing soustraitant_etat_avancements.
     */
    cursor?: soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soustraitant_etat_avancements.
     */
    skip?: number
    distinct?: Soustraitant_etat_avancementScalarFieldEnum | Soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant_etat_avancement create
   */
  export type soustraitant_etat_avancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to create a soustraitant_etat_avancement.
     */
    data: XOR<soustraitant_etat_avancementCreateInput, soustraitant_etat_avancementUncheckedCreateInput>
  }

  /**
   * soustraitant_etat_avancement createMany
   */
  export type soustraitant_etat_avancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many soustraitant_etat_avancements.
     */
    data: soustraitant_etat_avancementCreateManyInput | soustraitant_etat_avancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * soustraitant_etat_avancement update
   */
  export type soustraitant_etat_avancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to update a soustraitant_etat_avancement.
     */
    data: XOR<soustraitant_etat_avancementUpdateInput, soustraitant_etat_avancementUncheckedUpdateInput>
    /**
     * Choose, which soustraitant_etat_avancement to update.
     */
    where: soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * soustraitant_etat_avancement updateMany
   */
  export type soustraitant_etat_avancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update soustraitant_etat_avancements.
     */
    data: XOR<soustraitant_etat_avancementUpdateManyMutationInput, soustraitant_etat_avancementUncheckedUpdateManyInput>
    /**
     * Filter which soustraitant_etat_avancements to update
     */
    where?: soustraitant_etat_avancementWhereInput
    /**
     * Limit how many soustraitant_etat_avancements to update.
     */
    limit?: number
  }

  /**
   * soustraitant_etat_avancement upsert
   */
  export type soustraitant_etat_avancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The filter to search for the soustraitant_etat_avancement to update in case it exists.
     */
    where: soustraitant_etat_avancementWhereUniqueInput
    /**
     * In case the soustraitant_etat_avancement found by the `where` argument doesn't exist, create a new soustraitant_etat_avancement with this data.
     */
    create: XOR<soustraitant_etat_avancementCreateInput, soustraitant_etat_avancementUncheckedCreateInput>
    /**
     * In case the soustraitant_etat_avancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<soustraitant_etat_avancementUpdateInput, soustraitant_etat_avancementUncheckedUpdateInput>
  }

  /**
   * soustraitant_etat_avancement delete
   */
  export type soustraitant_etat_avancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter which soustraitant_etat_avancement to delete.
     */
    where: soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * soustraitant_etat_avancement deleteMany
   */
  export type soustraitant_etat_avancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which soustraitant_etat_avancements to delete
     */
    where?: soustraitant_etat_avancementWhereInput
    /**
     * Limit how many soustraitant_etat_avancements to delete.
     */
    limit?: number
  }

  /**
   * soustraitant_etat_avancement.avenant_soustraitant_etat_avancement
   */
  export type soustraitant_etat_avancement$avenant_soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avenant_soustraitant_etat_avancement
     */
    select?: avenant_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the avenant_soustraitant_etat_avancement
     */
    omit?: avenant_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avenant_soustraitant_etat_avancementInclude<ExtArgs> | null
    where?: avenant_soustraitant_etat_avancementWhereInput
    orderBy?: avenant_soustraitant_etat_avancementOrderByWithRelationInput | avenant_soustraitant_etat_avancementOrderByWithRelationInput[]
    cursor?: avenant_soustraitant_etat_avancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Avenant_soustraitant_etat_avancementScalarFieldEnum | Avenant_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant_etat_avancement.ligne_soustraitant_etat_avancement
   */
  export type soustraitant_etat_avancement$ligne_soustraitant_etat_avancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ligne_soustraitant_etat_avancement
     */
    select?: ligne_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ligne_soustraitant_etat_avancement
     */
    omit?: ligne_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ligne_soustraitant_etat_avancementInclude<ExtArgs> | null
    where?: ligne_soustraitant_etat_avancementWhereInput
    orderBy?: ligne_soustraitant_etat_avancementOrderByWithRelationInput | ligne_soustraitant_etat_avancementOrderByWithRelationInput[]
    cursor?: ligne_soustraitant_etat_avancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ligne_soustraitant_etat_avancementScalarFieldEnum | Ligne_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant_etat_avancement.photos
   */
  export type soustraitant_etat_avancement$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    where?: photo_soustraitant_etat_avancementWhereInput
    orderBy?: photo_soustraitant_etat_avancementOrderByWithRelationInput | photo_soustraitant_etat_avancementOrderByWithRelationInput[]
    cursor?: photo_soustraitant_etat_avancementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Photo_soustraitant_etat_avancementScalarFieldEnum | Photo_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * soustraitant_etat_avancement.commande_soustraitant
   */
  export type soustraitant_etat_avancement$commande_soustraitantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeSousTraitant
     */
    select?: CommandeSousTraitantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandeSousTraitant
     */
    omit?: CommandeSousTraitantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeSousTraitantInclude<ExtArgs> | null
    where?: CommandeSousTraitantWhereInput
  }

  /**
   * soustraitant_etat_avancement without action
   */
  export type soustraitant_etat_avancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soustraitant_etat_avancement
     */
    select?: soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soustraitant_etat_avancement
     */
    omit?: soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soustraitant_etat_avancementInclude<ExtArgs> | null
  }


  /**
   * Model photo_soustraitant_etat_avancement
   */

  export type AggregatePhoto_soustraitant_etat_avancement = {
    _count: Photo_soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Photo_soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Photo_soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Photo_soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Photo_soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  export type Photo_soustraitant_etat_avancementAvgAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
  }

  export type Photo_soustraitant_etat_avancementSumAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
  }

  export type Photo_soustraitant_etat_avancementMinAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    url: string | null
    description: string | null
    dateAjout: Date | null
  }

  export type Photo_soustraitant_etat_avancementMaxAggregateOutputType = {
    id: number | null
    soustraitantEtatAvancementId: number | null
    url: string | null
    description: string | null
    dateAjout: Date | null
  }

  export type Photo_soustraitant_etat_avancementCountAggregateOutputType = {
    id: number
    soustraitantEtatAvancementId: number
    url: number
    description: number
    dateAjout: number
    _all: number
  }


  export type Photo_soustraitant_etat_avancementAvgAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
  }

  export type Photo_soustraitant_etat_avancementSumAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
  }

  export type Photo_soustraitant_etat_avancementMinAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    url?: true
    description?: true
    dateAjout?: true
  }

  export type Photo_soustraitant_etat_avancementMaxAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    url?: true
    description?: true
    dateAjout?: true
  }

  export type Photo_soustraitant_etat_avancementCountAggregateInputType = {
    id?: true
    soustraitantEtatAvancementId?: true
    url?: true
    description?: true
    dateAjout?: true
    _all?: true
  }

  export type Photo_soustraitant_etat_avancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photo_soustraitant_etat_avancement to aggregate.
     */
    where?: photo_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photo_soustraitant_etat_avancements to fetch.
     */
    orderBy?: photo_soustraitant_etat_avancementOrderByWithRelationInput | photo_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: photo_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photo_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photo_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned photo_soustraitant_etat_avancements
    **/
    _count?: true | Photo_soustraitant_etat_avancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Photo_soustraitant_etat_avancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Photo_soustraitant_etat_avancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Photo_soustraitant_etat_avancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Photo_soustraitant_etat_avancementMaxAggregateInputType
  }

  export type GetPhoto_soustraitant_etat_avancementAggregateType<T extends Photo_soustraitant_etat_avancementAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto_soustraitant_etat_avancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto_soustraitant_etat_avancement[P]>
      : GetScalarType<T[P], AggregatePhoto_soustraitant_etat_avancement[P]>
  }




  export type photo_soustraitant_etat_avancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: photo_soustraitant_etat_avancementWhereInput
    orderBy?: photo_soustraitant_etat_avancementOrderByWithAggregationInput | photo_soustraitant_etat_avancementOrderByWithAggregationInput[]
    by: Photo_soustraitant_etat_avancementScalarFieldEnum[] | Photo_soustraitant_etat_avancementScalarFieldEnum
    having?: photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Photo_soustraitant_etat_avancementCountAggregateInputType | true
    _avg?: Photo_soustraitant_etat_avancementAvgAggregateInputType
    _sum?: Photo_soustraitant_etat_avancementSumAggregateInputType
    _min?: Photo_soustraitant_etat_avancementMinAggregateInputType
    _max?: Photo_soustraitant_etat_avancementMaxAggregateInputType
  }

  export type Photo_soustraitant_etat_avancementGroupByOutputType = {
    id: number
    soustraitantEtatAvancementId: number
    url: string
    description: string | null
    dateAjout: Date
    _count: Photo_soustraitant_etat_avancementCountAggregateOutputType | null
    _avg: Photo_soustraitant_etat_avancementAvgAggregateOutputType | null
    _sum: Photo_soustraitant_etat_avancementSumAggregateOutputType | null
    _min: Photo_soustraitant_etat_avancementMinAggregateOutputType | null
    _max: Photo_soustraitant_etat_avancementMaxAggregateOutputType | null
  }

  type GetPhoto_soustraitant_etat_avancementGroupByPayload<T extends photo_soustraitant_etat_avancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Photo_soustraitant_etat_avancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Photo_soustraitant_etat_avancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Photo_soustraitant_etat_avancementGroupByOutputType[P]>
            : GetScalarType<T[P], Photo_soustraitant_etat_avancementGroupByOutputType[P]>
        }
      >
    >


  export type photo_soustraitant_etat_avancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    soustraitantEtatAvancementId?: boolean
    url?: boolean
    description?: boolean
    dateAjout?: boolean
    soustraitant_etat_avancement?: boolean | soustraitant_etat_avancementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo_soustraitant_etat_avancement"]>



  export type photo_soustraitant_etat_avancementSelectScalar = {
    id?: boolean
    soustraitantEtatAvancementId?: boolean
    url?: boolean
    description?: boolean
    dateAjout?: boolean
  }

  export type photo_soustraitant_etat_avancementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "soustraitantEtatAvancementId" | "url" | "description" | "dateAjout", ExtArgs["result"]["photo_soustraitant_etat_avancement"]>
  export type photo_soustraitant_etat_avancementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soustraitant_etat_avancement?: boolean | soustraitant_etat_avancementDefaultArgs<ExtArgs>
  }

  export type $photo_soustraitant_etat_avancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "photo_soustraitant_etat_avancement"
    objects: {
      soustraitant_etat_avancement: Prisma.$soustraitant_etat_avancementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      soustraitantEtatAvancementId: number
      url: string
      description: string | null
      dateAjout: Date
    }, ExtArgs["result"]["photo_soustraitant_etat_avancement"]>
    composites: {}
  }

  type photo_soustraitant_etat_avancementGetPayload<S extends boolean | null | undefined | photo_soustraitant_etat_avancementDefaultArgs> = $Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload, S>

  type photo_soustraitant_etat_avancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<photo_soustraitant_etat_avancementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Photo_soustraitant_etat_avancementCountAggregateInputType | true
    }

  export interface photo_soustraitant_etat_avancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['photo_soustraitant_etat_avancement'], meta: { name: 'photo_soustraitant_etat_avancement' } }
    /**
     * Find zero or one Photo_soustraitant_etat_avancement that matches the filter.
     * @param {photo_soustraitant_etat_avancementFindUniqueArgs} args - Arguments to find a Photo_soustraitant_etat_avancement
     * @example
     * // Get one Photo_soustraitant_etat_avancement
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends photo_soustraitant_etat_avancementFindUniqueArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementFindUniqueArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photo_soustraitant_etat_avancement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {photo_soustraitant_etat_avancementFindUniqueOrThrowArgs} args - Arguments to find a Photo_soustraitant_etat_avancement
     * @example
     * // Get one Photo_soustraitant_etat_avancement
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends photo_soustraitant_etat_avancementFindUniqueOrThrowArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photo_soustraitant_etat_avancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photo_soustraitant_etat_avancementFindFirstArgs} args - Arguments to find a Photo_soustraitant_etat_avancement
     * @example
     * // Get one Photo_soustraitant_etat_avancement
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends photo_soustraitant_etat_avancementFindFirstArgs>(args?: SelectSubset<T, photo_soustraitant_etat_avancementFindFirstArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photo_soustraitant_etat_avancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photo_soustraitant_etat_avancementFindFirstOrThrowArgs} args - Arguments to find a Photo_soustraitant_etat_avancement
     * @example
     * // Get one Photo_soustraitant_etat_avancement
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends photo_soustraitant_etat_avancementFindFirstOrThrowArgs>(args?: SelectSubset<T, photo_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photo_soustraitant_etat_avancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photo_soustraitant_etat_avancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photo_soustraitant_etat_avancements
     * const photo_soustraitant_etat_avancements = await prisma.photo_soustraitant_etat_avancement.findMany()
     * 
     * // Get first 10 Photo_soustraitant_etat_avancements
     * const photo_soustraitant_etat_avancements = await prisma.photo_soustraitant_etat_avancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photo_soustraitant_etat_avancementWithIdOnly = await prisma.photo_soustraitant_etat_avancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends photo_soustraitant_etat_avancementFindManyArgs>(args?: SelectSubset<T, photo_soustraitant_etat_avancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photo_soustraitant_etat_avancement.
     * @param {photo_soustraitant_etat_avancementCreateArgs} args - Arguments to create a Photo_soustraitant_etat_avancement.
     * @example
     * // Create one Photo_soustraitant_etat_avancement
     * const Photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.create({
     *   data: {
     *     // ... data to create a Photo_soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    create<T extends photo_soustraitant_etat_avancementCreateArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementCreateArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photo_soustraitant_etat_avancements.
     * @param {photo_soustraitant_etat_avancementCreateManyArgs} args - Arguments to create many Photo_soustraitant_etat_avancements.
     * @example
     * // Create many Photo_soustraitant_etat_avancements
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends photo_soustraitant_etat_avancementCreateManyArgs>(args?: SelectSubset<T, photo_soustraitant_etat_avancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photo_soustraitant_etat_avancement.
     * @param {photo_soustraitant_etat_avancementDeleteArgs} args - Arguments to delete one Photo_soustraitant_etat_avancement.
     * @example
     * // Delete one Photo_soustraitant_etat_avancement
     * const Photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.delete({
     *   where: {
     *     // ... filter to delete one Photo_soustraitant_etat_avancement
     *   }
     * })
     * 
     */
    delete<T extends photo_soustraitant_etat_avancementDeleteArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementDeleteArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photo_soustraitant_etat_avancement.
     * @param {photo_soustraitant_etat_avancementUpdateArgs} args - Arguments to update one Photo_soustraitant_etat_avancement.
     * @example
     * // Update one Photo_soustraitant_etat_avancement
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends photo_soustraitant_etat_avancementUpdateArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementUpdateArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photo_soustraitant_etat_avancements.
     * @param {photo_soustraitant_etat_avancementDeleteManyArgs} args - Arguments to filter Photo_soustraitant_etat_avancements to delete.
     * @example
     * // Delete a few Photo_soustraitant_etat_avancements
     * const { count } = await prisma.photo_soustraitant_etat_avancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends photo_soustraitant_etat_avancementDeleteManyArgs>(args?: SelectSubset<T, photo_soustraitant_etat_avancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photo_soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photo_soustraitant_etat_avancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photo_soustraitant_etat_avancements
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends photo_soustraitant_etat_avancementUpdateManyArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo_soustraitant_etat_avancement.
     * @param {photo_soustraitant_etat_avancementUpsertArgs} args - Arguments to update or create a Photo_soustraitant_etat_avancement.
     * @example
     * // Update or create a Photo_soustraitant_etat_avancement
     * const photo_soustraitant_etat_avancement = await prisma.photo_soustraitant_etat_avancement.upsert({
     *   create: {
     *     // ... data to create a Photo_soustraitant_etat_avancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo_soustraitant_etat_avancement we want to update
     *   }
     * })
     */
    upsert<T extends photo_soustraitant_etat_avancementUpsertArgs>(args: SelectSubset<T, photo_soustraitant_etat_avancementUpsertArgs<ExtArgs>>): Prisma__photo_soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$photo_soustraitant_etat_avancementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photo_soustraitant_etat_avancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photo_soustraitant_etat_avancementCountArgs} args - Arguments to filter Photo_soustraitant_etat_avancements to count.
     * @example
     * // Count the number of Photo_soustraitant_etat_avancements
     * const count = await prisma.photo_soustraitant_etat_avancement.count({
     *   where: {
     *     // ... the filter for the Photo_soustraitant_etat_avancements we want to count
     *   }
     * })
    **/
    count<T extends photo_soustraitant_etat_avancementCountArgs>(
      args?: Subset<T, photo_soustraitant_etat_avancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Photo_soustraitant_etat_avancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo_soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Photo_soustraitant_etat_avancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Photo_soustraitant_etat_avancementAggregateArgs>(args: Subset<T, Photo_soustraitant_etat_avancementAggregateArgs>): Prisma.PrismaPromise<GetPhoto_soustraitant_etat_avancementAggregateType<T>>

    /**
     * Group by Photo_soustraitant_etat_avancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {photo_soustraitant_etat_avancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends photo_soustraitant_etat_avancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: photo_soustraitant_etat_avancementGroupByArgs['orderBy'] }
        : { orderBy?: photo_soustraitant_etat_avancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, photo_soustraitant_etat_avancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoto_soustraitant_etat_avancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the photo_soustraitant_etat_avancement model
   */
  readonly fields: photo_soustraitant_etat_avancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for photo_soustraitant_etat_avancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__photo_soustraitant_etat_avancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soustraitant_etat_avancement<T extends soustraitant_etat_avancementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, soustraitant_etat_avancementDefaultArgs<ExtArgs>>): Prisma__soustraitant_etat_avancementClient<$Result.GetResult<Prisma.$soustraitant_etat_avancementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the photo_soustraitant_etat_avancement model
   */ 
  interface photo_soustraitant_etat_avancementFieldRefs {
    readonly id: FieldRef<"photo_soustraitant_etat_avancement", 'Int'>
    readonly soustraitantEtatAvancementId: FieldRef<"photo_soustraitant_etat_avancement", 'Int'>
    readonly url: FieldRef<"photo_soustraitant_etat_avancement", 'String'>
    readonly description: FieldRef<"photo_soustraitant_etat_avancement", 'String'>
    readonly dateAjout: FieldRef<"photo_soustraitant_etat_avancement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * photo_soustraitant_etat_avancement findUnique
   */
  export type photo_soustraitant_etat_avancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which photo_soustraitant_etat_avancement to fetch.
     */
    where: photo_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * photo_soustraitant_etat_avancement findUniqueOrThrow
   */
  export type photo_soustraitant_etat_avancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which photo_soustraitant_etat_avancement to fetch.
     */
    where: photo_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * photo_soustraitant_etat_avancement findFirst
   */
  export type photo_soustraitant_etat_avancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which photo_soustraitant_etat_avancement to fetch.
     */
    where?: photo_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photo_soustraitant_etat_avancements to fetch.
     */
    orderBy?: photo_soustraitant_etat_avancementOrderByWithRelationInput | photo_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photo_soustraitant_etat_avancements.
     */
    cursor?: photo_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photo_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photo_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photo_soustraitant_etat_avancements.
     */
    distinct?: Photo_soustraitant_etat_avancementScalarFieldEnum | Photo_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * photo_soustraitant_etat_avancement findFirstOrThrow
   */
  export type photo_soustraitant_etat_avancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which photo_soustraitant_etat_avancement to fetch.
     */
    where?: photo_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photo_soustraitant_etat_avancements to fetch.
     */
    orderBy?: photo_soustraitant_etat_avancementOrderByWithRelationInput | photo_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for photo_soustraitant_etat_avancements.
     */
    cursor?: photo_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photo_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photo_soustraitant_etat_avancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of photo_soustraitant_etat_avancements.
     */
    distinct?: Photo_soustraitant_etat_avancementScalarFieldEnum | Photo_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * photo_soustraitant_etat_avancement findMany
   */
  export type photo_soustraitant_etat_avancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter, which photo_soustraitant_etat_avancements to fetch.
     */
    where?: photo_soustraitant_etat_avancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of photo_soustraitant_etat_avancements to fetch.
     */
    orderBy?: photo_soustraitant_etat_avancementOrderByWithRelationInput | photo_soustraitant_etat_avancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing photo_soustraitant_etat_avancements.
     */
    cursor?: photo_soustraitant_etat_avancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` photo_soustraitant_etat_avancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` photo_soustraitant_etat_avancements.
     */
    skip?: number
    distinct?: Photo_soustraitant_etat_avancementScalarFieldEnum | Photo_soustraitant_etat_avancementScalarFieldEnum[]
  }

  /**
   * photo_soustraitant_etat_avancement create
   */
  export type photo_soustraitant_etat_avancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to create a photo_soustraitant_etat_avancement.
     */
    data: XOR<photo_soustraitant_etat_avancementCreateInput, photo_soustraitant_etat_avancementUncheckedCreateInput>
  }

  /**
   * photo_soustraitant_etat_avancement createMany
   */
  export type photo_soustraitant_etat_avancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many photo_soustraitant_etat_avancements.
     */
    data: photo_soustraitant_etat_avancementCreateManyInput | photo_soustraitant_etat_avancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * photo_soustraitant_etat_avancement update
   */
  export type photo_soustraitant_etat_avancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The data needed to update a photo_soustraitant_etat_avancement.
     */
    data: XOR<photo_soustraitant_etat_avancementUpdateInput, photo_soustraitant_etat_avancementUncheckedUpdateInput>
    /**
     * Choose, which photo_soustraitant_etat_avancement to update.
     */
    where: photo_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * photo_soustraitant_etat_avancement updateMany
   */
  export type photo_soustraitant_etat_avancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update photo_soustraitant_etat_avancements.
     */
    data: XOR<photo_soustraitant_etat_avancementUpdateManyMutationInput, photo_soustraitant_etat_avancementUncheckedUpdateManyInput>
    /**
     * Filter which photo_soustraitant_etat_avancements to update
     */
    where?: photo_soustraitant_etat_avancementWhereInput
    /**
     * Limit how many photo_soustraitant_etat_avancements to update.
     */
    limit?: number
  }

  /**
   * photo_soustraitant_etat_avancement upsert
   */
  export type photo_soustraitant_etat_avancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * The filter to search for the photo_soustraitant_etat_avancement to update in case it exists.
     */
    where: photo_soustraitant_etat_avancementWhereUniqueInput
    /**
     * In case the photo_soustraitant_etat_avancement found by the `where` argument doesn't exist, create a new photo_soustraitant_etat_avancement with this data.
     */
    create: XOR<photo_soustraitant_etat_avancementCreateInput, photo_soustraitant_etat_avancementUncheckedCreateInput>
    /**
     * In case the photo_soustraitant_etat_avancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<photo_soustraitant_etat_avancementUpdateInput, photo_soustraitant_etat_avancementUncheckedUpdateInput>
  }

  /**
   * photo_soustraitant_etat_avancement delete
   */
  export type photo_soustraitant_etat_avancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
    /**
     * Filter which photo_soustraitant_etat_avancement to delete.
     */
    where: photo_soustraitant_etat_avancementWhereUniqueInput
  }

  /**
   * photo_soustraitant_etat_avancement deleteMany
   */
  export type photo_soustraitant_etat_avancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which photo_soustraitant_etat_avancements to delete
     */
    where?: photo_soustraitant_etat_avancementWhereInput
    /**
     * Limit how many photo_soustraitant_etat_avancements to delete.
     */
    limit?: number
  }

  /**
   * photo_soustraitant_etat_avancement without action
   */
  export type photo_soustraitant_etat_avancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the photo_soustraitant_etat_avancement
     */
    select?: photo_soustraitant_etat_avancementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the photo_soustraitant_etat_avancement
     */
    omit?: photo_soustraitant_etat_avancementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: photo_soustraitant_etat_avancementInclude<ExtArgs> | null
  }


  /**
   * Model Depense
   */

  export type AggregateDepense = {
    _count: DepenseCountAggregateOutputType | null
    _avg: DepenseAvgAggregateOutputType | null
    _sum: DepenseSumAggregateOutputType | null
    _min: DepenseMinAggregateOutputType | null
    _max: DepenseMaxAggregateOutputType | null
  }

  export type DepenseAvgAggregateOutputType = {
    montant: number | null
  }

  export type DepenseSumAggregateOutputType = {
    montant: number | null
  }

  export type DepenseMinAggregateOutputType = {
    id: string | null
    chantierId: string | null
    date: Date | null
    montant: number | null
    description: string | null
    categorie: string | null
    fournisseur: string | null
    reference: string | null
    justificatif: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepenseMaxAggregateOutputType = {
    id: string | null
    chantierId: string | null
    date: Date | null
    montant: number | null
    description: string | null
    categorie: string | null
    fournisseur: string | null
    reference: string | null
    justificatif: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepenseCountAggregateOutputType = {
    id: number
    chantierId: number
    date: number
    montant: number
    description: number
    categorie: number
    fournisseur: number
    reference: number
    justificatif: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepenseAvgAggregateInputType = {
    montant?: true
  }

  export type DepenseSumAggregateInputType = {
    montant?: true
  }

  export type DepenseMinAggregateInputType = {
    id?: true
    chantierId?: true
    date?: true
    montant?: true
    description?: true
    categorie?: true
    fournisseur?: true
    reference?: true
    justificatif?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepenseMaxAggregateInputType = {
    id?: true
    chantierId?: true
    date?: true
    montant?: true
    description?: true
    categorie?: true
    fournisseur?: true
    reference?: true
    justificatif?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepenseCountAggregateInputType = {
    id?: true
    chantierId?: true
    date?: true
    montant?: true
    description?: true
    categorie?: true
    fournisseur?: true
    reference?: true
    justificatif?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depense to aggregate.
     */
    where?: DepenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depenses to fetch.
     */
    orderBy?: DepenseOrderByWithRelationInput | DepenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Depenses
    **/
    _count?: true | DepenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepenseMaxAggregateInputType
  }

  export type GetDepenseAggregateType<T extends DepenseAggregateArgs> = {
        [P in keyof T & keyof AggregateDepense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepense[P]>
      : GetScalarType<T[P], AggregateDepense[P]>
  }




  export type DepenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepenseWhereInput
    orderBy?: DepenseOrderByWithAggregationInput | DepenseOrderByWithAggregationInput[]
    by: DepenseScalarFieldEnum[] | DepenseScalarFieldEnum
    having?: DepenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepenseCountAggregateInputType | true
    _avg?: DepenseAvgAggregateInputType
    _sum?: DepenseSumAggregateInputType
    _min?: DepenseMinAggregateInputType
    _max?: DepenseMaxAggregateInputType
  }

  export type DepenseGroupByOutputType = {
    id: string
    chantierId: string
    date: Date
    montant: number
    description: string
    categorie: string
    fournisseur: string | null
    reference: string | null
    justificatif: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: DepenseCountAggregateOutputType | null
    _avg: DepenseAvgAggregateOutputType | null
    _sum: DepenseSumAggregateOutputType | null
    _min: DepenseMinAggregateOutputType | null
    _max: DepenseMaxAggregateOutputType | null
  }

  type GetDepenseGroupByPayload<T extends DepenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepenseGroupByOutputType[P]>
            : GetScalarType<T[P], DepenseGroupByOutputType[P]>
        }
      >
    >


  export type DepenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    date?: boolean
    montant?: boolean
    description?: boolean
    categorie?: boolean
    fournisseur?: boolean
    reference?: boolean
    justificatif?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["depense"]>



  export type DepenseSelectScalar = {
    id?: boolean
    chantierId?: boolean
    date?: boolean
    montant?: boolean
    description?: boolean
    categorie?: boolean
    fournisseur?: boolean
    reference?: boolean
    justificatif?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "date" | "montant" | "description" | "categorie" | "fournisseur" | "reference" | "justificatif" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["depense"]>

  export type $DepensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Depense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chantierId: string
      date: Date
      montant: number
      description: string
      categorie: string
      fournisseur: string | null
      reference: string | null
      justificatif: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["depense"]>
    composites: {}
  }

  type DepenseGetPayload<S extends boolean | null | undefined | DepenseDefaultArgs> = $Result.GetResult<Prisma.$DepensePayload, S>

  type DepenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepenseCountAggregateInputType | true
    }

  export interface DepenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Depense'], meta: { name: 'Depense' } }
    /**
     * Find zero or one Depense that matches the filter.
     * @param {DepenseFindUniqueArgs} args - Arguments to find a Depense
     * @example
     * // Get one Depense
     * const depense = await prisma.depense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepenseFindUniqueArgs>(args: SelectSubset<T, DepenseFindUniqueArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Depense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepenseFindUniqueOrThrowArgs} args - Arguments to find a Depense
     * @example
     * // Get one Depense
     * const depense = await prisma.depense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepenseFindUniqueOrThrowArgs>(args: SelectSubset<T, DepenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Depense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseFindFirstArgs} args - Arguments to find a Depense
     * @example
     * // Get one Depense
     * const depense = await prisma.depense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepenseFindFirstArgs>(args?: SelectSubset<T, DepenseFindFirstArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Depense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseFindFirstOrThrowArgs} args - Arguments to find a Depense
     * @example
     * // Get one Depense
     * const depense = await prisma.depense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepenseFindFirstOrThrowArgs>(args?: SelectSubset<T, DepenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Depenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Depenses
     * const depenses = await prisma.depense.findMany()
     * 
     * // Get first 10 Depenses
     * const depenses = await prisma.depense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depenseWithIdOnly = await prisma.depense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepenseFindManyArgs>(args?: SelectSubset<T, DepenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Depense.
     * @param {DepenseCreateArgs} args - Arguments to create a Depense.
     * @example
     * // Create one Depense
     * const Depense = await prisma.depense.create({
     *   data: {
     *     // ... data to create a Depense
     *   }
     * })
     * 
     */
    create<T extends DepenseCreateArgs>(args: SelectSubset<T, DepenseCreateArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Depenses.
     * @param {DepenseCreateManyArgs} args - Arguments to create many Depenses.
     * @example
     * // Create many Depenses
     * const depense = await prisma.depense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepenseCreateManyArgs>(args?: SelectSubset<T, DepenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Depense.
     * @param {DepenseDeleteArgs} args - Arguments to delete one Depense.
     * @example
     * // Delete one Depense
     * const Depense = await prisma.depense.delete({
     *   where: {
     *     // ... filter to delete one Depense
     *   }
     * })
     * 
     */
    delete<T extends DepenseDeleteArgs>(args: SelectSubset<T, DepenseDeleteArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Depense.
     * @param {DepenseUpdateArgs} args - Arguments to update one Depense.
     * @example
     * // Update one Depense
     * const depense = await prisma.depense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepenseUpdateArgs>(args: SelectSubset<T, DepenseUpdateArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Depenses.
     * @param {DepenseDeleteManyArgs} args - Arguments to filter Depenses to delete.
     * @example
     * // Delete a few Depenses
     * const { count } = await prisma.depense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepenseDeleteManyArgs>(args?: SelectSubset<T, DepenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Depenses
     * const depense = await prisma.depense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepenseUpdateManyArgs>(args: SelectSubset<T, DepenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Depense.
     * @param {DepenseUpsertArgs} args - Arguments to update or create a Depense.
     * @example
     * // Update or create a Depense
     * const depense = await prisma.depense.upsert({
     *   create: {
     *     // ... data to create a Depense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Depense we want to update
     *   }
     * })
     */
    upsert<T extends DepenseUpsertArgs>(args: SelectSubset<T, DepenseUpsertArgs<ExtArgs>>): Prisma__DepenseClient<$Result.GetResult<Prisma.$DepensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Depenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseCountArgs} args - Arguments to filter Depenses to count.
     * @example
     * // Count the number of Depenses
     * const count = await prisma.depense.count({
     *   where: {
     *     // ... the filter for the Depenses we want to count
     *   }
     * })
    **/
    count<T extends DepenseCountArgs>(
      args?: Subset<T, DepenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Depense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepenseAggregateArgs>(args: Subset<T, DepenseAggregateArgs>): Prisma.PrismaPromise<GetDepenseAggregateType<T>>

    /**
     * Group by Depense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepenseGroupByArgs['orderBy'] }
        : { orderBy?: DepenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Depense model
   */
  readonly fields: DepenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Depense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Depense model
   */ 
  interface DepenseFieldRefs {
    readonly id: FieldRef<"Depense", 'String'>
    readonly chantierId: FieldRef<"Depense", 'String'>
    readonly date: FieldRef<"Depense", 'DateTime'>
    readonly montant: FieldRef<"Depense", 'Float'>
    readonly description: FieldRef<"Depense", 'String'>
    readonly categorie: FieldRef<"Depense", 'String'>
    readonly fournisseur: FieldRef<"Depense", 'String'>
    readonly reference: FieldRef<"Depense", 'String'>
    readonly justificatif: FieldRef<"Depense", 'String'>
    readonly createdBy: FieldRef<"Depense", 'String'>
    readonly createdAt: FieldRef<"Depense", 'DateTime'>
    readonly updatedAt: FieldRef<"Depense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Depense findUnique
   */
  export type DepenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * Filter, which Depense to fetch.
     */
    where: DepenseWhereUniqueInput
  }

  /**
   * Depense findUniqueOrThrow
   */
  export type DepenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * Filter, which Depense to fetch.
     */
    where: DepenseWhereUniqueInput
  }

  /**
   * Depense findFirst
   */
  export type DepenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * Filter, which Depense to fetch.
     */
    where?: DepenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depenses to fetch.
     */
    orderBy?: DepenseOrderByWithRelationInput | DepenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depenses.
     */
    cursor?: DepenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depenses.
     */
    distinct?: DepenseScalarFieldEnum | DepenseScalarFieldEnum[]
  }

  /**
   * Depense findFirstOrThrow
   */
  export type DepenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * Filter, which Depense to fetch.
     */
    where?: DepenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depenses to fetch.
     */
    orderBy?: DepenseOrderByWithRelationInput | DepenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Depenses.
     */
    cursor?: DepenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Depenses.
     */
    distinct?: DepenseScalarFieldEnum | DepenseScalarFieldEnum[]
  }

  /**
   * Depense findMany
   */
  export type DepenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * Filter, which Depenses to fetch.
     */
    where?: DepenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Depenses to fetch.
     */
    orderBy?: DepenseOrderByWithRelationInput | DepenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Depenses.
     */
    cursor?: DepenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Depenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Depenses.
     */
    skip?: number
    distinct?: DepenseScalarFieldEnum | DepenseScalarFieldEnum[]
  }

  /**
   * Depense create
   */
  export type DepenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Depense.
     */
    data: XOR<DepenseCreateInput, DepenseUncheckedCreateInput>
  }

  /**
   * Depense createMany
   */
  export type DepenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Depenses.
     */
    data: DepenseCreateManyInput | DepenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Depense update
   */
  export type DepenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Depense.
     */
    data: XOR<DepenseUpdateInput, DepenseUncheckedUpdateInput>
    /**
     * Choose, which Depense to update.
     */
    where: DepenseWhereUniqueInput
  }

  /**
   * Depense updateMany
   */
  export type DepenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Depenses.
     */
    data: XOR<DepenseUpdateManyMutationInput, DepenseUncheckedUpdateManyInput>
    /**
     * Filter which Depenses to update
     */
    where?: DepenseWhereInput
    /**
     * Limit how many Depenses to update.
     */
    limit?: number
  }

  /**
   * Depense upsert
   */
  export type DepenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Depense to update in case it exists.
     */
    where: DepenseWhereUniqueInput
    /**
     * In case the Depense found by the `where` argument doesn't exist, create a new Depense with this data.
     */
    create: XOR<DepenseCreateInput, DepenseUncheckedCreateInput>
    /**
     * In case the Depense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepenseUpdateInput, DepenseUncheckedUpdateInput>
  }

  /**
   * Depense delete
   */
  export type DepenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
    /**
     * Filter which Depense to delete.
     */
    where: DepenseWhereUniqueInput
  }

  /**
   * Depense deleteMany
   */
  export type DepenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Depenses to delete
     */
    where?: DepenseWhereInput
    /**
     * Limit how many Depenses to delete.
     */
    limit?: number
  }

  /**
   * Depense without action
   */
  export type DepenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Depense
     */
    select?: DepenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Depense
     */
    omit?: DepenseOmit<ExtArgs> | null
  }


  /**
   * Model UserNotes
   */

  export type AggregateUserNotes = {
    _count: UserNotesCountAggregateOutputType | null
    _avg: UserNotesAvgAggregateOutputType | null
    _sum: UserNotesSumAggregateOutputType | null
    _min: UserNotesMinAggregateOutputType | null
    _max: UserNotesMaxAggregateOutputType | null
  }

  export type UserNotesAvgAggregateOutputType = {
    id: number | null
  }

  export type UserNotesSumAggregateOutputType = {
    id: number | null
  }

  export type UserNotesMinAggregateOutputType = {
    id: number | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotesMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotesCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserNotesAvgAggregateInputType = {
    id?: true
  }

  export type UserNotesSumAggregateInputType = {
    id?: true
  }

  export type UserNotesMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotesMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotesCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserNotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotes to aggregate.
     */
    where?: UserNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNotesOrderByWithRelationInput | UserNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotes
    **/
    _count?: true | UserNotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotesMaxAggregateInputType
  }

  export type GetUserNotesAggregateType<T extends UserNotesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotes[P]>
      : GetScalarType<T[P], AggregateUserNotes[P]>
  }




  export type UserNotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotesWhereInput
    orderBy?: UserNotesOrderByWithAggregationInput | UserNotesOrderByWithAggregationInput[]
    by: UserNotesScalarFieldEnum[] | UserNotesScalarFieldEnum
    having?: UserNotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotesCountAggregateInputType | true
    _avg?: UserNotesAvgAggregateInputType
    _sum?: UserNotesSumAggregateInputType
    _min?: UserNotesMinAggregateInputType
    _max?: UserNotesMaxAggregateInputType
  }

  export type UserNotesGroupByOutputType = {
    id: number
    userId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: UserNotesCountAggregateOutputType | null
    _avg: UserNotesAvgAggregateOutputType | null
    _sum: UserNotesSumAggregateOutputType | null
    _min: UserNotesMinAggregateOutputType | null
    _max: UserNotesMaxAggregateOutputType | null
  }

  type GetUserNotesGroupByPayload<T extends UserNotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotesGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotesGroupByOutputType[P]>
        }
      >
    >


  export type UserNotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userNotes"]>



  export type UserNotesSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserNotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["userNotes"]>

  export type $UserNotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userNotes"]>
    composites: {}
  }

  type UserNotesGetPayload<S extends boolean | null | undefined | UserNotesDefaultArgs> = $Result.GetResult<Prisma.$UserNotesPayload, S>

  type UserNotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserNotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNotesCountAggregateInputType | true
    }

  export interface UserNotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotes'], meta: { name: 'UserNotes' } }
    /**
     * Find zero or one UserNotes that matches the filter.
     * @param {UserNotesFindUniqueArgs} args - Arguments to find a UserNotes
     * @example
     * // Get one UserNotes
     * const userNotes = await prisma.userNotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotesFindUniqueArgs>(args: SelectSubset<T, UserNotesFindUniqueArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNotesFindUniqueOrThrowArgs} args - Arguments to find a UserNotes
     * @example
     * // Get one UserNotes
     * const userNotes = await prisma.userNotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesFindFirstArgs} args - Arguments to find a UserNotes
     * @example
     * // Get one UserNotes
     * const userNotes = await prisma.userNotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotesFindFirstArgs>(args?: SelectSubset<T, UserNotesFindFirstArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesFindFirstOrThrowArgs} args - Arguments to find a UserNotes
     * @example
     * // Get one UserNotes
     * const userNotes = await prisma.userNotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotes
     * const userNotes = await prisma.userNotes.findMany()
     * 
     * // Get first 10 UserNotes
     * const userNotes = await prisma.userNotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotesWithIdOnly = await prisma.userNotes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotesFindManyArgs>(args?: SelectSubset<T, UserNotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNotes.
     * @param {UserNotesCreateArgs} args - Arguments to create a UserNotes.
     * @example
     * // Create one UserNotes
     * const UserNotes = await prisma.userNotes.create({
     *   data: {
     *     // ... data to create a UserNotes
     *   }
     * })
     * 
     */
    create<T extends UserNotesCreateArgs>(args: SelectSubset<T, UserNotesCreateArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNotes.
     * @param {UserNotesCreateManyArgs} args - Arguments to create many UserNotes.
     * @example
     * // Create many UserNotes
     * const userNotes = await prisma.userNotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotesCreateManyArgs>(args?: SelectSubset<T, UserNotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserNotes.
     * @param {UserNotesDeleteArgs} args - Arguments to delete one UserNotes.
     * @example
     * // Delete one UserNotes
     * const UserNotes = await prisma.userNotes.delete({
     *   where: {
     *     // ... filter to delete one UserNotes
     *   }
     * })
     * 
     */
    delete<T extends UserNotesDeleteArgs>(args: SelectSubset<T, UserNotesDeleteArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNotes.
     * @param {UserNotesUpdateArgs} args - Arguments to update one UserNotes.
     * @example
     * // Update one UserNotes
     * const userNotes = await prisma.userNotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotesUpdateArgs>(args: SelectSubset<T, UserNotesUpdateArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNotes.
     * @param {UserNotesDeleteManyArgs} args - Arguments to filter UserNotes to delete.
     * @example
     * // Delete a few UserNotes
     * const { count } = await prisma.userNotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotesDeleteManyArgs>(args?: SelectSubset<T, UserNotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotes
     * const userNotes = await prisma.userNotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotesUpdateManyArgs>(args: SelectSubset<T, UserNotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotes.
     * @param {UserNotesUpsertArgs} args - Arguments to update or create a UserNotes.
     * @example
     * // Update or create a UserNotes
     * const userNotes = await prisma.userNotes.upsert({
     *   create: {
     *     // ... data to create a UserNotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotes we want to update
     *   }
     * })
     */
    upsert<T extends UserNotesUpsertArgs>(args: SelectSubset<T, UserNotesUpsertArgs<ExtArgs>>): Prisma__UserNotesClient<$Result.GetResult<Prisma.$UserNotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesCountArgs} args - Arguments to filter UserNotes to count.
     * @example
     * // Count the number of UserNotes
     * const count = await prisma.userNotes.count({
     *   where: {
     *     // ... the filter for the UserNotes we want to count
     *   }
     * })
    **/
    count<T extends UserNotesCountArgs>(
      args?: Subset<T, UserNotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotesAggregateArgs>(args: Subset<T, UserNotesAggregateArgs>): Prisma.PrismaPromise<GetUserNotesAggregateType<T>>

    /**
     * Group by UserNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotesGroupByArgs['orderBy'] }
        : { orderBy?: UserNotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotes model
   */
  readonly fields: UserNotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotes model
   */ 
  interface UserNotesFieldRefs {
    readonly id: FieldRef<"UserNotes", 'Int'>
    readonly userId: FieldRef<"UserNotes", 'String'>
    readonly content: FieldRef<"UserNotes", 'String'>
    readonly createdAt: FieldRef<"UserNotes", 'DateTime'>
    readonly updatedAt: FieldRef<"UserNotes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNotes findUnique
   */
  export type UserNotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * Filter, which UserNotes to fetch.
     */
    where: UserNotesWhereUniqueInput
  }

  /**
   * UserNotes findUniqueOrThrow
   */
  export type UserNotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * Filter, which UserNotes to fetch.
     */
    where: UserNotesWhereUniqueInput
  }

  /**
   * UserNotes findFirst
   */
  export type UserNotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * Filter, which UserNotes to fetch.
     */
    where?: UserNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNotesOrderByWithRelationInput | UserNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotes.
     */
    cursor?: UserNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotes.
     */
    distinct?: UserNotesScalarFieldEnum | UserNotesScalarFieldEnum[]
  }

  /**
   * UserNotes findFirstOrThrow
   */
  export type UserNotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * Filter, which UserNotes to fetch.
     */
    where?: UserNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNotesOrderByWithRelationInput | UserNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotes.
     */
    cursor?: UserNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotes.
     */
    distinct?: UserNotesScalarFieldEnum | UserNotesScalarFieldEnum[]
  }

  /**
   * UserNotes findMany
   */
  export type UserNotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * Filter, which UserNotes to fetch.
     */
    where?: UserNotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNotesOrderByWithRelationInput | UserNotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotes.
     */
    cursor?: UserNotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    distinct?: UserNotesScalarFieldEnum | UserNotesScalarFieldEnum[]
  }

  /**
   * UserNotes create
   */
  export type UserNotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * The data needed to create a UserNotes.
     */
    data: XOR<UserNotesCreateInput, UserNotesUncheckedCreateInput>
  }

  /**
   * UserNotes createMany
   */
  export type UserNotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotes.
     */
    data: UserNotesCreateManyInput | UserNotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotes update
   */
  export type UserNotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * The data needed to update a UserNotes.
     */
    data: XOR<UserNotesUpdateInput, UserNotesUncheckedUpdateInput>
    /**
     * Choose, which UserNotes to update.
     */
    where: UserNotesWhereUniqueInput
  }

  /**
   * UserNotes updateMany
   */
  export type UserNotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotes.
     */
    data: XOR<UserNotesUpdateManyMutationInput, UserNotesUncheckedUpdateManyInput>
    /**
     * Filter which UserNotes to update
     */
    where?: UserNotesWhereInput
    /**
     * Limit how many UserNotes to update.
     */
    limit?: number
  }

  /**
   * UserNotes upsert
   */
  export type UserNotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * The filter to search for the UserNotes to update in case it exists.
     */
    where: UserNotesWhereUniqueInput
    /**
     * In case the UserNotes found by the `where` argument doesn't exist, create a new UserNotes with this data.
     */
    create: XOR<UserNotesCreateInput, UserNotesUncheckedCreateInput>
    /**
     * In case the UserNotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotesUpdateInput, UserNotesUncheckedUpdateInput>
  }

  /**
   * UserNotes delete
   */
  export type UserNotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
    /**
     * Filter which UserNotes to delete.
     */
    where: UserNotesWhereUniqueInput
  }

  /**
   * UserNotes deleteMany
   */
  export type UserNotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotes to delete
     */
    where?: UserNotesWhereInput
    /**
     * Limit how many UserNotes to delete.
     */
    limit?: number
  }

  /**
   * UserNotes without action
   */
  export type UserNotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotes
     */
    select?: UserNotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotes
     */
    omit?: UserNotesOmit<ExtArgs> | null
  }


  /**
   * Model Rack
   */

  export type AggregateRack = {
    _count: RackCountAggregateOutputType | null
    _avg: RackAvgAggregateOutputType | null
    _sum: RackSumAggregateOutputType | null
    _min: RackMinAggregateOutputType | null
    _max: RackMaxAggregateOutputType | null
  }

  export type RackAvgAggregateOutputType = {
    lignes: number | null
    colonnes: number | null
  }

  export type RackSumAggregateOutputType = {
    lignes: number | null
    colonnes: number | null
  }

  export type RackMinAggregateOutputType = {
    id: string | null
    nom: string | null
    position: string | null
    lignes: number | null
    colonnes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RackMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    position: string | null
    lignes: number | null
    colonnes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RackCountAggregateOutputType = {
    id: number
    nom: number
    position: number
    lignes: number
    colonnes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RackAvgAggregateInputType = {
    lignes?: true
    colonnes?: true
  }

  export type RackSumAggregateInputType = {
    lignes?: true
    colonnes?: true
  }

  export type RackMinAggregateInputType = {
    id?: true
    nom?: true
    position?: true
    lignes?: true
    colonnes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RackMaxAggregateInputType = {
    id?: true
    nom?: true
    position?: true
    lignes?: true
    colonnes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RackCountAggregateInputType = {
    id?: true
    nom?: true
    position?: true
    lignes?: true
    colonnes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rack to aggregate.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Racks
    **/
    _count?: true | RackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RackMaxAggregateInputType
  }

  export type GetRackAggregateType<T extends RackAggregateArgs> = {
        [P in keyof T & keyof AggregateRack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRack[P]>
      : GetScalarType<T[P], AggregateRack[P]>
  }




  export type RackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RackWhereInput
    orderBy?: RackOrderByWithAggregationInput | RackOrderByWithAggregationInput[]
    by: RackScalarFieldEnum[] | RackScalarFieldEnum
    having?: RackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RackCountAggregateInputType | true
    _avg?: RackAvgAggregateInputType
    _sum?: RackSumAggregateInputType
    _min?: RackMinAggregateInputType
    _max?: RackMaxAggregateInputType
  }

  export type RackGroupByOutputType = {
    id: string
    nom: string
    position: string
    lignes: number
    colonnes: number
    createdAt: Date
    updatedAt: Date
    _count: RackCountAggregateOutputType | null
    _avg: RackAvgAggregateOutputType | null
    _sum: RackSumAggregateOutputType | null
    _min: RackMinAggregateOutputType | null
    _max: RackMaxAggregateOutputType | null
  }

  type GetRackGroupByPayload<T extends RackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RackGroupByOutputType[P]>
            : GetScalarType<T[P], RackGroupByOutputType[P]>
        }
      >
    >


  export type RackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    position?: boolean
    lignes?: boolean
    colonnes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emplacements?: boolean | Rack$emplacementsArgs<ExtArgs>
    _count?: boolean | RackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rack"]>



  export type RackSelectScalar = {
    id?: boolean
    nom?: boolean
    position?: boolean
    lignes?: boolean
    colonnes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "position" | "lignes" | "colonnes" | "createdAt" | "updatedAt", ExtArgs["result"]["rack"]>
  export type RackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emplacements?: boolean | Rack$emplacementsArgs<ExtArgs>
    _count?: boolean | RackCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rack"
    objects: {
      emplacements: Prisma.$EmplacementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      position: string
      lignes: number
      colonnes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rack"]>
    composites: {}
  }

  type RackGetPayload<S extends boolean | null | undefined | RackDefaultArgs> = $Result.GetResult<Prisma.$RackPayload, S>

  type RackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RackCountAggregateInputType | true
    }

  export interface RackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rack'], meta: { name: 'Rack' } }
    /**
     * Find zero or one Rack that matches the filter.
     * @param {RackFindUniqueArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RackFindUniqueArgs>(args: SelectSubset<T, RackFindUniqueArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RackFindUniqueOrThrowArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RackFindUniqueOrThrowArgs>(args: SelectSubset<T, RackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackFindFirstArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RackFindFirstArgs>(args?: SelectSubset<T, RackFindFirstArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackFindFirstOrThrowArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RackFindFirstOrThrowArgs>(args?: SelectSubset<T, RackFindFirstOrThrowArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Racks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Racks
     * const racks = await prisma.rack.findMany()
     * 
     * // Get first 10 Racks
     * const racks = await prisma.rack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rackWithIdOnly = await prisma.rack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RackFindManyArgs>(args?: SelectSubset<T, RackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rack.
     * @param {RackCreateArgs} args - Arguments to create a Rack.
     * @example
     * // Create one Rack
     * const Rack = await prisma.rack.create({
     *   data: {
     *     // ... data to create a Rack
     *   }
     * })
     * 
     */
    create<T extends RackCreateArgs>(args: SelectSubset<T, RackCreateArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Racks.
     * @param {RackCreateManyArgs} args - Arguments to create many Racks.
     * @example
     * // Create many Racks
     * const rack = await prisma.rack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RackCreateManyArgs>(args?: SelectSubset<T, RackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rack.
     * @param {RackDeleteArgs} args - Arguments to delete one Rack.
     * @example
     * // Delete one Rack
     * const Rack = await prisma.rack.delete({
     *   where: {
     *     // ... filter to delete one Rack
     *   }
     * })
     * 
     */
    delete<T extends RackDeleteArgs>(args: SelectSubset<T, RackDeleteArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rack.
     * @param {RackUpdateArgs} args - Arguments to update one Rack.
     * @example
     * // Update one Rack
     * const rack = await prisma.rack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RackUpdateArgs>(args: SelectSubset<T, RackUpdateArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Racks.
     * @param {RackDeleteManyArgs} args - Arguments to filter Racks to delete.
     * @example
     * // Delete a few Racks
     * const { count } = await prisma.rack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RackDeleteManyArgs>(args?: SelectSubset<T, RackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Racks
     * const rack = await prisma.rack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RackUpdateManyArgs>(args: SelectSubset<T, RackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rack.
     * @param {RackUpsertArgs} args - Arguments to update or create a Rack.
     * @example
     * // Update or create a Rack
     * const rack = await prisma.rack.upsert({
     *   create: {
     *     // ... data to create a Rack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rack we want to update
     *   }
     * })
     */
    upsert<T extends RackUpsertArgs>(args: SelectSubset<T, RackUpsertArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackCountArgs} args - Arguments to filter Racks to count.
     * @example
     * // Count the number of Racks
     * const count = await prisma.rack.count({
     *   where: {
     *     // ... the filter for the Racks we want to count
     *   }
     * })
    **/
    count<T extends RackCountArgs>(
      args?: Subset<T, RackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RackAggregateArgs>(args: Subset<T, RackAggregateArgs>): Prisma.PrismaPromise<GetRackAggregateType<T>>

    /**
     * Group by Rack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RackGroupByArgs['orderBy'] }
        : { orderBy?: RackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rack model
   */
  readonly fields: RackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emplacements<T extends Rack$emplacementsArgs<ExtArgs> = {}>(args?: Subset<T, Rack$emplacementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rack model
   */ 
  interface RackFieldRefs {
    readonly id: FieldRef<"Rack", 'String'>
    readonly nom: FieldRef<"Rack", 'String'>
    readonly position: FieldRef<"Rack", 'String'>
    readonly lignes: FieldRef<"Rack", 'Int'>
    readonly colonnes: FieldRef<"Rack", 'Int'>
    readonly createdAt: FieldRef<"Rack", 'DateTime'>
    readonly updatedAt: FieldRef<"Rack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rack findUnique
   */
  export type RackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack findUniqueOrThrow
   */
  export type RackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack findFirst
   */
  export type RackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Racks.
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Racks.
     */
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Rack findFirstOrThrow
   */
  export type RackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Racks.
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Racks.
     */
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Rack findMany
   */
  export type RackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Racks to fetch.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Racks.
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Rack create
   */
  export type RackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * The data needed to create a Rack.
     */
    data: XOR<RackCreateInput, RackUncheckedCreateInput>
  }

  /**
   * Rack createMany
   */
  export type RackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Racks.
     */
    data: RackCreateManyInput | RackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rack update
   */
  export type RackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * The data needed to update a Rack.
     */
    data: XOR<RackUpdateInput, RackUncheckedUpdateInput>
    /**
     * Choose, which Rack to update.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack updateMany
   */
  export type RackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Racks.
     */
    data: XOR<RackUpdateManyMutationInput, RackUncheckedUpdateManyInput>
    /**
     * Filter which Racks to update
     */
    where?: RackWhereInput
    /**
     * Limit how many Racks to update.
     */
    limit?: number
  }

  /**
   * Rack upsert
   */
  export type RackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * The filter to search for the Rack to update in case it exists.
     */
    where: RackWhereUniqueInput
    /**
     * In case the Rack found by the `where` argument doesn't exist, create a new Rack with this data.
     */
    create: XOR<RackCreateInput, RackUncheckedCreateInput>
    /**
     * In case the Rack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RackUpdateInput, RackUncheckedUpdateInput>
  }

  /**
   * Rack delete
   */
  export type RackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter which Rack to delete.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack deleteMany
   */
  export type RackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Racks to delete
     */
    where?: RackWhereInput
    /**
     * Limit how many Racks to delete.
     */
    limit?: number
  }

  /**
   * Rack.emplacements
   */
  export type Rack$emplacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    where?: EmplacementWhereInput
    orderBy?: EmplacementOrderByWithRelationInput | EmplacementOrderByWithRelationInput[]
    cursor?: EmplacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmplacementScalarFieldEnum | EmplacementScalarFieldEnum[]
  }

  /**
   * Rack without action
   */
  export type RackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
  }


  /**
   * Model Emplacement
   */

  export type AggregateEmplacement = {
    _count: EmplacementCountAggregateOutputType | null
    _avg: EmplacementAvgAggregateOutputType | null
    _sum: EmplacementSumAggregateOutputType | null
    _min: EmplacementMinAggregateOutputType | null
    _max: EmplacementMaxAggregateOutputType | null
  }

  export type EmplacementAvgAggregateOutputType = {
    ligne: number | null
    colonne: number | null
  }

  export type EmplacementSumAggregateOutputType = {
    ligne: number | null
    colonne: number | null
  }

  export type EmplacementMinAggregateOutputType = {
    id: string | null
    rackId: string | null
    ligne: number | null
    colonne: number | null
    codeQR: string | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmplacementMaxAggregateOutputType = {
    id: string | null
    rackId: string | null
    ligne: number | null
    colonne: number | null
    codeQR: string | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmplacementCountAggregateOutputType = {
    id: number
    rackId: number
    ligne: number
    colonne: number
    codeQR: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmplacementAvgAggregateInputType = {
    ligne?: true
    colonne?: true
  }

  export type EmplacementSumAggregateInputType = {
    ligne?: true
    colonne?: true
  }

  export type EmplacementMinAggregateInputType = {
    id?: true
    rackId?: true
    ligne?: true
    colonne?: true
    codeQR?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmplacementMaxAggregateInputType = {
    id?: true
    rackId?: true
    ligne?: true
    colonne?: true
    codeQR?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmplacementCountAggregateInputType = {
    id?: true
    rackId?: true
    ligne?: true
    colonne?: true
    codeQR?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmplacementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emplacement to aggregate.
     */
    where?: EmplacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emplacements to fetch.
     */
    orderBy?: EmplacementOrderByWithRelationInput | EmplacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmplacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emplacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emplacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emplacements
    **/
    _count?: true | EmplacementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmplacementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmplacementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmplacementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmplacementMaxAggregateInputType
  }

  export type GetEmplacementAggregateType<T extends EmplacementAggregateArgs> = {
        [P in keyof T & keyof AggregateEmplacement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmplacement[P]>
      : GetScalarType<T[P], AggregateEmplacement[P]>
  }




  export type EmplacementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmplacementWhereInput
    orderBy?: EmplacementOrderByWithAggregationInput | EmplacementOrderByWithAggregationInput[]
    by: EmplacementScalarFieldEnum[] | EmplacementScalarFieldEnum
    having?: EmplacementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmplacementCountAggregateInputType | true
    _avg?: EmplacementAvgAggregateInputType
    _sum?: EmplacementSumAggregateInputType
    _min?: EmplacementMinAggregateInputType
    _max?: EmplacementMaxAggregateInputType
  }

  export type EmplacementGroupByOutputType = {
    id: string
    rackId: string
    ligne: number
    colonne: number
    codeQR: string
    statut: string
    createdAt: Date
    updatedAt: Date
    _count: EmplacementCountAggregateOutputType | null
    _avg: EmplacementAvgAggregateOutputType | null
    _sum: EmplacementSumAggregateOutputType | null
    _min: EmplacementMinAggregateOutputType | null
    _max: EmplacementMaxAggregateOutputType | null
  }

  type GetEmplacementGroupByPayload<T extends EmplacementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmplacementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmplacementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmplacementGroupByOutputType[P]>
            : GetScalarType<T[P], EmplacementGroupByOutputType[P]>
        }
      >
    >


  export type EmplacementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rackId?: boolean
    ligne?: boolean
    colonne?: boolean
    codeQR?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rack?: boolean | RackDefaultArgs<ExtArgs>
    materiaux?: boolean | Emplacement$materiauxArgs<ExtArgs>
    _count?: boolean | EmplacementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emplacement"]>



  export type EmplacementSelectScalar = {
    id?: boolean
    rackId?: boolean
    ligne?: boolean
    colonne?: boolean
    codeQR?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmplacementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rackId" | "ligne" | "colonne" | "codeQR" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["emplacement"]>
  export type EmplacementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rack?: boolean | RackDefaultArgs<ExtArgs>
    materiaux?: boolean | Emplacement$materiauxArgs<ExtArgs>
    _count?: boolean | EmplacementCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmplacementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emplacement"
    objects: {
      rack: Prisma.$RackPayload<ExtArgs>
      materiaux: Prisma.$MateriauPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rackId: string
      ligne: number
      colonne: number
      codeQR: string
      statut: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emplacement"]>
    composites: {}
  }

  type EmplacementGetPayload<S extends boolean | null | undefined | EmplacementDefaultArgs> = $Result.GetResult<Prisma.$EmplacementPayload, S>

  type EmplacementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmplacementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmplacementCountAggregateInputType | true
    }

  export interface EmplacementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emplacement'], meta: { name: 'Emplacement' } }
    /**
     * Find zero or one Emplacement that matches the filter.
     * @param {EmplacementFindUniqueArgs} args - Arguments to find a Emplacement
     * @example
     * // Get one Emplacement
     * const emplacement = await prisma.emplacement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmplacementFindUniqueArgs>(args: SelectSubset<T, EmplacementFindUniqueArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emplacement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmplacementFindUniqueOrThrowArgs} args - Arguments to find a Emplacement
     * @example
     * // Get one Emplacement
     * const emplacement = await prisma.emplacement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmplacementFindUniqueOrThrowArgs>(args: SelectSubset<T, EmplacementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emplacement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementFindFirstArgs} args - Arguments to find a Emplacement
     * @example
     * // Get one Emplacement
     * const emplacement = await prisma.emplacement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmplacementFindFirstArgs>(args?: SelectSubset<T, EmplacementFindFirstArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emplacement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementFindFirstOrThrowArgs} args - Arguments to find a Emplacement
     * @example
     * // Get one Emplacement
     * const emplacement = await prisma.emplacement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmplacementFindFirstOrThrowArgs>(args?: SelectSubset<T, EmplacementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emplacements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emplacements
     * const emplacements = await prisma.emplacement.findMany()
     * 
     * // Get first 10 Emplacements
     * const emplacements = await prisma.emplacement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emplacementWithIdOnly = await prisma.emplacement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmplacementFindManyArgs>(args?: SelectSubset<T, EmplacementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emplacement.
     * @param {EmplacementCreateArgs} args - Arguments to create a Emplacement.
     * @example
     * // Create one Emplacement
     * const Emplacement = await prisma.emplacement.create({
     *   data: {
     *     // ... data to create a Emplacement
     *   }
     * })
     * 
     */
    create<T extends EmplacementCreateArgs>(args: SelectSubset<T, EmplacementCreateArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emplacements.
     * @param {EmplacementCreateManyArgs} args - Arguments to create many Emplacements.
     * @example
     * // Create many Emplacements
     * const emplacement = await prisma.emplacement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmplacementCreateManyArgs>(args?: SelectSubset<T, EmplacementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emplacement.
     * @param {EmplacementDeleteArgs} args - Arguments to delete one Emplacement.
     * @example
     * // Delete one Emplacement
     * const Emplacement = await prisma.emplacement.delete({
     *   where: {
     *     // ... filter to delete one Emplacement
     *   }
     * })
     * 
     */
    delete<T extends EmplacementDeleteArgs>(args: SelectSubset<T, EmplacementDeleteArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emplacement.
     * @param {EmplacementUpdateArgs} args - Arguments to update one Emplacement.
     * @example
     * // Update one Emplacement
     * const emplacement = await prisma.emplacement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmplacementUpdateArgs>(args: SelectSubset<T, EmplacementUpdateArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emplacements.
     * @param {EmplacementDeleteManyArgs} args - Arguments to filter Emplacements to delete.
     * @example
     * // Delete a few Emplacements
     * const { count } = await prisma.emplacement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmplacementDeleteManyArgs>(args?: SelectSubset<T, EmplacementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emplacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emplacements
     * const emplacement = await prisma.emplacement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmplacementUpdateManyArgs>(args: SelectSubset<T, EmplacementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emplacement.
     * @param {EmplacementUpsertArgs} args - Arguments to update or create a Emplacement.
     * @example
     * // Update or create a Emplacement
     * const emplacement = await prisma.emplacement.upsert({
     *   create: {
     *     // ... data to create a Emplacement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emplacement we want to update
     *   }
     * })
     */
    upsert<T extends EmplacementUpsertArgs>(args: SelectSubset<T, EmplacementUpsertArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emplacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementCountArgs} args - Arguments to filter Emplacements to count.
     * @example
     * // Count the number of Emplacements
     * const count = await prisma.emplacement.count({
     *   where: {
     *     // ... the filter for the Emplacements we want to count
     *   }
     * })
    **/
    count<T extends EmplacementCountArgs>(
      args?: Subset<T, EmplacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmplacementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emplacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmplacementAggregateArgs>(args: Subset<T, EmplacementAggregateArgs>): Prisma.PrismaPromise<GetEmplacementAggregateType<T>>

    /**
     * Group by Emplacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmplacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmplacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmplacementGroupByArgs['orderBy'] }
        : { orderBy?: EmplacementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmplacementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmplacementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emplacement model
   */
  readonly fields: EmplacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emplacement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmplacementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rack<T extends RackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RackDefaultArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materiaux<T extends Emplacement$materiauxArgs<ExtArgs> = {}>(args?: Subset<T, Emplacement$materiauxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emplacement model
   */ 
  interface EmplacementFieldRefs {
    readonly id: FieldRef<"Emplacement", 'String'>
    readonly rackId: FieldRef<"Emplacement", 'String'>
    readonly ligne: FieldRef<"Emplacement", 'Int'>
    readonly colonne: FieldRef<"Emplacement", 'Int'>
    readonly codeQR: FieldRef<"Emplacement", 'String'>
    readonly statut: FieldRef<"Emplacement", 'String'>
    readonly createdAt: FieldRef<"Emplacement", 'DateTime'>
    readonly updatedAt: FieldRef<"Emplacement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Emplacement findUnique
   */
  export type EmplacementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * Filter, which Emplacement to fetch.
     */
    where: EmplacementWhereUniqueInput
  }

  /**
   * Emplacement findUniqueOrThrow
   */
  export type EmplacementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * Filter, which Emplacement to fetch.
     */
    where: EmplacementWhereUniqueInput
  }

  /**
   * Emplacement findFirst
   */
  export type EmplacementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * Filter, which Emplacement to fetch.
     */
    where?: EmplacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emplacements to fetch.
     */
    orderBy?: EmplacementOrderByWithRelationInput | EmplacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emplacements.
     */
    cursor?: EmplacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emplacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emplacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emplacements.
     */
    distinct?: EmplacementScalarFieldEnum | EmplacementScalarFieldEnum[]
  }

  /**
   * Emplacement findFirstOrThrow
   */
  export type EmplacementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * Filter, which Emplacement to fetch.
     */
    where?: EmplacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emplacements to fetch.
     */
    orderBy?: EmplacementOrderByWithRelationInput | EmplacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emplacements.
     */
    cursor?: EmplacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emplacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emplacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emplacements.
     */
    distinct?: EmplacementScalarFieldEnum | EmplacementScalarFieldEnum[]
  }

  /**
   * Emplacement findMany
   */
  export type EmplacementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * Filter, which Emplacements to fetch.
     */
    where?: EmplacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emplacements to fetch.
     */
    orderBy?: EmplacementOrderByWithRelationInput | EmplacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emplacements.
     */
    cursor?: EmplacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emplacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emplacements.
     */
    skip?: number
    distinct?: EmplacementScalarFieldEnum | EmplacementScalarFieldEnum[]
  }

  /**
   * Emplacement create
   */
  export type EmplacementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * The data needed to create a Emplacement.
     */
    data: XOR<EmplacementCreateInput, EmplacementUncheckedCreateInput>
  }

  /**
   * Emplacement createMany
   */
  export type EmplacementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emplacements.
     */
    data: EmplacementCreateManyInput | EmplacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emplacement update
   */
  export type EmplacementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * The data needed to update a Emplacement.
     */
    data: XOR<EmplacementUpdateInput, EmplacementUncheckedUpdateInput>
    /**
     * Choose, which Emplacement to update.
     */
    where: EmplacementWhereUniqueInput
  }

  /**
   * Emplacement updateMany
   */
  export type EmplacementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emplacements.
     */
    data: XOR<EmplacementUpdateManyMutationInput, EmplacementUncheckedUpdateManyInput>
    /**
     * Filter which Emplacements to update
     */
    where?: EmplacementWhereInput
    /**
     * Limit how many Emplacements to update.
     */
    limit?: number
  }

  /**
   * Emplacement upsert
   */
  export type EmplacementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * The filter to search for the Emplacement to update in case it exists.
     */
    where: EmplacementWhereUniqueInput
    /**
     * In case the Emplacement found by the `where` argument doesn't exist, create a new Emplacement with this data.
     */
    create: XOR<EmplacementCreateInput, EmplacementUncheckedCreateInput>
    /**
     * In case the Emplacement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmplacementUpdateInput, EmplacementUncheckedUpdateInput>
  }

  /**
   * Emplacement delete
   */
  export type EmplacementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    /**
     * Filter which Emplacement to delete.
     */
    where: EmplacementWhereUniqueInput
  }

  /**
   * Emplacement deleteMany
   */
  export type EmplacementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emplacements to delete
     */
    where?: EmplacementWhereInput
    /**
     * Limit how many Emplacements to delete.
     */
    limit?: number
  }

  /**
   * Emplacement.materiaux
   */
  export type Emplacement$materiauxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    where?: MateriauWhereInput
    orderBy?: MateriauOrderByWithRelationInput | MateriauOrderByWithRelationInput[]
    cursor?: MateriauWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MateriauScalarFieldEnum | MateriauScalarFieldEnum[]
  }

  /**
   * Emplacement without action
   */
  export type EmplacementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
  }


  /**
   * Model Materiau
   */

  export type AggregateMateriau = {
    _count: MateriauCountAggregateOutputType | null
    _avg: MateriauAvgAggregateOutputType | null
    _sum: MateriauSumAggregateOutputType | null
    _min: MateriauMinAggregateOutputType | null
    _max: MateriauMaxAggregateOutputType | null
  }

  export type MateriauAvgAggregateOutputType = {
    quantite: number | null
  }

  export type MateriauSumAggregateOutputType = {
    quantite: number | null
  }

  export type MateriauMinAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    quantite: number | null
    codeQR: string | null
    emplacementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MateriauMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    quantite: number | null
    codeQR: string | null
    emplacementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MateriauCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    quantite: number
    codeQR: number
    emplacementId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MateriauAvgAggregateInputType = {
    quantite?: true
  }

  export type MateriauSumAggregateInputType = {
    quantite?: true
  }

  export type MateriauMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    quantite?: true
    codeQR?: true
    emplacementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MateriauMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    quantite?: true
    codeQR?: true
    emplacementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MateriauCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    quantite?: true
    codeQR?: true
    emplacementId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MateriauAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materiau to aggregate.
     */
    where?: MateriauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiaus to fetch.
     */
    orderBy?: MateriauOrderByWithRelationInput | MateriauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MateriauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materiaus
    **/
    _count?: true | MateriauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MateriauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MateriauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MateriauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MateriauMaxAggregateInputType
  }

  export type GetMateriauAggregateType<T extends MateriauAggregateArgs> = {
        [P in keyof T & keyof AggregateMateriau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateriau[P]>
      : GetScalarType<T[P], AggregateMateriau[P]>
  }




  export type MateriauGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriauWhereInput
    orderBy?: MateriauOrderByWithAggregationInput | MateriauOrderByWithAggregationInput[]
    by: MateriauScalarFieldEnum[] | MateriauScalarFieldEnum
    having?: MateriauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MateriauCountAggregateInputType | true
    _avg?: MateriauAvgAggregateInputType
    _sum?: MateriauSumAggregateInputType
    _min?: MateriauMinAggregateInputType
    _max?: MateriauMaxAggregateInputType
  }

  export type MateriauGroupByOutputType = {
    id: string
    nom: string
    description: string | null
    quantite: number
    codeQR: string | null
    emplacementId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MateriauCountAggregateOutputType | null
    _avg: MateriauAvgAggregateOutputType | null
    _sum: MateriauSumAggregateOutputType | null
    _min: MateriauMinAggregateOutputType | null
    _max: MateriauMaxAggregateOutputType | null
  }

  type GetMateriauGroupByPayload<T extends MateriauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MateriauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MateriauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MateriauGroupByOutputType[P]>
            : GetScalarType<T[P], MateriauGroupByOutputType[P]>
        }
      >
    >


  export type MateriauSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    quantite?: boolean
    codeQR?: boolean
    emplacementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emplacement?: boolean | Materiau$emplacementArgs<ExtArgs>
  }, ExtArgs["result"]["materiau"]>



  export type MateriauSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    quantite?: boolean
    codeQR?: boolean
    emplacementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MateriauOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "quantite" | "codeQR" | "emplacementId" | "createdAt" | "updatedAt", ExtArgs["result"]["materiau"]>
  export type MateriauInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emplacement?: boolean | Materiau$emplacementArgs<ExtArgs>
  }

  export type $MateriauPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materiau"
    objects: {
      emplacement: Prisma.$EmplacementPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      description: string | null
      quantite: number
      codeQR: string | null
      emplacementId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materiau"]>
    composites: {}
  }

  type MateriauGetPayload<S extends boolean | null | undefined | MateriauDefaultArgs> = $Result.GetResult<Prisma.$MateriauPayload, S>

  type MateriauCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MateriauFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MateriauCountAggregateInputType | true
    }

  export interface MateriauDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materiau'], meta: { name: 'Materiau' } }
    /**
     * Find zero or one Materiau that matches the filter.
     * @param {MateriauFindUniqueArgs} args - Arguments to find a Materiau
     * @example
     * // Get one Materiau
     * const materiau = await prisma.materiau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MateriauFindUniqueArgs>(args: SelectSubset<T, MateriauFindUniqueArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materiau that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MateriauFindUniqueOrThrowArgs} args - Arguments to find a Materiau
     * @example
     * // Get one Materiau
     * const materiau = await prisma.materiau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MateriauFindUniqueOrThrowArgs>(args: SelectSubset<T, MateriauFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materiau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauFindFirstArgs} args - Arguments to find a Materiau
     * @example
     * // Get one Materiau
     * const materiau = await prisma.materiau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MateriauFindFirstArgs>(args?: SelectSubset<T, MateriauFindFirstArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materiau that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauFindFirstOrThrowArgs} args - Arguments to find a Materiau
     * @example
     * // Get one Materiau
     * const materiau = await prisma.materiau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MateriauFindFirstOrThrowArgs>(args?: SelectSubset<T, MateriauFindFirstOrThrowArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materiaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materiaus
     * const materiaus = await prisma.materiau.findMany()
     * 
     * // Get first 10 Materiaus
     * const materiaus = await prisma.materiau.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materiauWithIdOnly = await prisma.materiau.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MateriauFindManyArgs>(args?: SelectSubset<T, MateriauFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materiau.
     * @param {MateriauCreateArgs} args - Arguments to create a Materiau.
     * @example
     * // Create one Materiau
     * const Materiau = await prisma.materiau.create({
     *   data: {
     *     // ... data to create a Materiau
     *   }
     * })
     * 
     */
    create<T extends MateriauCreateArgs>(args: SelectSubset<T, MateriauCreateArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materiaus.
     * @param {MateriauCreateManyArgs} args - Arguments to create many Materiaus.
     * @example
     * // Create many Materiaus
     * const materiau = await prisma.materiau.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MateriauCreateManyArgs>(args?: SelectSubset<T, MateriauCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materiau.
     * @param {MateriauDeleteArgs} args - Arguments to delete one Materiau.
     * @example
     * // Delete one Materiau
     * const Materiau = await prisma.materiau.delete({
     *   where: {
     *     // ... filter to delete one Materiau
     *   }
     * })
     * 
     */
    delete<T extends MateriauDeleteArgs>(args: SelectSubset<T, MateriauDeleteArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materiau.
     * @param {MateriauUpdateArgs} args - Arguments to update one Materiau.
     * @example
     * // Update one Materiau
     * const materiau = await prisma.materiau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MateriauUpdateArgs>(args: SelectSubset<T, MateriauUpdateArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materiaus.
     * @param {MateriauDeleteManyArgs} args - Arguments to filter Materiaus to delete.
     * @example
     * // Delete a few Materiaus
     * const { count } = await prisma.materiau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MateriauDeleteManyArgs>(args?: SelectSubset<T, MateriauDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materiaus
     * const materiau = await prisma.materiau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MateriauUpdateManyArgs>(args: SelectSubset<T, MateriauUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materiau.
     * @param {MateriauUpsertArgs} args - Arguments to update or create a Materiau.
     * @example
     * // Update or create a Materiau
     * const materiau = await prisma.materiau.upsert({
     *   create: {
     *     // ... data to create a Materiau
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materiau we want to update
     *   }
     * })
     */
    upsert<T extends MateriauUpsertArgs>(args: SelectSubset<T, MateriauUpsertArgs<ExtArgs>>): Prisma__MateriauClient<$Result.GetResult<Prisma.$MateriauPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materiaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauCountArgs} args - Arguments to filter Materiaus to count.
     * @example
     * // Count the number of Materiaus
     * const count = await prisma.materiau.count({
     *   where: {
     *     // ... the filter for the Materiaus we want to count
     *   }
     * })
    **/
    count<T extends MateriauCountArgs>(
      args?: Subset<T, MateriauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MateriauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materiau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MateriauAggregateArgs>(args: Subset<T, MateriauAggregateArgs>): Prisma.PrismaPromise<GetMateriauAggregateType<T>>

    /**
     * Group by Materiau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MateriauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MateriauGroupByArgs['orderBy'] }
        : { orderBy?: MateriauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MateriauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateriauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materiau model
   */
  readonly fields: MateriauFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materiau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MateriauClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emplacement<T extends Materiau$emplacementArgs<ExtArgs> = {}>(args?: Subset<T, Materiau$emplacementArgs<ExtArgs>>): Prisma__EmplacementClient<$Result.GetResult<Prisma.$EmplacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materiau model
   */ 
  interface MateriauFieldRefs {
    readonly id: FieldRef<"Materiau", 'String'>
    readonly nom: FieldRef<"Materiau", 'String'>
    readonly description: FieldRef<"Materiau", 'String'>
    readonly quantite: FieldRef<"Materiau", 'Int'>
    readonly codeQR: FieldRef<"Materiau", 'String'>
    readonly emplacementId: FieldRef<"Materiau", 'String'>
    readonly createdAt: FieldRef<"Materiau", 'DateTime'>
    readonly updatedAt: FieldRef<"Materiau", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Materiau findUnique
   */
  export type MateriauFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * Filter, which Materiau to fetch.
     */
    where: MateriauWhereUniqueInput
  }

  /**
   * Materiau findUniqueOrThrow
   */
  export type MateriauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * Filter, which Materiau to fetch.
     */
    where: MateriauWhereUniqueInput
  }

  /**
   * Materiau findFirst
   */
  export type MateriauFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * Filter, which Materiau to fetch.
     */
    where?: MateriauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiaus to fetch.
     */
    orderBy?: MateriauOrderByWithRelationInput | MateriauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materiaus.
     */
    cursor?: MateriauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materiaus.
     */
    distinct?: MateriauScalarFieldEnum | MateriauScalarFieldEnum[]
  }

  /**
   * Materiau findFirstOrThrow
   */
  export type MateriauFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * Filter, which Materiau to fetch.
     */
    where?: MateriauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiaus to fetch.
     */
    orderBy?: MateriauOrderByWithRelationInput | MateriauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materiaus.
     */
    cursor?: MateriauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materiaus.
     */
    distinct?: MateriauScalarFieldEnum | MateriauScalarFieldEnum[]
  }

  /**
   * Materiau findMany
   */
  export type MateriauFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * Filter, which Materiaus to fetch.
     */
    where?: MateriauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiaus to fetch.
     */
    orderBy?: MateriauOrderByWithRelationInput | MateriauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materiaus.
     */
    cursor?: MateriauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiaus.
     */
    skip?: number
    distinct?: MateriauScalarFieldEnum | MateriauScalarFieldEnum[]
  }

  /**
   * Materiau create
   */
  export type MateriauCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * The data needed to create a Materiau.
     */
    data: XOR<MateriauCreateInput, MateriauUncheckedCreateInput>
  }

  /**
   * Materiau createMany
   */
  export type MateriauCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materiaus.
     */
    data: MateriauCreateManyInput | MateriauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materiau update
   */
  export type MateriauUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * The data needed to update a Materiau.
     */
    data: XOR<MateriauUpdateInput, MateriauUncheckedUpdateInput>
    /**
     * Choose, which Materiau to update.
     */
    where: MateriauWhereUniqueInput
  }

  /**
   * Materiau updateMany
   */
  export type MateriauUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materiaus.
     */
    data: XOR<MateriauUpdateManyMutationInput, MateriauUncheckedUpdateManyInput>
    /**
     * Filter which Materiaus to update
     */
    where?: MateriauWhereInput
    /**
     * Limit how many Materiaus to update.
     */
    limit?: number
  }

  /**
   * Materiau upsert
   */
  export type MateriauUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * The filter to search for the Materiau to update in case it exists.
     */
    where: MateriauWhereUniqueInput
    /**
     * In case the Materiau found by the `where` argument doesn't exist, create a new Materiau with this data.
     */
    create: XOR<MateriauCreateInput, MateriauUncheckedCreateInput>
    /**
     * In case the Materiau was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MateriauUpdateInput, MateriauUncheckedUpdateInput>
  }

  /**
   * Materiau delete
   */
  export type MateriauDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
    /**
     * Filter which Materiau to delete.
     */
    where: MateriauWhereUniqueInput
  }

  /**
   * Materiau deleteMany
   */
  export type MateriauDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materiaus to delete
     */
    where?: MateriauWhereInput
    /**
     * Limit how many Materiaus to delete.
     */
    limit?: number
  }

  /**
   * Materiau.emplacement
   */
  export type Materiau$emplacementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emplacement
     */
    select?: EmplacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emplacement
     */
    omit?: EmplacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmplacementInclude<ExtArgs> | null
    where?: EmplacementWhereInput
  }

  /**
   * Materiau without action
   */
  export type MateriauDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiau
     */
    select?: MateriauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materiau
     */
    omit?: MateriauOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriauInclude<ExtArgs> | null
  }


  /**
   * Model Avenant
   */

  export type AggregateAvenant = {
    _count: AvenantCountAggregateOutputType | null
    _avg: AvenantAvgAggregateOutputType | null
    _sum: AvenantSumAggregateOutputType | null
    _min: AvenantMinAggregateOutputType | null
    _max: AvenantMaxAggregateOutputType | null
  }

  export type AvenantAvgAggregateOutputType = {
    id: number | null
    numero: number | null
    marcheId: number | null
  }

  export type AvenantSumAggregateOutputType = {
    id: number | null
    numero: number | null
    marcheId: number | null
  }

  export type AvenantMinAggregateOutputType = {
    id: number | null
    numero: number | null
    date: Date | null
    description: string | null
    chantierId: string | null
    marcheId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvenantMaxAggregateOutputType = {
    id: number | null
    numero: number | null
    date: Date | null
    description: string | null
    chantierId: string | null
    marcheId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvenantCountAggregateOutputType = {
    id: number
    numero: number
    date: number
    description: number
    chantierId: number
    marcheId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvenantAvgAggregateInputType = {
    id?: true
    numero?: true
    marcheId?: true
  }

  export type AvenantSumAggregateInputType = {
    id?: true
    numero?: true
    marcheId?: true
  }

  export type AvenantMinAggregateInputType = {
    id?: true
    numero?: true
    date?: true
    description?: true
    chantierId?: true
    marcheId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvenantMaxAggregateInputType = {
    id?: true
    numero?: true
    date?: true
    description?: true
    chantierId?: true
    marcheId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvenantCountAggregateInputType = {
    id?: true
    numero?: true
    date?: true
    description?: true
    chantierId?: true
    marcheId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avenant to aggregate.
     */
    where?: AvenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avenants to fetch.
     */
    orderBy?: AvenantOrderByWithRelationInput | AvenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avenants
    **/
    _count?: true | AvenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvenantMaxAggregateInputType
  }

  export type GetAvenantAggregateType<T extends AvenantAggregateArgs> = {
        [P in keyof T & keyof AggregateAvenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvenant[P]>
      : GetScalarType<T[P], AggregateAvenant[P]>
  }




  export type AvenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvenantWhereInput
    orderBy?: AvenantOrderByWithAggregationInput | AvenantOrderByWithAggregationInput[]
    by: AvenantScalarFieldEnum[] | AvenantScalarFieldEnum
    having?: AvenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvenantCountAggregateInputType | true
    _avg?: AvenantAvgAggregateInputType
    _sum?: AvenantSumAggregateInputType
    _min?: AvenantMinAggregateInputType
    _max?: AvenantMaxAggregateInputType
  }

  export type AvenantGroupByOutputType = {
    id: number
    numero: number
    date: Date
    description: string | null
    chantierId: string
    marcheId: number
    createdAt: Date
    updatedAt: Date
    _count: AvenantCountAggregateOutputType | null
    _avg: AvenantAvgAggregateOutputType | null
    _sum: AvenantSumAggregateOutputType | null
    _min: AvenantMinAggregateOutputType | null
    _max: AvenantMaxAggregateOutputType | null
  }

  type GetAvenantGroupByPayload<T extends AvenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvenantGroupByOutputType[P]>
            : GetScalarType<T[P], AvenantGroupByOutputType[P]>
        }
      >
    >


  export type AvenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    date?: boolean
    description?: boolean
    chantierId?: boolean
    marcheId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    Marche?: boolean | MarcheDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avenant"]>



  export type AvenantSelectScalar = {
    id?: boolean
    numero?: boolean
    date?: boolean
    description?: boolean
    chantierId?: boolean
    marcheId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numero" | "date" | "description" | "chantierId" | "marcheId" | "createdAt" | "updatedAt", ExtArgs["result"]["avenant"]>
  export type AvenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    Marche?: boolean | MarcheDefaultArgs<ExtArgs>
  }

  export type $AvenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Avenant"
    objects: {
      Chantier: Prisma.$ChantierPayload<ExtArgs>
      Marche: Prisma.$MarchePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numero: number
      date: Date
      description: string | null
      chantierId: string
      marcheId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["avenant"]>
    composites: {}
  }

  type AvenantGetPayload<S extends boolean | null | undefined | AvenantDefaultArgs> = $Result.GetResult<Prisma.$AvenantPayload, S>

  type AvenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvenantCountAggregateInputType | true
    }

  export interface AvenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Avenant'], meta: { name: 'Avenant' } }
    /**
     * Find zero or one Avenant that matches the filter.
     * @param {AvenantFindUniqueArgs} args - Arguments to find a Avenant
     * @example
     * // Get one Avenant
     * const avenant = await prisma.avenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvenantFindUniqueArgs>(args: SelectSubset<T, AvenantFindUniqueArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Avenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvenantFindUniqueOrThrowArgs} args - Arguments to find a Avenant
     * @example
     * // Get one Avenant
     * const avenant = await prisma.avenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvenantFindUniqueOrThrowArgs>(args: SelectSubset<T, AvenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantFindFirstArgs} args - Arguments to find a Avenant
     * @example
     * // Get one Avenant
     * const avenant = await prisma.avenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvenantFindFirstArgs>(args?: SelectSubset<T, AvenantFindFirstArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantFindFirstOrThrowArgs} args - Arguments to find a Avenant
     * @example
     * // Get one Avenant
     * const avenant = await prisma.avenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvenantFindFirstOrThrowArgs>(args?: SelectSubset<T, AvenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Avenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avenants
     * const avenants = await prisma.avenant.findMany()
     * 
     * // Get first 10 Avenants
     * const avenants = await prisma.avenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avenantWithIdOnly = await prisma.avenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvenantFindManyArgs>(args?: SelectSubset<T, AvenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Avenant.
     * @param {AvenantCreateArgs} args - Arguments to create a Avenant.
     * @example
     * // Create one Avenant
     * const Avenant = await prisma.avenant.create({
     *   data: {
     *     // ... data to create a Avenant
     *   }
     * })
     * 
     */
    create<T extends AvenantCreateArgs>(args: SelectSubset<T, AvenantCreateArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Avenants.
     * @param {AvenantCreateManyArgs} args - Arguments to create many Avenants.
     * @example
     * // Create many Avenants
     * const avenant = await prisma.avenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvenantCreateManyArgs>(args?: SelectSubset<T, AvenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Avenant.
     * @param {AvenantDeleteArgs} args - Arguments to delete one Avenant.
     * @example
     * // Delete one Avenant
     * const Avenant = await prisma.avenant.delete({
     *   where: {
     *     // ... filter to delete one Avenant
     *   }
     * })
     * 
     */
    delete<T extends AvenantDeleteArgs>(args: SelectSubset<T, AvenantDeleteArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Avenant.
     * @param {AvenantUpdateArgs} args - Arguments to update one Avenant.
     * @example
     * // Update one Avenant
     * const avenant = await prisma.avenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvenantUpdateArgs>(args: SelectSubset<T, AvenantUpdateArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Avenants.
     * @param {AvenantDeleteManyArgs} args - Arguments to filter Avenants to delete.
     * @example
     * // Delete a few Avenants
     * const { count } = await prisma.avenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvenantDeleteManyArgs>(args?: SelectSubset<T, AvenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avenants
     * const avenant = await prisma.avenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvenantUpdateManyArgs>(args: SelectSubset<T, AvenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avenant.
     * @param {AvenantUpsertArgs} args - Arguments to update or create a Avenant.
     * @example
     * // Update or create a Avenant
     * const avenant = await prisma.avenant.upsert({
     *   create: {
     *     // ... data to create a Avenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avenant we want to update
     *   }
     * })
     */
    upsert<T extends AvenantUpsertArgs>(args: SelectSubset<T, AvenantUpsertArgs<ExtArgs>>): Prisma__AvenantClient<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Avenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantCountArgs} args - Arguments to filter Avenants to count.
     * @example
     * // Count the number of Avenants
     * const count = await prisma.avenant.count({
     *   where: {
     *     // ... the filter for the Avenants we want to count
     *   }
     * })
    **/
    count<T extends AvenantCountArgs>(
      args?: Subset<T, AvenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvenantAggregateArgs>(args: Subset<T, AvenantAggregateArgs>): Prisma.PrismaPromise<GetAvenantAggregateType<T>>

    /**
     * Group by Avenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvenantGroupByArgs['orderBy'] }
        : { orderBy?: AvenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Avenant model
   */
  readonly fields: AvenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Avenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Marche<T extends MarcheDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarcheDefaultArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Avenant model
   */ 
  interface AvenantFieldRefs {
    readonly id: FieldRef<"Avenant", 'Int'>
    readonly numero: FieldRef<"Avenant", 'Int'>
    readonly date: FieldRef<"Avenant", 'DateTime'>
    readonly description: FieldRef<"Avenant", 'String'>
    readonly chantierId: FieldRef<"Avenant", 'String'>
    readonly marcheId: FieldRef<"Avenant", 'Int'>
    readonly createdAt: FieldRef<"Avenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Avenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Avenant findUnique
   */
  export type AvenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * Filter, which Avenant to fetch.
     */
    where: AvenantWhereUniqueInput
  }

  /**
   * Avenant findUniqueOrThrow
   */
  export type AvenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * Filter, which Avenant to fetch.
     */
    where: AvenantWhereUniqueInput
  }

  /**
   * Avenant findFirst
   */
  export type AvenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * Filter, which Avenant to fetch.
     */
    where?: AvenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avenants to fetch.
     */
    orderBy?: AvenantOrderByWithRelationInput | AvenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avenants.
     */
    cursor?: AvenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avenants.
     */
    distinct?: AvenantScalarFieldEnum | AvenantScalarFieldEnum[]
  }

  /**
   * Avenant findFirstOrThrow
   */
  export type AvenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * Filter, which Avenant to fetch.
     */
    where?: AvenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avenants to fetch.
     */
    orderBy?: AvenantOrderByWithRelationInput | AvenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avenants.
     */
    cursor?: AvenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avenants.
     */
    distinct?: AvenantScalarFieldEnum | AvenantScalarFieldEnum[]
  }

  /**
   * Avenant findMany
   */
  export type AvenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * Filter, which Avenants to fetch.
     */
    where?: AvenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avenants to fetch.
     */
    orderBy?: AvenantOrderByWithRelationInput | AvenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avenants.
     */
    cursor?: AvenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avenants.
     */
    skip?: number
    distinct?: AvenantScalarFieldEnum | AvenantScalarFieldEnum[]
  }

  /**
   * Avenant create
   */
  export type AvenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Avenant.
     */
    data: XOR<AvenantCreateInput, AvenantUncheckedCreateInput>
  }

  /**
   * Avenant createMany
   */
  export type AvenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avenants.
     */
    data: AvenantCreateManyInput | AvenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Avenant update
   */
  export type AvenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Avenant.
     */
    data: XOR<AvenantUpdateInput, AvenantUncheckedUpdateInput>
    /**
     * Choose, which Avenant to update.
     */
    where: AvenantWhereUniqueInput
  }

  /**
   * Avenant updateMany
   */
  export type AvenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avenants.
     */
    data: XOR<AvenantUpdateManyMutationInput, AvenantUncheckedUpdateManyInput>
    /**
     * Filter which Avenants to update
     */
    where?: AvenantWhereInput
    /**
     * Limit how many Avenants to update.
     */
    limit?: number
  }

  /**
   * Avenant upsert
   */
  export type AvenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Avenant to update in case it exists.
     */
    where: AvenantWhereUniqueInput
    /**
     * In case the Avenant found by the `where` argument doesn't exist, create a new Avenant with this data.
     */
    create: XOR<AvenantCreateInput, AvenantUncheckedCreateInput>
    /**
     * In case the Avenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvenantUpdateInput, AvenantUncheckedUpdateInput>
  }

  /**
   * Avenant delete
   */
  export type AvenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    /**
     * Filter which Avenant to delete.
     */
    where: AvenantWhereUniqueInput
  }

  /**
   * Avenant deleteMany
   */
  export type AvenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avenants to delete
     */
    where?: AvenantWhereInput
    /**
     * Limit how many Avenants to delete.
     */
    limit?: number
  }

  /**
   * Avenant without action
   */
  export type AvenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
  }


  /**
   * Model Chantier
   */

  export type AggregateChantier = {
    _count: ChantierCountAggregateOutputType | null
    _avg: ChantierAvgAggregateOutputType | null
    _sum: ChantierSumAggregateOutputType | null
    _min: ChantierMinAggregateOutputType | null
    _max: ChantierMaxAggregateOutputType | null
  }

  export type ChantierAvgAggregateOutputType = {
    id: number | null
    budget: number | null
    dureeEnJours: number | null
  }

  export type ChantierSumAggregateOutputType = {
    id: number | null
    budget: number | null
    dureeEnJours: number | null
  }

  export type ChantierMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    nomChantier: string | null
    adresseChantier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    budget: number | null
    dateDebut: Date | null
    dateFinPrevue: Date | null
    dateFinReelle: Date | null
    description: string | null
    statut: string | null
    villeChantier: string | null
    dureeEnJours: number | null
    typeDuree: string | null
  }

  export type ChantierMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    nomChantier: string | null
    adresseChantier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    budget: number | null
    dateDebut: Date | null
    dateFinPrevue: Date | null
    dateFinReelle: Date | null
    description: string | null
    statut: string | null
    villeChantier: string | null
    dureeEnJours: number | null
    typeDuree: string | null
  }

  export type ChantierCountAggregateOutputType = {
    id: number
    chantierId: number
    nomChantier: number
    adresseChantier: number
    createdAt: number
    updatedAt: number
    clientId: number
    budget: number
    dateDebut: number
    dateFinPrevue: number
    dateFinReelle: number
    description: number
    statut: number
    villeChantier: number
    dureeEnJours: number
    typeDuree: number
    _all: number
  }


  export type ChantierAvgAggregateInputType = {
    id?: true
    budget?: true
    dureeEnJours?: true
  }

  export type ChantierSumAggregateInputType = {
    id?: true
    budget?: true
    dureeEnJours?: true
  }

  export type ChantierMinAggregateInputType = {
    id?: true
    chantierId?: true
    nomChantier?: true
    adresseChantier?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    budget?: true
    dateDebut?: true
    dateFinPrevue?: true
    dateFinReelle?: true
    description?: true
    statut?: true
    villeChantier?: true
    dureeEnJours?: true
    typeDuree?: true
  }

  export type ChantierMaxAggregateInputType = {
    id?: true
    chantierId?: true
    nomChantier?: true
    adresseChantier?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    budget?: true
    dateDebut?: true
    dateFinPrevue?: true
    dateFinReelle?: true
    description?: true
    statut?: true
    villeChantier?: true
    dureeEnJours?: true
    typeDuree?: true
  }

  export type ChantierCountAggregateInputType = {
    id?: true
    chantierId?: true
    nomChantier?: true
    adresseChantier?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    budget?: true
    dateDebut?: true
    dateFinPrevue?: true
    dateFinReelle?: true
    description?: true
    statut?: true
    villeChantier?: true
    dureeEnJours?: true
    typeDuree?: true
    _all?: true
  }

  export type ChantierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chantier to aggregate.
     */
    where?: ChantierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chantiers to fetch.
     */
    orderBy?: ChantierOrderByWithRelationInput | ChantierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChantierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chantiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chantiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chantiers
    **/
    _count?: true | ChantierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChantierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChantierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChantierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChantierMaxAggregateInputType
  }

  export type GetChantierAggregateType<T extends ChantierAggregateArgs> = {
        [P in keyof T & keyof AggregateChantier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChantier[P]>
      : GetScalarType<T[P], AggregateChantier[P]>
  }




  export type ChantierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChantierWhereInput
    orderBy?: ChantierOrderByWithAggregationInput | ChantierOrderByWithAggregationInput[]
    by: ChantierScalarFieldEnum[] | ChantierScalarFieldEnum
    having?: ChantierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChantierCountAggregateInputType | true
    _avg?: ChantierAvgAggregateInputType
    _sum?: ChantierSumAggregateInputType
    _min?: ChantierMinAggregateInputType
    _max?: ChantierMaxAggregateInputType
  }

  export type ChantierGroupByOutputType = {
    id: number
    chantierId: string
    nomChantier: string
    adresseChantier: string | null
    createdAt: Date
    updatedAt: Date
    clientId: string | null
    budget: number | null
    dateDebut: Date | null
    dateFinPrevue: Date | null
    dateFinReelle: Date | null
    description: string | null
    statut: string
    villeChantier: string | null
    dureeEnJours: number | null
    typeDuree: string
    _count: ChantierCountAggregateOutputType | null
    _avg: ChantierAvgAggregateOutputType | null
    _sum: ChantierSumAggregateOutputType | null
    _min: ChantierMinAggregateOutputType | null
    _max: ChantierMaxAggregateOutputType | null
  }

  type GetChantierGroupByPayload<T extends ChantierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChantierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChantierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChantierGroupByOutputType[P]>
            : GetScalarType<T[P], ChantierGroupByOutputType[P]>
        }
      >
    >


  export type ChantierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    nomChantier?: boolean
    adresseChantier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    budget?: boolean
    dateDebut?: boolean
    dateFinPrevue?: boolean
    dateFinReelle?: boolean
    description?: boolean
    statut?: boolean
    villeChantier?: boolean
    dureeEnJours?: boolean
    typeDuree?: boolean
    avenants?: boolean | Chantier$avenantsArgs<ExtArgs>
    client?: boolean | Chantier$clientArgs<ExtArgs>
    documents?: boolean | Chantier$documentsArgs<ExtArgs>
    etats?: boolean | Chantier$etatsArgs<ExtArgs>
    marches?: boolean | Chantier$marchesArgs<ExtArgs>
    notes?: boolean | Chantier$notesArgs<ExtArgs>
    taches?: boolean | Chantier$tachesArgs<ExtArgs>
    admintasks?: boolean | Chantier$admintasksArgs<ExtArgs>
    bonsRegie?: boolean | Chantier$bonsRegieArgs<ExtArgs>
    _count?: boolean | ChantierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chantier"]>



  export type ChantierSelectScalar = {
    id?: boolean
    chantierId?: boolean
    nomChantier?: boolean
    adresseChantier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    budget?: boolean
    dateDebut?: boolean
    dateFinPrevue?: boolean
    dateFinReelle?: boolean
    description?: boolean
    statut?: boolean
    villeChantier?: boolean
    dureeEnJours?: boolean
    typeDuree?: boolean
  }

  export type ChantierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "nomChantier" | "adresseChantier" | "createdAt" | "updatedAt" | "clientId" | "budget" | "dateDebut" | "dateFinPrevue" | "dateFinReelle" | "description" | "statut" | "villeChantier" | "dureeEnJours" | "typeDuree", ExtArgs["result"]["chantier"]>
  export type ChantierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avenants?: boolean | Chantier$avenantsArgs<ExtArgs>
    client?: boolean | Chantier$clientArgs<ExtArgs>
    documents?: boolean | Chantier$documentsArgs<ExtArgs>
    etats?: boolean | Chantier$etatsArgs<ExtArgs>
    marches?: boolean | Chantier$marchesArgs<ExtArgs>
    notes?: boolean | Chantier$notesArgs<ExtArgs>
    taches?: boolean | Chantier$tachesArgs<ExtArgs>
    admintasks?: boolean | Chantier$admintasksArgs<ExtArgs>
    bonsRegie?: boolean | Chantier$bonsRegieArgs<ExtArgs>
    _count?: boolean | ChantierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChantierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chantier"
    objects: {
      avenants: Prisma.$AvenantPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      etats: Prisma.$EtatPayload<ExtArgs>[]
      marches: Prisma.$MarchePayload<ExtArgs> | null
      notes: Prisma.$NotePayload<ExtArgs>[]
      taches: Prisma.$TachePayload<ExtArgs>[]
      admintasks: Prisma.$admintaskPayload<ExtArgs>[]
      bonsRegie: Prisma.$BonRegiePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      nomChantier: string
      adresseChantier: string | null
      createdAt: Date
      updatedAt: Date
      clientId: string | null
      budget: number | null
      dateDebut: Date | null
      dateFinPrevue: Date | null
      dateFinReelle: Date | null
      description: string | null
      statut: string
      villeChantier: string | null
      dureeEnJours: number | null
      typeDuree: string
    }, ExtArgs["result"]["chantier"]>
    composites: {}
  }

  type ChantierGetPayload<S extends boolean | null | undefined | ChantierDefaultArgs> = $Result.GetResult<Prisma.$ChantierPayload, S>

  type ChantierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChantierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChantierCountAggregateInputType | true
    }

  export interface ChantierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chantier'], meta: { name: 'Chantier' } }
    /**
     * Find zero or one Chantier that matches the filter.
     * @param {ChantierFindUniqueArgs} args - Arguments to find a Chantier
     * @example
     * // Get one Chantier
     * const chantier = await prisma.chantier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChantierFindUniqueArgs>(args: SelectSubset<T, ChantierFindUniqueArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chantier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChantierFindUniqueOrThrowArgs} args - Arguments to find a Chantier
     * @example
     * // Get one Chantier
     * const chantier = await prisma.chantier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChantierFindUniqueOrThrowArgs>(args: SelectSubset<T, ChantierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chantier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierFindFirstArgs} args - Arguments to find a Chantier
     * @example
     * // Get one Chantier
     * const chantier = await prisma.chantier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChantierFindFirstArgs>(args?: SelectSubset<T, ChantierFindFirstArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chantier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierFindFirstOrThrowArgs} args - Arguments to find a Chantier
     * @example
     * // Get one Chantier
     * const chantier = await prisma.chantier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChantierFindFirstOrThrowArgs>(args?: SelectSubset<T, ChantierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chantiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chantiers
     * const chantiers = await prisma.chantier.findMany()
     * 
     * // Get first 10 Chantiers
     * const chantiers = await prisma.chantier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chantierWithIdOnly = await prisma.chantier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChantierFindManyArgs>(args?: SelectSubset<T, ChantierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chantier.
     * @param {ChantierCreateArgs} args - Arguments to create a Chantier.
     * @example
     * // Create one Chantier
     * const Chantier = await prisma.chantier.create({
     *   data: {
     *     // ... data to create a Chantier
     *   }
     * })
     * 
     */
    create<T extends ChantierCreateArgs>(args: SelectSubset<T, ChantierCreateArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chantiers.
     * @param {ChantierCreateManyArgs} args - Arguments to create many Chantiers.
     * @example
     * // Create many Chantiers
     * const chantier = await prisma.chantier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChantierCreateManyArgs>(args?: SelectSubset<T, ChantierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chantier.
     * @param {ChantierDeleteArgs} args - Arguments to delete one Chantier.
     * @example
     * // Delete one Chantier
     * const Chantier = await prisma.chantier.delete({
     *   where: {
     *     // ... filter to delete one Chantier
     *   }
     * })
     * 
     */
    delete<T extends ChantierDeleteArgs>(args: SelectSubset<T, ChantierDeleteArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chantier.
     * @param {ChantierUpdateArgs} args - Arguments to update one Chantier.
     * @example
     * // Update one Chantier
     * const chantier = await prisma.chantier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChantierUpdateArgs>(args: SelectSubset<T, ChantierUpdateArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chantiers.
     * @param {ChantierDeleteManyArgs} args - Arguments to filter Chantiers to delete.
     * @example
     * // Delete a few Chantiers
     * const { count } = await prisma.chantier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChantierDeleteManyArgs>(args?: SelectSubset<T, ChantierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chantiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chantiers
     * const chantier = await prisma.chantier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChantierUpdateManyArgs>(args: SelectSubset<T, ChantierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chantier.
     * @param {ChantierUpsertArgs} args - Arguments to update or create a Chantier.
     * @example
     * // Update or create a Chantier
     * const chantier = await prisma.chantier.upsert({
     *   create: {
     *     // ... data to create a Chantier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chantier we want to update
     *   }
     * })
     */
    upsert<T extends ChantierUpsertArgs>(args: SelectSubset<T, ChantierUpsertArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chantiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierCountArgs} args - Arguments to filter Chantiers to count.
     * @example
     * // Count the number of Chantiers
     * const count = await prisma.chantier.count({
     *   where: {
     *     // ... the filter for the Chantiers we want to count
     *   }
     * })
    **/
    count<T extends ChantierCountArgs>(
      args?: Subset<T, ChantierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChantierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chantier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChantierAggregateArgs>(args: Subset<T, ChantierAggregateArgs>): Prisma.PrismaPromise<GetChantierAggregateType<T>>

    /**
     * Group by Chantier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChantierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChantierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChantierGroupByArgs['orderBy'] }
        : { orderBy?: ChantierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChantierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChantierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chantier model
   */
  readonly fields: ChantierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chantier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChantierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avenants<T extends Chantier$avenantsArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$avenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends Chantier$clientArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Chantier$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    etats<T extends Chantier$etatsArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$etatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marches<T extends Chantier$marchesArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$marchesArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notes<T extends Chantier$notesArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taches<T extends Chantier$tachesArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$tachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admintasks<T extends Chantier$admintasksArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$admintasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bonsRegie<T extends Chantier$bonsRegieArgs<ExtArgs> = {}>(args?: Subset<T, Chantier$bonsRegieArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chantier model
   */ 
  interface ChantierFieldRefs {
    readonly id: FieldRef<"Chantier", 'Int'>
    readonly chantierId: FieldRef<"Chantier", 'String'>
    readonly nomChantier: FieldRef<"Chantier", 'String'>
    readonly adresseChantier: FieldRef<"Chantier", 'String'>
    readonly createdAt: FieldRef<"Chantier", 'DateTime'>
    readonly updatedAt: FieldRef<"Chantier", 'DateTime'>
    readonly clientId: FieldRef<"Chantier", 'String'>
    readonly budget: FieldRef<"Chantier", 'Float'>
    readonly dateDebut: FieldRef<"Chantier", 'DateTime'>
    readonly dateFinPrevue: FieldRef<"Chantier", 'DateTime'>
    readonly dateFinReelle: FieldRef<"Chantier", 'DateTime'>
    readonly description: FieldRef<"Chantier", 'String'>
    readonly statut: FieldRef<"Chantier", 'String'>
    readonly villeChantier: FieldRef<"Chantier", 'String'>
    readonly dureeEnJours: FieldRef<"Chantier", 'Int'>
    readonly typeDuree: FieldRef<"Chantier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chantier findUnique
   */
  export type ChantierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * Filter, which Chantier to fetch.
     */
    where: ChantierWhereUniqueInput
  }

  /**
   * Chantier findUniqueOrThrow
   */
  export type ChantierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * Filter, which Chantier to fetch.
     */
    where: ChantierWhereUniqueInput
  }

  /**
   * Chantier findFirst
   */
  export type ChantierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * Filter, which Chantier to fetch.
     */
    where?: ChantierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chantiers to fetch.
     */
    orderBy?: ChantierOrderByWithRelationInput | ChantierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chantiers.
     */
    cursor?: ChantierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chantiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chantiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chantiers.
     */
    distinct?: ChantierScalarFieldEnum | ChantierScalarFieldEnum[]
  }

  /**
   * Chantier findFirstOrThrow
   */
  export type ChantierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * Filter, which Chantier to fetch.
     */
    where?: ChantierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chantiers to fetch.
     */
    orderBy?: ChantierOrderByWithRelationInput | ChantierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chantiers.
     */
    cursor?: ChantierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chantiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chantiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chantiers.
     */
    distinct?: ChantierScalarFieldEnum | ChantierScalarFieldEnum[]
  }

  /**
   * Chantier findMany
   */
  export type ChantierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * Filter, which Chantiers to fetch.
     */
    where?: ChantierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chantiers to fetch.
     */
    orderBy?: ChantierOrderByWithRelationInput | ChantierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chantiers.
     */
    cursor?: ChantierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chantiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chantiers.
     */
    skip?: number
    distinct?: ChantierScalarFieldEnum | ChantierScalarFieldEnum[]
  }

  /**
   * Chantier create
   */
  export type ChantierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * The data needed to create a Chantier.
     */
    data: XOR<ChantierCreateInput, ChantierUncheckedCreateInput>
  }

  /**
   * Chantier createMany
   */
  export type ChantierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chantiers.
     */
    data: ChantierCreateManyInput | ChantierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chantier update
   */
  export type ChantierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * The data needed to update a Chantier.
     */
    data: XOR<ChantierUpdateInput, ChantierUncheckedUpdateInput>
    /**
     * Choose, which Chantier to update.
     */
    where: ChantierWhereUniqueInput
  }

  /**
   * Chantier updateMany
   */
  export type ChantierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chantiers.
     */
    data: XOR<ChantierUpdateManyMutationInput, ChantierUncheckedUpdateManyInput>
    /**
     * Filter which Chantiers to update
     */
    where?: ChantierWhereInput
    /**
     * Limit how many Chantiers to update.
     */
    limit?: number
  }

  /**
   * Chantier upsert
   */
  export type ChantierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * The filter to search for the Chantier to update in case it exists.
     */
    where: ChantierWhereUniqueInput
    /**
     * In case the Chantier found by the `where` argument doesn't exist, create a new Chantier with this data.
     */
    create: XOR<ChantierCreateInput, ChantierUncheckedCreateInput>
    /**
     * In case the Chantier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChantierUpdateInput, ChantierUncheckedUpdateInput>
  }

  /**
   * Chantier delete
   */
  export type ChantierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    /**
     * Filter which Chantier to delete.
     */
    where: ChantierWhereUniqueInput
  }

  /**
   * Chantier deleteMany
   */
  export type ChantierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chantiers to delete
     */
    where?: ChantierWhereInput
    /**
     * Limit how many Chantiers to delete.
     */
    limit?: number
  }

  /**
   * Chantier.avenants
   */
  export type Chantier$avenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    where?: AvenantWhereInput
    orderBy?: AvenantOrderByWithRelationInput | AvenantOrderByWithRelationInput[]
    cursor?: AvenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvenantScalarFieldEnum | AvenantScalarFieldEnum[]
  }

  /**
   * Chantier.client
   */
  export type Chantier$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Chantier.documents
   */
  export type Chantier$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Chantier.etats
   */
  export type Chantier$etatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    where?: EtatWhereInput
    orderBy?: EtatOrderByWithRelationInput | EtatOrderByWithRelationInput[]
    cursor?: EtatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtatScalarFieldEnum | EtatScalarFieldEnum[]
  }

  /**
   * Chantier.marches
   */
  export type Chantier$marchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    where?: MarcheWhereInput
  }

  /**
   * Chantier.notes
   */
  export type Chantier$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Chantier.taches
   */
  export type Chantier$tachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    where?: TacheWhereInput
    orderBy?: TacheOrderByWithRelationInput | TacheOrderByWithRelationInput[]
    cursor?: TacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TacheScalarFieldEnum | TacheScalarFieldEnum[]
  }

  /**
   * Chantier.admintasks
   */
  export type Chantier$admintasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    where?: admintaskWhereInput
    orderBy?: admintaskOrderByWithRelationInput | admintaskOrderByWithRelationInput[]
    cursor?: admintaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmintaskScalarFieldEnum | AdmintaskScalarFieldEnum[]
  }

  /**
   * Chantier.bonsRegie
   */
  export type Chantier$bonsRegieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    where?: BonRegieWhereInput
    orderBy?: BonRegieOrderByWithRelationInput | BonRegieOrderByWithRelationInput[]
    cursor?: BonRegieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonRegieScalarFieldEnum | BonRegieScalarFieldEnum[]
  }

  /**
   * Chantier without action
   */
  export type ChantierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    nom: string | null
    email: string | null
    adresse: string | null
    telephone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    email: string | null
    adresse: string | null
    telephone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    adresse: number
    telephone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    adresse?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    adresse?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    adresse?: true
    telephone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    nom: string
    email: string | null
    adresse: string | null
    telephone: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    adresse?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Chantier?: boolean | Client$ChantierArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>



  export type ClientSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    adresse?: boolean
    telephone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "email" | "adresse" | "telephone" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chantier?: boolean | Client$ChantierArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      Chantier: Prisma.$ChantierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      email: string | null
      adresse: string | null
      telephone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chantier<T extends Client$ChantierArgs<ExtArgs> = {}>(args?: Subset<T, Client$ChantierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly nom: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly adresse: FieldRef<"Client", 'String'>
    readonly telephone: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.Chantier
   */
  export type Client$ChantierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    where?: ChantierWhereInput
    orderBy?: ChantierOrderByWithRelationInput | ChantierOrderByWithRelationInput[]
    cursor?: ChantierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChantierScalarFieldEnum | ChantierScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    taille: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    taille: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    nom: string | null
    type: string | null
    url: string | null
    taille: number | null
    mimeType: string | null
    chantierId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    type: string | null
    url: string | null
    taille: number | null
    mimeType: string | null
    chantierId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    nom: number
    type: number
    url: number
    taille: number
    mimeType: number
    chantierId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    metadata: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    taille?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    taille?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    url?: true
    taille?: true
    mimeType?: true
    chantierId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    url?: true
    taille?: true
    mimeType?: true
    chantierId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    url?: true
    taille?: true
    mimeType?: true
    chantierId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    chantierId: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type?: boolean
    url?: boolean
    taille?: boolean
    mimeType?: boolean
    chantierId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>



  export type DocumentSelectScalar = {
    id?: boolean
    nom?: boolean
    type?: boolean
    url?: boolean
    taille?: boolean
    mimeType?: boolean
    chantierId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "type" | "url" | "taille" | "mimeType" | "chantierId" | "createdBy" | "createdAt" | "updatedAt" | "metadata", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      chantier: Prisma.$ChantierPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      type: string
      url: string
      taille: number
      mimeType: string
      chantierId: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly nom: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly taille: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly chantierId: FieldRef<"Document", 'String'>
    readonly createdBy: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly metadata: FieldRef<"Document", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentOuvrier
   */

  export type AggregateDocumentOuvrier = {
    _count: DocumentOuvrierCountAggregateOutputType | null
    _min: DocumentOuvrierMinAggregateOutputType | null
    _max: DocumentOuvrierMaxAggregateOutputType | null
  }

  export type DocumentOuvrierMinAggregateOutputType = {
    id: string | null
    nom: string | null
    type: string | null
    url: string | null
    dateExpiration: Date | null
    ouvrierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentOuvrierMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    type: string | null
    url: string | null
    dateExpiration: Date | null
    ouvrierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentOuvrierCountAggregateOutputType = {
    id: number
    nom: number
    type: number
    url: number
    dateExpiration: number
    ouvrierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentOuvrierMinAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    url?: true
    dateExpiration?: true
    ouvrierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentOuvrierMaxAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    url?: true
    dateExpiration?: true
    ouvrierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentOuvrierCountAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    url?: true
    dateExpiration?: true
    ouvrierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentOuvrierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentOuvrier to aggregate.
     */
    where?: DocumentOuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentOuvriers to fetch.
     */
    orderBy?: DocumentOuvrierOrderByWithRelationInput | DocumentOuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentOuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentOuvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentOuvriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentOuvriers
    **/
    _count?: true | DocumentOuvrierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentOuvrierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentOuvrierMaxAggregateInputType
  }

  export type GetDocumentOuvrierAggregateType<T extends DocumentOuvrierAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentOuvrier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentOuvrier[P]>
      : GetScalarType<T[P], AggregateDocumentOuvrier[P]>
  }




  export type DocumentOuvrierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentOuvrierWhereInput
    orderBy?: DocumentOuvrierOrderByWithAggregationInput | DocumentOuvrierOrderByWithAggregationInput[]
    by: DocumentOuvrierScalarFieldEnum[] | DocumentOuvrierScalarFieldEnum
    having?: DocumentOuvrierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentOuvrierCountAggregateInputType | true
    _min?: DocumentOuvrierMinAggregateInputType
    _max?: DocumentOuvrierMaxAggregateInputType
  }

  export type DocumentOuvrierGroupByOutputType = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration: Date | null
    ouvrierId: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentOuvrierCountAggregateOutputType | null
    _min: DocumentOuvrierMinAggregateOutputType | null
    _max: DocumentOuvrierMaxAggregateOutputType | null
  }

  type GetDocumentOuvrierGroupByPayload<T extends DocumentOuvrierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentOuvrierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentOuvrierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentOuvrierGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentOuvrierGroupByOutputType[P]>
        }
      >
    >


  export type DocumentOuvrierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type?: boolean
    url?: boolean
    dateExpiration?: boolean
    ouvrierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Ouvrier?: boolean | OuvrierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentOuvrier"]>



  export type DocumentOuvrierSelectScalar = {
    id?: boolean
    nom?: boolean
    type?: boolean
    url?: boolean
    dateExpiration?: boolean
    ouvrierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOuvrierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "type" | "url" | "dateExpiration" | "ouvrierId" | "createdAt" | "updatedAt", ExtArgs["result"]["documentOuvrier"]>
  export type DocumentOuvrierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ouvrier?: boolean | OuvrierDefaultArgs<ExtArgs>
  }

  export type $DocumentOuvrierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentOuvrier"
    objects: {
      Ouvrier: Prisma.$OuvrierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      type: string
      url: string
      dateExpiration: Date | null
      ouvrierId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentOuvrier"]>
    composites: {}
  }

  type DocumentOuvrierGetPayload<S extends boolean | null | undefined | DocumentOuvrierDefaultArgs> = $Result.GetResult<Prisma.$DocumentOuvrierPayload, S>

  type DocumentOuvrierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentOuvrierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentOuvrierCountAggregateInputType | true
    }

  export interface DocumentOuvrierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentOuvrier'], meta: { name: 'DocumentOuvrier' } }
    /**
     * Find zero or one DocumentOuvrier that matches the filter.
     * @param {DocumentOuvrierFindUniqueArgs} args - Arguments to find a DocumentOuvrier
     * @example
     * // Get one DocumentOuvrier
     * const documentOuvrier = await prisma.documentOuvrier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentOuvrierFindUniqueArgs>(args: SelectSubset<T, DocumentOuvrierFindUniqueArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentOuvrier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentOuvrierFindUniqueOrThrowArgs} args - Arguments to find a DocumentOuvrier
     * @example
     * // Get one DocumentOuvrier
     * const documentOuvrier = await prisma.documentOuvrier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentOuvrierFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentOuvrierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentOuvrier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierFindFirstArgs} args - Arguments to find a DocumentOuvrier
     * @example
     * // Get one DocumentOuvrier
     * const documentOuvrier = await prisma.documentOuvrier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentOuvrierFindFirstArgs>(args?: SelectSubset<T, DocumentOuvrierFindFirstArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentOuvrier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierFindFirstOrThrowArgs} args - Arguments to find a DocumentOuvrier
     * @example
     * // Get one DocumentOuvrier
     * const documentOuvrier = await prisma.documentOuvrier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentOuvrierFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentOuvrierFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentOuvriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentOuvriers
     * const documentOuvriers = await prisma.documentOuvrier.findMany()
     * 
     * // Get first 10 DocumentOuvriers
     * const documentOuvriers = await prisma.documentOuvrier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentOuvrierWithIdOnly = await prisma.documentOuvrier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentOuvrierFindManyArgs>(args?: SelectSubset<T, DocumentOuvrierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentOuvrier.
     * @param {DocumentOuvrierCreateArgs} args - Arguments to create a DocumentOuvrier.
     * @example
     * // Create one DocumentOuvrier
     * const DocumentOuvrier = await prisma.documentOuvrier.create({
     *   data: {
     *     // ... data to create a DocumentOuvrier
     *   }
     * })
     * 
     */
    create<T extends DocumentOuvrierCreateArgs>(args: SelectSubset<T, DocumentOuvrierCreateArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentOuvriers.
     * @param {DocumentOuvrierCreateManyArgs} args - Arguments to create many DocumentOuvriers.
     * @example
     * // Create many DocumentOuvriers
     * const documentOuvrier = await prisma.documentOuvrier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentOuvrierCreateManyArgs>(args?: SelectSubset<T, DocumentOuvrierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentOuvrier.
     * @param {DocumentOuvrierDeleteArgs} args - Arguments to delete one DocumentOuvrier.
     * @example
     * // Delete one DocumentOuvrier
     * const DocumentOuvrier = await prisma.documentOuvrier.delete({
     *   where: {
     *     // ... filter to delete one DocumentOuvrier
     *   }
     * })
     * 
     */
    delete<T extends DocumentOuvrierDeleteArgs>(args: SelectSubset<T, DocumentOuvrierDeleteArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentOuvrier.
     * @param {DocumentOuvrierUpdateArgs} args - Arguments to update one DocumentOuvrier.
     * @example
     * // Update one DocumentOuvrier
     * const documentOuvrier = await prisma.documentOuvrier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentOuvrierUpdateArgs>(args: SelectSubset<T, DocumentOuvrierUpdateArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentOuvriers.
     * @param {DocumentOuvrierDeleteManyArgs} args - Arguments to filter DocumentOuvriers to delete.
     * @example
     * // Delete a few DocumentOuvriers
     * const { count } = await prisma.documentOuvrier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentOuvrierDeleteManyArgs>(args?: SelectSubset<T, DocumentOuvrierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentOuvriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentOuvriers
     * const documentOuvrier = await prisma.documentOuvrier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentOuvrierUpdateManyArgs>(args: SelectSubset<T, DocumentOuvrierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentOuvrier.
     * @param {DocumentOuvrierUpsertArgs} args - Arguments to update or create a DocumentOuvrier.
     * @example
     * // Update or create a DocumentOuvrier
     * const documentOuvrier = await prisma.documentOuvrier.upsert({
     *   create: {
     *     // ... data to create a DocumentOuvrier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentOuvrier we want to update
     *   }
     * })
     */
    upsert<T extends DocumentOuvrierUpsertArgs>(args: SelectSubset<T, DocumentOuvrierUpsertArgs<ExtArgs>>): Prisma__DocumentOuvrierClient<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentOuvriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierCountArgs} args - Arguments to filter DocumentOuvriers to count.
     * @example
     * // Count the number of DocumentOuvriers
     * const count = await prisma.documentOuvrier.count({
     *   where: {
     *     // ... the filter for the DocumentOuvriers we want to count
     *   }
     * })
    **/
    count<T extends DocumentOuvrierCountArgs>(
      args?: Subset<T, DocumentOuvrierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentOuvrierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentOuvrier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentOuvrierAggregateArgs>(args: Subset<T, DocumentOuvrierAggregateArgs>): Prisma.PrismaPromise<GetDocumentOuvrierAggregateType<T>>

    /**
     * Group by DocumentOuvrier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentOuvrierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentOuvrierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentOuvrierGroupByArgs['orderBy'] }
        : { orderBy?: DocumentOuvrierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentOuvrierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentOuvrierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentOuvrier model
   */
  readonly fields: DocumentOuvrierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentOuvrier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentOuvrierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ouvrier<T extends OuvrierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OuvrierDefaultArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentOuvrier model
   */ 
  interface DocumentOuvrierFieldRefs {
    readonly id: FieldRef<"DocumentOuvrier", 'String'>
    readonly nom: FieldRef<"DocumentOuvrier", 'String'>
    readonly type: FieldRef<"DocumentOuvrier", 'String'>
    readonly url: FieldRef<"DocumentOuvrier", 'String'>
    readonly dateExpiration: FieldRef<"DocumentOuvrier", 'DateTime'>
    readonly ouvrierId: FieldRef<"DocumentOuvrier", 'String'>
    readonly createdAt: FieldRef<"DocumentOuvrier", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentOuvrier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentOuvrier findUnique
   */
  export type DocumentOuvrierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * Filter, which DocumentOuvrier to fetch.
     */
    where: DocumentOuvrierWhereUniqueInput
  }

  /**
   * DocumentOuvrier findUniqueOrThrow
   */
  export type DocumentOuvrierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * Filter, which DocumentOuvrier to fetch.
     */
    where: DocumentOuvrierWhereUniqueInput
  }

  /**
   * DocumentOuvrier findFirst
   */
  export type DocumentOuvrierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * Filter, which DocumentOuvrier to fetch.
     */
    where?: DocumentOuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentOuvriers to fetch.
     */
    orderBy?: DocumentOuvrierOrderByWithRelationInput | DocumentOuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentOuvriers.
     */
    cursor?: DocumentOuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentOuvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentOuvriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentOuvriers.
     */
    distinct?: DocumentOuvrierScalarFieldEnum | DocumentOuvrierScalarFieldEnum[]
  }

  /**
   * DocumentOuvrier findFirstOrThrow
   */
  export type DocumentOuvrierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * Filter, which DocumentOuvrier to fetch.
     */
    where?: DocumentOuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentOuvriers to fetch.
     */
    orderBy?: DocumentOuvrierOrderByWithRelationInput | DocumentOuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentOuvriers.
     */
    cursor?: DocumentOuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentOuvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentOuvriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentOuvriers.
     */
    distinct?: DocumentOuvrierScalarFieldEnum | DocumentOuvrierScalarFieldEnum[]
  }

  /**
   * DocumentOuvrier findMany
   */
  export type DocumentOuvrierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * Filter, which DocumentOuvriers to fetch.
     */
    where?: DocumentOuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentOuvriers to fetch.
     */
    orderBy?: DocumentOuvrierOrderByWithRelationInput | DocumentOuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentOuvriers.
     */
    cursor?: DocumentOuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentOuvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentOuvriers.
     */
    skip?: number
    distinct?: DocumentOuvrierScalarFieldEnum | DocumentOuvrierScalarFieldEnum[]
  }

  /**
   * DocumentOuvrier create
   */
  export type DocumentOuvrierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentOuvrier.
     */
    data: XOR<DocumentOuvrierCreateInput, DocumentOuvrierUncheckedCreateInput>
  }

  /**
   * DocumentOuvrier createMany
   */
  export type DocumentOuvrierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentOuvriers.
     */
    data: DocumentOuvrierCreateManyInput | DocumentOuvrierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentOuvrier update
   */
  export type DocumentOuvrierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentOuvrier.
     */
    data: XOR<DocumentOuvrierUpdateInput, DocumentOuvrierUncheckedUpdateInput>
    /**
     * Choose, which DocumentOuvrier to update.
     */
    where: DocumentOuvrierWhereUniqueInput
  }

  /**
   * DocumentOuvrier updateMany
   */
  export type DocumentOuvrierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentOuvriers.
     */
    data: XOR<DocumentOuvrierUpdateManyMutationInput, DocumentOuvrierUncheckedUpdateManyInput>
    /**
     * Filter which DocumentOuvriers to update
     */
    where?: DocumentOuvrierWhereInput
    /**
     * Limit how many DocumentOuvriers to update.
     */
    limit?: number
  }

  /**
   * DocumentOuvrier upsert
   */
  export type DocumentOuvrierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentOuvrier to update in case it exists.
     */
    where: DocumentOuvrierWhereUniqueInput
    /**
     * In case the DocumentOuvrier found by the `where` argument doesn't exist, create a new DocumentOuvrier with this data.
     */
    create: XOR<DocumentOuvrierCreateInput, DocumentOuvrierUncheckedCreateInput>
    /**
     * In case the DocumentOuvrier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentOuvrierUpdateInput, DocumentOuvrierUncheckedUpdateInput>
  }

  /**
   * DocumentOuvrier delete
   */
  export type DocumentOuvrierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    /**
     * Filter which DocumentOuvrier to delete.
     */
    where: DocumentOuvrierWhereUniqueInput
  }

  /**
   * DocumentOuvrier deleteMany
   */
  export type DocumentOuvrierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentOuvriers to delete
     */
    where?: DocumentOuvrierWhereInput
    /**
     * Limit how many DocumentOuvriers to delete.
     */
    limit?: number
  }

  /**
   * DocumentOuvrier without action
   */
  export type DocumentOuvrierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
  }


  /**
   * Model Etat
   */

  export type AggregateEtat = {
    _count: EtatCountAggregateOutputType | null
    _avg: EtatAvgAggregateOutputType | null
    _sum: EtatSumAggregateOutputType | null
    _min: EtatMinAggregateOutputType | null
    _max: EtatMaxAggregateOutputType | null
  }

  export type EtatAvgAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type EtatSumAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type EtatMinAggregateOutputType = {
    id: number | null
    numero: number | null
    date: Date | null
    chantierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EtatMaxAggregateOutputType = {
    id: number | null
    numero: number | null
    date: Date | null
    chantierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EtatCountAggregateOutputType = {
    id: number
    numero: number
    date: number
    chantierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EtatAvgAggregateInputType = {
    id?: true
    numero?: true
  }

  export type EtatSumAggregateInputType = {
    id?: true
    numero?: true
  }

  export type EtatMinAggregateInputType = {
    id?: true
    numero?: true
    date?: true
    chantierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EtatMaxAggregateInputType = {
    id?: true
    numero?: true
    date?: true
    chantierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EtatCountAggregateInputType = {
    id?: true
    numero?: true
    date?: true
    chantierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EtatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etat to aggregate.
     */
    where?: EtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etats to fetch.
     */
    orderBy?: EtatOrderByWithRelationInput | EtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etats
    **/
    _count?: true | EtatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtatMaxAggregateInputType
  }

  export type GetEtatAggregateType<T extends EtatAggregateArgs> = {
        [P in keyof T & keyof AggregateEtat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtat[P]>
      : GetScalarType<T[P], AggregateEtat[P]>
  }




  export type EtatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtatWhereInput
    orderBy?: EtatOrderByWithAggregationInput | EtatOrderByWithAggregationInput[]
    by: EtatScalarFieldEnum[] | EtatScalarFieldEnum
    having?: EtatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtatCountAggregateInputType | true
    _avg?: EtatAvgAggregateInputType
    _sum?: EtatSumAggregateInputType
    _min?: EtatMinAggregateInputType
    _max?: EtatMaxAggregateInputType
  }

  export type EtatGroupByOutputType = {
    id: number
    numero: number
    date: Date
    chantierId: string
    createdAt: Date
    updatedAt: Date
    _count: EtatCountAggregateOutputType | null
    _avg: EtatAvgAggregateOutputType | null
    _sum: EtatSumAggregateOutputType | null
    _min: EtatMinAggregateOutputType | null
    _max: EtatMaxAggregateOutputType | null
  }

  type GetEtatGroupByPayload<T extends EtatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtatGroupByOutputType[P]>
            : GetScalarType<T[P], EtatGroupByOutputType[P]>
        }
      >
    >


  export type EtatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    date?: boolean
    chantierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    LigneEtat?: boolean | Etat$LigneEtatArgs<ExtArgs>
    _count?: boolean | EtatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etat"]>



  export type EtatSelectScalar = {
    id?: boolean
    numero?: boolean
    date?: boolean
    chantierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EtatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numero" | "date" | "chantierId" | "createdAt" | "updatedAt", ExtArgs["result"]["etat"]>
  export type EtatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    LigneEtat?: boolean | Etat$LigneEtatArgs<ExtArgs>
    _count?: boolean | EtatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EtatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etat"
    objects: {
      Chantier: Prisma.$ChantierPayload<ExtArgs>
      LigneEtat: Prisma.$LigneEtatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numero: number
      date: Date
      chantierId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["etat"]>
    composites: {}
  }

  type EtatGetPayload<S extends boolean | null | undefined | EtatDefaultArgs> = $Result.GetResult<Prisma.$EtatPayload, S>

  type EtatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EtatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtatCountAggregateInputType | true
    }

  export interface EtatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etat'], meta: { name: 'Etat' } }
    /**
     * Find zero or one Etat that matches the filter.
     * @param {EtatFindUniqueArgs} args - Arguments to find a Etat
     * @example
     * // Get one Etat
     * const etat = await prisma.etat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtatFindUniqueArgs>(args: SelectSubset<T, EtatFindUniqueArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Etat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EtatFindUniqueOrThrowArgs} args - Arguments to find a Etat
     * @example
     * // Get one Etat
     * const etat = await prisma.etat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtatFindUniqueOrThrowArgs>(args: SelectSubset<T, EtatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatFindFirstArgs} args - Arguments to find a Etat
     * @example
     * // Get one Etat
     * const etat = await prisma.etat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtatFindFirstArgs>(args?: SelectSubset<T, EtatFindFirstArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatFindFirstOrThrowArgs} args - Arguments to find a Etat
     * @example
     * // Get one Etat
     * const etat = await prisma.etat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtatFindFirstOrThrowArgs>(args?: SelectSubset<T, EtatFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Etats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etats
     * const etats = await prisma.etat.findMany()
     * 
     * // Get first 10 Etats
     * const etats = await prisma.etat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etatWithIdOnly = await prisma.etat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EtatFindManyArgs>(args?: SelectSubset<T, EtatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Etat.
     * @param {EtatCreateArgs} args - Arguments to create a Etat.
     * @example
     * // Create one Etat
     * const Etat = await prisma.etat.create({
     *   data: {
     *     // ... data to create a Etat
     *   }
     * })
     * 
     */
    create<T extends EtatCreateArgs>(args: SelectSubset<T, EtatCreateArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Etats.
     * @param {EtatCreateManyArgs} args - Arguments to create many Etats.
     * @example
     * // Create many Etats
     * const etat = await prisma.etat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtatCreateManyArgs>(args?: SelectSubset<T, EtatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etat.
     * @param {EtatDeleteArgs} args - Arguments to delete one Etat.
     * @example
     * // Delete one Etat
     * const Etat = await prisma.etat.delete({
     *   where: {
     *     // ... filter to delete one Etat
     *   }
     * })
     * 
     */
    delete<T extends EtatDeleteArgs>(args: SelectSubset<T, EtatDeleteArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Etat.
     * @param {EtatUpdateArgs} args - Arguments to update one Etat.
     * @example
     * // Update one Etat
     * const etat = await prisma.etat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtatUpdateArgs>(args: SelectSubset<T, EtatUpdateArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Etats.
     * @param {EtatDeleteManyArgs} args - Arguments to filter Etats to delete.
     * @example
     * // Delete a few Etats
     * const { count } = await prisma.etat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtatDeleteManyArgs>(args?: SelectSubset<T, EtatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etats
     * const etat = await prisma.etat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtatUpdateManyArgs>(args: SelectSubset<T, EtatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etat.
     * @param {EtatUpsertArgs} args - Arguments to update or create a Etat.
     * @example
     * // Update or create a Etat
     * const etat = await prisma.etat.upsert({
     *   create: {
     *     // ... data to create a Etat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etat we want to update
     *   }
     * })
     */
    upsert<T extends EtatUpsertArgs>(args: SelectSubset<T, EtatUpsertArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Etats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatCountArgs} args - Arguments to filter Etats to count.
     * @example
     * // Count the number of Etats
     * const count = await prisma.etat.count({
     *   where: {
     *     // ... the filter for the Etats we want to count
     *   }
     * })
    **/
    count<T extends EtatCountArgs>(
      args?: Subset<T, EtatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtatAggregateArgs>(args: Subset<T, EtatAggregateArgs>): Prisma.PrismaPromise<GetEtatAggregateType<T>>

    /**
     * Group by Etat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtatGroupByArgs['orderBy'] }
        : { orderBy?: EtatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etat model
   */
  readonly fields: EtatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LigneEtat<T extends Etat$LigneEtatArgs<ExtArgs> = {}>(args?: Subset<T, Etat$LigneEtatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Etat model
   */ 
  interface EtatFieldRefs {
    readonly id: FieldRef<"Etat", 'Int'>
    readonly numero: FieldRef<"Etat", 'Int'>
    readonly date: FieldRef<"Etat", 'DateTime'>
    readonly chantierId: FieldRef<"Etat", 'String'>
    readonly createdAt: FieldRef<"Etat", 'DateTime'>
    readonly updatedAt: FieldRef<"Etat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Etat findUnique
   */
  export type EtatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * Filter, which Etat to fetch.
     */
    where: EtatWhereUniqueInput
  }

  /**
   * Etat findUniqueOrThrow
   */
  export type EtatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * Filter, which Etat to fetch.
     */
    where: EtatWhereUniqueInput
  }

  /**
   * Etat findFirst
   */
  export type EtatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * Filter, which Etat to fetch.
     */
    where?: EtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etats to fetch.
     */
    orderBy?: EtatOrderByWithRelationInput | EtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etats.
     */
    cursor?: EtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etats.
     */
    distinct?: EtatScalarFieldEnum | EtatScalarFieldEnum[]
  }

  /**
   * Etat findFirstOrThrow
   */
  export type EtatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * Filter, which Etat to fetch.
     */
    where?: EtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etats to fetch.
     */
    orderBy?: EtatOrderByWithRelationInput | EtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etats.
     */
    cursor?: EtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etats.
     */
    distinct?: EtatScalarFieldEnum | EtatScalarFieldEnum[]
  }

  /**
   * Etat findMany
   */
  export type EtatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * Filter, which Etats to fetch.
     */
    where?: EtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etats to fetch.
     */
    orderBy?: EtatOrderByWithRelationInput | EtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etats.
     */
    cursor?: EtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etats.
     */
    skip?: number
    distinct?: EtatScalarFieldEnum | EtatScalarFieldEnum[]
  }

  /**
   * Etat create
   */
  export type EtatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * The data needed to create a Etat.
     */
    data: XOR<EtatCreateInput, EtatUncheckedCreateInput>
  }

  /**
   * Etat createMany
   */
  export type EtatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etats.
     */
    data: EtatCreateManyInput | EtatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Etat update
   */
  export type EtatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * The data needed to update a Etat.
     */
    data: XOR<EtatUpdateInput, EtatUncheckedUpdateInput>
    /**
     * Choose, which Etat to update.
     */
    where: EtatWhereUniqueInput
  }

  /**
   * Etat updateMany
   */
  export type EtatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etats.
     */
    data: XOR<EtatUpdateManyMutationInput, EtatUncheckedUpdateManyInput>
    /**
     * Filter which Etats to update
     */
    where?: EtatWhereInput
    /**
     * Limit how many Etats to update.
     */
    limit?: number
  }

  /**
   * Etat upsert
   */
  export type EtatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * The filter to search for the Etat to update in case it exists.
     */
    where: EtatWhereUniqueInput
    /**
     * In case the Etat found by the `where` argument doesn't exist, create a new Etat with this data.
     */
    create: XOR<EtatCreateInput, EtatUncheckedCreateInput>
    /**
     * In case the Etat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtatUpdateInput, EtatUncheckedUpdateInput>
  }

  /**
   * Etat delete
   */
  export type EtatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
    /**
     * Filter which Etat to delete.
     */
    where: EtatWhereUniqueInput
  }

  /**
   * Etat deleteMany
   */
  export type EtatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etats to delete
     */
    where?: EtatWhereInput
    /**
     * Limit how many Etats to delete.
     */
    limit?: number
  }

  /**
   * Etat.LigneEtat
   */
  export type Etat$LigneEtatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    where?: LigneEtatWhereInput
    orderBy?: LigneEtatOrderByWithRelationInput | LigneEtatOrderByWithRelationInput[]
    cursor?: LigneEtatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneEtatScalarFieldEnum | LigneEtatScalarFieldEnum[]
  }

  /**
   * Etat without action
   */
  export type EtatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etat
     */
    select?: EtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etat
     */
    omit?: EtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtatInclude<ExtArgs> | null
  }


  /**
   * Model LigneEtat
   */

  export type AggregateLigneEtat = {
    _count: LigneEtatCountAggregateOutputType | null
    _avg: LigneEtatAvgAggregateOutputType | null
    _sum: LigneEtatSumAggregateOutputType | null
    _min: LigneEtatMinAggregateOutputType | null
    _max: LigneEtatMaxAggregateOutputType | null
  }

  export type LigneEtatAvgAggregateOutputType = {
    id: number | null
    etatId: number | null
    ligneMarcheId: number | null
    quantite: number | null
  }

  export type LigneEtatSumAggregateOutputType = {
    id: number | null
    etatId: number | null
    ligneMarcheId: number | null
    quantite: number | null
  }

  export type LigneEtatMinAggregateOutputType = {
    id: number | null
    etatId: number | null
    ligneMarcheId: number | null
    quantite: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneEtatMaxAggregateOutputType = {
    id: number | null
    etatId: number | null
    ligneMarcheId: number | null
    quantite: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneEtatCountAggregateOutputType = {
    id: number
    etatId: number
    ligneMarcheId: number
    quantite: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LigneEtatAvgAggregateInputType = {
    id?: true
    etatId?: true
    ligneMarcheId?: true
    quantite?: true
  }

  export type LigneEtatSumAggregateInputType = {
    id?: true
    etatId?: true
    ligneMarcheId?: true
    quantite?: true
  }

  export type LigneEtatMinAggregateInputType = {
    id?: true
    etatId?: true
    ligneMarcheId?: true
    quantite?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneEtatMaxAggregateInputType = {
    id?: true
    etatId?: true
    ligneMarcheId?: true
    quantite?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneEtatCountAggregateInputType = {
    id?: true
    etatId?: true
    ligneMarcheId?: true
    quantite?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LigneEtatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneEtat to aggregate.
     */
    where?: LigneEtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtats to fetch.
     */
    orderBy?: LigneEtatOrderByWithRelationInput | LigneEtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneEtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneEtats
    **/
    _count?: true | LigneEtatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneEtatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneEtatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneEtatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneEtatMaxAggregateInputType
  }

  export type GetLigneEtatAggregateType<T extends LigneEtatAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneEtat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneEtat[P]>
      : GetScalarType<T[P], AggregateLigneEtat[P]>
  }




  export type LigneEtatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneEtatWhereInput
    orderBy?: LigneEtatOrderByWithAggregationInput | LigneEtatOrderByWithAggregationInput[]
    by: LigneEtatScalarFieldEnum[] | LigneEtatScalarFieldEnum
    having?: LigneEtatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneEtatCountAggregateInputType | true
    _avg?: LigneEtatAvgAggregateInputType
    _sum?: LigneEtatSumAggregateInputType
    _min?: LigneEtatMinAggregateInputType
    _max?: LigneEtatMaxAggregateInputType
  }

  export type LigneEtatGroupByOutputType = {
    id: number
    etatId: number
    ligneMarcheId: number
    quantite: number
    createdAt: Date
    updatedAt: Date
    _count: LigneEtatCountAggregateOutputType | null
    _avg: LigneEtatAvgAggregateOutputType | null
    _sum: LigneEtatSumAggregateOutputType | null
    _min: LigneEtatMinAggregateOutputType | null
    _max: LigneEtatMaxAggregateOutputType | null
  }

  type GetLigneEtatGroupByPayload<T extends LigneEtatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneEtatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneEtatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneEtatGroupByOutputType[P]>
            : GetScalarType<T[P], LigneEtatGroupByOutputType[P]>
        }
      >
    >


  export type LigneEtatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    etatId?: boolean
    ligneMarcheId?: boolean
    quantite?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Etat?: boolean | EtatDefaultArgs<ExtArgs>
    LigneMarche?: boolean | LigneMarcheDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneEtat"]>



  export type LigneEtatSelectScalar = {
    id?: boolean
    etatId?: boolean
    ligneMarcheId?: boolean
    quantite?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LigneEtatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "etatId" | "ligneMarcheId" | "quantite" | "createdAt" | "updatedAt", ExtArgs["result"]["ligneEtat"]>
  export type LigneEtatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Etat?: boolean | EtatDefaultArgs<ExtArgs>
    LigneMarche?: boolean | LigneMarcheDefaultArgs<ExtArgs>
  }

  export type $LigneEtatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneEtat"
    objects: {
      Etat: Prisma.$EtatPayload<ExtArgs>
      LigneMarche: Prisma.$LigneMarchePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      etatId: number
      ligneMarcheId: number
      quantite: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ligneEtat"]>
    composites: {}
  }

  type LigneEtatGetPayload<S extends boolean | null | undefined | LigneEtatDefaultArgs> = $Result.GetResult<Prisma.$LigneEtatPayload, S>

  type LigneEtatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneEtatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneEtatCountAggregateInputType | true
    }

  export interface LigneEtatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneEtat'], meta: { name: 'LigneEtat' } }
    /**
     * Find zero or one LigneEtat that matches the filter.
     * @param {LigneEtatFindUniqueArgs} args - Arguments to find a LigneEtat
     * @example
     * // Get one LigneEtat
     * const ligneEtat = await prisma.ligneEtat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneEtatFindUniqueArgs>(args: SelectSubset<T, LigneEtatFindUniqueArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LigneEtat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneEtatFindUniqueOrThrowArgs} args - Arguments to find a LigneEtat
     * @example
     * // Get one LigneEtat
     * const ligneEtat = await prisma.ligneEtat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneEtatFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneEtatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneEtat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatFindFirstArgs} args - Arguments to find a LigneEtat
     * @example
     * // Get one LigneEtat
     * const ligneEtat = await prisma.ligneEtat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneEtatFindFirstArgs>(args?: SelectSubset<T, LigneEtatFindFirstArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneEtat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatFindFirstOrThrowArgs} args - Arguments to find a LigneEtat
     * @example
     * // Get one LigneEtat
     * const ligneEtat = await prisma.ligneEtat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneEtatFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneEtatFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LigneEtats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneEtats
     * const ligneEtats = await prisma.ligneEtat.findMany()
     * 
     * // Get first 10 LigneEtats
     * const ligneEtats = await prisma.ligneEtat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneEtatWithIdOnly = await prisma.ligneEtat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneEtatFindManyArgs>(args?: SelectSubset<T, LigneEtatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LigneEtat.
     * @param {LigneEtatCreateArgs} args - Arguments to create a LigneEtat.
     * @example
     * // Create one LigneEtat
     * const LigneEtat = await prisma.ligneEtat.create({
     *   data: {
     *     // ... data to create a LigneEtat
     *   }
     * })
     * 
     */
    create<T extends LigneEtatCreateArgs>(args: SelectSubset<T, LigneEtatCreateArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LigneEtats.
     * @param {LigneEtatCreateManyArgs} args - Arguments to create many LigneEtats.
     * @example
     * // Create many LigneEtats
     * const ligneEtat = await prisma.ligneEtat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneEtatCreateManyArgs>(args?: SelectSubset<T, LigneEtatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LigneEtat.
     * @param {LigneEtatDeleteArgs} args - Arguments to delete one LigneEtat.
     * @example
     * // Delete one LigneEtat
     * const LigneEtat = await prisma.ligneEtat.delete({
     *   where: {
     *     // ... filter to delete one LigneEtat
     *   }
     * })
     * 
     */
    delete<T extends LigneEtatDeleteArgs>(args: SelectSubset<T, LigneEtatDeleteArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LigneEtat.
     * @param {LigneEtatUpdateArgs} args - Arguments to update one LigneEtat.
     * @example
     * // Update one LigneEtat
     * const ligneEtat = await prisma.ligneEtat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneEtatUpdateArgs>(args: SelectSubset<T, LigneEtatUpdateArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LigneEtats.
     * @param {LigneEtatDeleteManyArgs} args - Arguments to filter LigneEtats to delete.
     * @example
     * // Delete a few LigneEtats
     * const { count } = await prisma.ligneEtat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneEtatDeleteManyArgs>(args?: SelectSubset<T, LigneEtatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneEtats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneEtats
     * const ligneEtat = await prisma.ligneEtat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneEtatUpdateManyArgs>(args: SelectSubset<T, LigneEtatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneEtat.
     * @param {LigneEtatUpsertArgs} args - Arguments to update or create a LigneEtat.
     * @example
     * // Update or create a LigneEtat
     * const ligneEtat = await prisma.ligneEtat.upsert({
     *   create: {
     *     // ... data to create a LigneEtat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneEtat we want to update
     *   }
     * })
     */
    upsert<T extends LigneEtatUpsertArgs>(args: SelectSubset<T, LigneEtatUpsertArgs<ExtArgs>>): Prisma__LigneEtatClient<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LigneEtats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatCountArgs} args - Arguments to filter LigneEtats to count.
     * @example
     * // Count the number of LigneEtats
     * const count = await prisma.ligneEtat.count({
     *   where: {
     *     // ... the filter for the LigneEtats we want to count
     *   }
     * })
    **/
    count<T extends LigneEtatCountArgs>(
      args?: Subset<T, LigneEtatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneEtatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneEtat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneEtatAggregateArgs>(args: Subset<T, LigneEtatAggregateArgs>): Prisma.PrismaPromise<GetLigneEtatAggregateType<T>>

    /**
     * Group by LigneEtat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneEtatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneEtatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneEtatGroupByArgs['orderBy'] }
        : { orderBy?: LigneEtatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneEtatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneEtatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneEtat model
   */
  readonly fields: LigneEtatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneEtat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneEtatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Etat<T extends EtatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtatDefaultArgs<ExtArgs>>): Prisma__EtatClient<$Result.GetResult<Prisma.$EtatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LigneMarche<T extends LigneMarcheDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LigneMarcheDefaultArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneEtat model
   */ 
  interface LigneEtatFieldRefs {
    readonly id: FieldRef<"LigneEtat", 'Int'>
    readonly etatId: FieldRef<"LigneEtat", 'Int'>
    readonly ligneMarcheId: FieldRef<"LigneEtat", 'Int'>
    readonly quantite: FieldRef<"LigneEtat", 'Float'>
    readonly createdAt: FieldRef<"LigneEtat", 'DateTime'>
    readonly updatedAt: FieldRef<"LigneEtat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneEtat findUnique
   */
  export type LigneEtatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtat to fetch.
     */
    where: LigneEtatWhereUniqueInput
  }

  /**
   * LigneEtat findUniqueOrThrow
   */
  export type LigneEtatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtat to fetch.
     */
    where: LigneEtatWhereUniqueInput
  }

  /**
   * LigneEtat findFirst
   */
  export type LigneEtatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtat to fetch.
     */
    where?: LigneEtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtats to fetch.
     */
    orderBy?: LigneEtatOrderByWithRelationInput | LigneEtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneEtats.
     */
    cursor?: LigneEtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneEtats.
     */
    distinct?: LigneEtatScalarFieldEnum | LigneEtatScalarFieldEnum[]
  }

  /**
   * LigneEtat findFirstOrThrow
   */
  export type LigneEtatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtat to fetch.
     */
    where?: LigneEtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtats to fetch.
     */
    orderBy?: LigneEtatOrderByWithRelationInput | LigneEtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneEtats.
     */
    cursor?: LigneEtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneEtats.
     */
    distinct?: LigneEtatScalarFieldEnum | LigneEtatScalarFieldEnum[]
  }

  /**
   * LigneEtat findMany
   */
  export type LigneEtatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * Filter, which LigneEtats to fetch.
     */
    where?: LigneEtatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneEtats to fetch.
     */
    orderBy?: LigneEtatOrderByWithRelationInput | LigneEtatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneEtats.
     */
    cursor?: LigneEtatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneEtats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneEtats.
     */
    skip?: number
    distinct?: LigneEtatScalarFieldEnum | LigneEtatScalarFieldEnum[]
  }

  /**
   * LigneEtat create
   */
  export type LigneEtatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneEtat.
     */
    data: XOR<LigneEtatCreateInput, LigneEtatUncheckedCreateInput>
  }

  /**
   * LigneEtat createMany
   */
  export type LigneEtatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneEtats.
     */
    data: LigneEtatCreateManyInput | LigneEtatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneEtat update
   */
  export type LigneEtatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneEtat.
     */
    data: XOR<LigneEtatUpdateInput, LigneEtatUncheckedUpdateInput>
    /**
     * Choose, which LigneEtat to update.
     */
    where: LigneEtatWhereUniqueInput
  }

  /**
   * LigneEtat updateMany
   */
  export type LigneEtatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneEtats.
     */
    data: XOR<LigneEtatUpdateManyMutationInput, LigneEtatUncheckedUpdateManyInput>
    /**
     * Filter which LigneEtats to update
     */
    where?: LigneEtatWhereInput
    /**
     * Limit how many LigneEtats to update.
     */
    limit?: number
  }

  /**
   * LigneEtat upsert
   */
  export type LigneEtatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneEtat to update in case it exists.
     */
    where: LigneEtatWhereUniqueInput
    /**
     * In case the LigneEtat found by the `where` argument doesn't exist, create a new LigneEtat with this data.
     */
    create: XOR<LigneEtatCreateInput, LigneEtatUncheckedCreateInput>
    /**
     * In case the LigneEtat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneEtatUpdateInput, LigneEtatUncheckedUpdateInput>
  }

  /**
   * LigneEtat delete
   */
  export type LigneEtatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    /**
     * Filter which LigneEtat to delete.
     */
    where: LigneEtatWhereUniqueInput
  }

  /**
   * LigneEtat deleteMany
   */
  export type LigneEtatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneEtats to delete
     */
    where?: LigneEtatWhereInput
    /**
     * Limit how many LigneEtats to delete.
     */
    limit?: number
  }

  /**
   * LigneEtat without action
   */
  export type LigneEtatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
  }


  /**
   * Model LigneMarche
   */

  export type AggregateLigneMarche = {
    _count: LigneMarcheCountAggregateOutputType | null
    _avg: LigneMarcheAvgAggregateOutputType | null
    _sum: LigneMarcheSumAggregateOutputType | null
    _min: LigneMarcheMinAggregateOutputType | null
    _max: LigneMarcheMaxAggregateOutputType | null
  }

  export type LigneMarcheAvgAggregateOutputType = {
    id: number | null
    article: number | null
    quantite: number | null
    prixUnitaire: number | null
    marcheId: number | null
  }

  export type LigneMarcheSumAggregateOutputType = {
    id: number | null
    article: number | null
    quantite: number | null
    prixUnitaire: number | null
    marcheId: number | null
  }

  export type LigneMarcheMinAggregateOutputType = {
    id: number | null
    article: number | null
    descriptif: string | null
    unite: string | null
    quantite: number | null
    prixUnitaire: number | null
    marcheId: number | null
  }

  export type LigneMarcheMaxAggregateOutputType = {
    id: number | null
    article: number | null
    descriptif: string | null
    unite: string | null
    quantite: number | null
    prixUnitaire: number | null
    marcheId: number | null
  }

  export type LigneMarcheCountAggregateOutputType = {
    id: number
    article: number
    descriptif: number
    unite: number
    quantite: number
    prixUnitaire: number
    marcheId: number
    _all: number
  }


  export type LigneMarcheAvgAggregateInputType = {
    id?: true
    article?: true
    quantite?: true
    prixUnitaire?: true
    marcheId?: true
  }

  export type LigneMarcheSumAggregateInputType = {
    id?: true
    article?: true
    quantite?: true
    prixUnitaire?: true
    marcheId?: true
  }

  export type LigneMarcheMinAggregateInputType = {
    id?: true
    article?: true
    descriptif?: true
    unite?: true
    quantite?: true
    prixUnitaire?: true
    marcheId?: true
  }

  export type LigneMarcheMaxAggregateInputType = {
    id?: true
    article?: true
    descriptif?: true
    unite?: true
    quantite?: true
    prixUnitaire?: true
    marcheId?: true
  }

  export type LigneMarcheCountAggregateInputType = {
    id?: true
    article?: true
    descriptif?: true
    unite?: true
    quantite?: true
    prixUnitaire?: true
    marcheId?: true
    _all?: true
  }

  export type LigneMarcheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneMarche to aggregate.
     */
    where?: LigneMarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneMarches to fetch.
     */
    orderBy?: LigneMarcheOrderByWithRelationInput | LigneMarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneMarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneMarches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneMarches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneMarches
    **/
    _count?: true | LigneMarcheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneMarcheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneMarcheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneMarcheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneMarcheMaxAggregateInputType
  }

  export type GetLigneMarcheAggregateType<T extends LigneMarcheAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneMarche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneMarche[P]>
      : GetScalarType<T[P], AggregateLigneMarche[P]>
  }




  export type LigneMarcheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneMarcheWhereInput
    orderBy?: LigneMarcheOrderByWithAggregationInput | LigneMarcheOrderByWithAggregationInput[]
    by: LigneMarcheScalarFieldEnum[] | LigneMarcheScalarFieldEnum
    having?: LigneMarcheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneMarcheCountAggregateInputType | true
    _avg?: LigneMarcheAvgAggregateInputType
    _sum?: LigneMarcheSumAggregateInputType
    _min?: LigneMarcheMinAggregateInputType
    _max?: LigneMarcheMaxAggregateInputType
  }

  export type LigneMarcheGroupByOutputType = {
    id: number
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    marcheId: number
    _count: LigneMarcheCountAggregateOutputType | null
    _avg: LigneMarcheAvgAggregateOutputType | null
    _sum: LigneMarcheSumAggregateOutputType | null
    _min: LigneMarcheMinAggregateOutputType | null
    _max: LigneMarcheMaxAggregateOutputType | null
  }

  type GetLigneMarcheGroupByPayload<T extends LigneMarcheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneMarcheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneMarcheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneMarcheGroupByOutputType[P]>
            : GetScalarType<T[P], LigneMarcheGroupByOutputType[P]>
        }
      >
    >


  export type LigneMarcheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    article?: boolean
    descriptif?: boolean
    unite?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    marcheId?: boolean
    LigneEtat?: boolean | LigneMarche$LigneEtatArgs<ExtArgs>
    Marche?: boolean | MarcheDefaultArgs<ExtArgs>
    _count?: boolean | LigneMarcheCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneMarche"]>



  export type LigneMarcheSelectScalar = {
    id?: boolean
    article?: boolean
    descriptif?: boolean
    unite?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    marcheId?: boolean
  }

  export type LigneMarcheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "article" | "descriptif" | "unite" | "quantite" | "prixUnitaire" | "marcheId", ExtArgs["result"]["ligneMarche"]>
  export type LigneMarcheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LigneEtat?: boolean | LigneMarche$LigneEtatArgs<ExtArgs>
    Marche?: boolean | MarcheDefaultArgs<ExtArgs>
    _count?: boolean | LigneMarcheCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LigneMarchePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneMarche"
    objects: {
      LigneEtat: Prisma.$LigneEtatPayload<ExtArgs>[]
      Marche: Prisma.$MarchePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      article: number
      descriptif: string
      unite: string
      quantite: number
      prixUnitaire: number
      marcheId: number
    }, ExtArgs["result"]["ligneMarche"]>
    composites: {}
  }

  type LigneMarcheGetPayload<S extends boolean | null | undefined | LigneMarcheDefaultArgs> = $Result.GetResult<Prisma.$LigneMarchePayload, S>

  type LigneMarcheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneMarcheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneMarcheCountAggregateInputType | true
    }

  export interface LigneMarcheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneMarche'], meta: { name: 'LigneMarche' } }
    /**
     * Find zero or one LigneMarche that matches the filter.
     * @param {LigneMarcheFindUniqueArgs} args - Arguments to find a LigneMarche
     * @example
     * // Get one LigneMarche
     * const ligneMarche = await prisma.ligneMarche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneMarcheFindUniqueArgs>(args: SelectSubset<T, LigneMarcheFindUniqueArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LigneMarche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneMarcheFindUniqueOrThrowArgs} args - Arguments to find a LigneMarche
     * @example
     * // Get one LigneMarche
     * const ligneMarche = await prisma.ligneMarche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneMarcheFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneMarcheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneMarche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheFindFirstArgs} args - Arguments to find a LigneMarche
     * @example
     * // Get one LigneMarche
     * const ligneMarche = await prisma.ligneMarche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneMarcheFindFirstArgs>(args?: SelectSubset<T, LigneMarcheFindFirstArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LigneMarche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheFindFirstOrThrowArgs} args - Arguments to find a LigneMarche
     * @example
     * // Get one LigneMarche
     * const ligneMarche = await prisma.ligneMarche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneMarcheFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneMarcheFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LigneMarches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneMarches
     * const ligneMarches = await prisma.ligneMarche.findMany()
     * 
     * // Get first 10 LigneMarches
     * const ligneMarches = await prisma.ligneMarche.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneMarcheWithIdOnly = await prisma.ligneMarche.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneMarcheFindManyArgs>(args?: SelectSubset<T, LigneMarcheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LigneMarche.
     * @param {LigneMarcheCreateArgs} args - Arguments to create a LigneMarche.
     * @example
     * // Create one LigneMarche
     * const LigneMarche = await prisma.ligneMarche.create({
     *   data: {
     *     // ... data to create a LigneMarche
     *   }
     * })
     * 
     */
    create<T extends LigneMarcheCreateArgs>(args: SelectSubset<T, LigneMarcheCreateArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LigneMarches.
     * @param {LigneMarcheCreateManyArgs} args - Arguments to create many LigneMarches.
     * @example
     * // Create many LigneMarches
     * const ligneMarche = await prisma.ligneMarche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneMarcheCreateManyArgs>(args?: SelectSubset<T, LigneMarcheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LigneMarche.
     * @param {LigneMarcheDeleteArgs} args - Arguments to delete one LigneMarche.
     * @example
     * // Delete one LigneMarche
     * const LigneMarche = await prisma.ligneMarche.delete({
     *   where: {
     *     // ... filter to delete one LigneMarche
     *   }
     * })
     * 
     */
    delete<T extends LigneMarcheDeleteArgs>(args: SelectSubset<T, LigneMarcheDeleteArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LigneMarche.
     * @param {LigneMarcheUpdateArgs} args - Arguments to update one LigneMarche.
     * @example
     * // Update one LigneMarche
     * const ligneMarche = await prisma.ligneMarche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneMarcheUpdateArgs>(args: SelectSubset<T, LigneMarcheUpdateArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LigneMarches.
     * @param {LigneMarcheDeleteManyArgs} args - Arguments to filter LigneMarches to delete.
     * @example
     * // Delete a few LigneMarches
     * const { count } = await prisma.ligneMarche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneMarcheDeleteManyArgs>(args?: SelectSubset<T, LigneMarcheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneMarches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneMarches
     * const ligneMarche = await prisma.ligneMarche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneMarcheUpdateManyArgs>(args: SelectSubset<T, LigneMarcheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneMarche.
     * @param {LigneMarcheUpsertArgs} args - Arguments to update or create a LigneMarche.
     * @example
     * // Update or create a LigneMarche
     * const ligneMarche = await prisma.ligneMarche.upsert({
     *   create: {
     *     // ... data to create a LigneMarche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneMarche we want to update
     *   }
     * })
     */
    upsert<T extends LigneMarcheUpsertArgs>(args: SelectSubset<T, LigneMarcheUpsertArgs<ExtArgs>>): Prisma__LigneMarcheClient<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LigneMarches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheCountArgs} args - Arguments to filter LigneMarches to count.
     * @example
     * // Count the number of LigneMarches
     * const count = await prisma.ligneMarche.count({
     *   where: {
     *     // ... the filter for the LigneMarches we want to count
     *   }
     * })
    **/
    count<T extends LigneMarcheCountArgs>(
      args?: Subset<T, LigneMarcheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneMarcheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneMarche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneMarcheAggregateArgs>(args: Subset<T, LigneMarcheAggregateArgs>): Prisma.PrismaPromise<GetLigneMarcheAggregateType<T>>

    /**
     * Group by LigneMarche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneMarcheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneMarcheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneMarcheGroupByArgs['orderBy'] }
        : { orderBy?: LigneMarcheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneMarcheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneMarcheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneMarche model
   */
  readonly fields: LigneMarcheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneMarche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneMarcheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    LigneEtat<T extends LigneMarche$LigneEtatArgs<ExtArgs> = {}>(args?: Subset<T, LigneMarche$LigneEtatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneEtatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Marche<T extends MarcheDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarcheDefaultArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneMarche model
   */ 
  interface LigneMarcheFieldRefs {
    readonly id: FieldRef<"LigneMarche", 'Int'>
    readonly article: FieldRef<"LigneMarche", 'Int'>
    readonly descriptif: FieldRef<"LigneMarche", 'String'>
    readonly unite: FieldRef<"LigneMarche", 'String'>
    readonly quantite: FieldRef<"LigneMarche", 'Float'>
    readonly prixUnitaire: FieldRef<"LigneMarche", 'Float'>
    readonly marcheId: FieldRef<"LigneMarche", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LigneMarche findUnique
   */
  export type LigneMarcheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * Filter, which LigneMarche to fetch.
     */
    where: LigneMarcheWhereUniqueInput
  }

  /**
   * LigneMarche findUniqueOrThrow
   */
  export type LigneMarcheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * Filter, which LigneMarche to fetch.
     */
    where: LigneMarcheWhereUniqueInput
  }

  /**
   * LigneMarche findFirst
   */
  export type LigneMarcheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * Filter, which LigneMarche to fetch.
     */
    where?: LigneMarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneMarches to fetch.
     */
    orderBy?: LigneMarcheOrderByWithRelationInput | LigneMarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneMarches.
     */
    cursor?: LigneMarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneMarches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneMarches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneMarches.
     */
    distinct?: LigneMarcheScalarFieldEnum | LigneMarcheScalarFieldEnum[]
  }

  /**
   * LigneMarche findFirstOrThrow
   */
  export type LigneMarcheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * Filter, which LigneMarche to fetch.
     */
    where?: LigneMarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneMarches to fetch.
     */
    orderBy?: LigneMarcheOrderByWithRelationInput | LigneMarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneMarches.
     */
    cursor?: LigneMarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneMarches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneMarches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneMarches.
     */
    distinct?: LigneMarcheScalarFieldEnum | LigneMarcheScalarFieldEnum[]
  }

  /**
   * LigneMarche findMany
   */
  export type LigneMarcheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * Filter, which LigneMarches to fetch.
     */
    where?: LigneMarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneMarches to fetch.
     */
    orderBy?: LigneMarcheOrderByWithRelationInput | LigneMarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneMarches.
     */
    cursor?: LigneMarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneMarches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneMarches.
     */
    skip?: number
    distinct?: LigneMarcheScalarFieldEnum | LigneMarcheScalarFieldEnum[]
  }

  /**
   * LigneMarche create
   */
  export type LigneMarcheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneMarche.
     */
    data: XOR<LigneMarcheCreateInput, LigneMarcheUncheckedCreateInput>
  }

  /**
   * LigneMarche createMany
   */
  export type LigneMarcheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneMarches.
     */
    data: LigneMarcheCreateManyInput | LigneMarcheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneMarche update
   */
  export type LigneMarcheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneMarche.
     */
    data: XOR<LigneMarcheUpdateInput, LigneMarcheUncheckedUpdateInput>
    /**
     * Choose, which LigneMarche to update.
     */
    where: LigneMarcheWhereUniqueInput
  }

  /**
   * LigneMarche updateMany
   */
  export type LigneMarcheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneMarches.
     */
    data: XOR<LigneMarcheUpdateManyMutationInput, LigneMarcheUncheckedUpdateManyInput>
    /**
     * Filter which LigneMarches to update
     */
    where?: LigneMarcheWhereInput
    /**
     * Limit how many LigneMarches to update.
     */
    limit?: number
  }

  /**
   * LigneMarche upsert
   */
  export type LigneMarcheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneMarche to update in case it exists.
     */
    where: LigneMarcheWhereUniqueInput
    /**
     * In case the LigneMarche found by the `where` argument doesn't exist, create a new LigneMarche with this data.
     */
    create: XOR<LigneMarcheCreateInput, LigneMarcheUncheckedCreateInput>
    /**
     * In case the LigneMarche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneMarcheUpdateInput, LigneMarcheUncheckedUpdateInput>
  }

  /**
   * LigneMarche delete
   */
  export type LigneMarcheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    /**
     * Filter which LigneMarche to delete.
     */
    where: LigneMarcheWhereUniqueInput
  }

  /**
   * LigneMarche deleteMany
   */
  export type LigneMarcheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneMarches to delete
     */
    where?: LigneMarcheWhereInput
    /**
     * Limit how many LigneMarches to delete.
     */
    limit?: number
  }

  /**
   * LigneMarche.LigneEtat
   */
  export type LigneMarche$LigneEtatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneEtat
     */
    select?: LigneEtatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneEtat
     */
    omit?: LigneEtatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneEtatInclude<ExtArgs> | null
    where?: LigneEtatWhereInput
    orderBy?: LigneEtatOrderByWithRelationInput | LigneEtatOrderByWithRelationInput[]
    cursor?: LigneEtatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneEtatScalarFieldEnum | LigneEtatScalarFieldEnum[]
  }

  /**
   * LigneMarche without action
   */
  export type LigneMarcheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
  }


  /**
   * Model Machine
   */

  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineMinAggregateOutputType = {
    id: string | null
    nom: string | null
    modele: string | null
    numeroSerie: string | null
    localisation: string | null
    statut: $Enums.Machine_statut | null
    dateAchat: Date | null
    qrCode: string | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    modele: string | null
    numeroSerie: string | null
    localisation: string | null
    statut: $Enums.Machine_statut | null
    dateAchat: Date | null
    qrCode: string | null
    commentaire: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    nom: number
    modele: number
    numeroSerie: number
    localisation: number
    statut: number
    dateAchat: number
    qrCode: number
    commentaire: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MachineMinAggregateInputType = {
    id?: true
    nom?: true
    modele?: true
    numeroSerie?: true
    localisation?: true
    statut?: true
    dateAchat?: true
    qrCode?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    nom?: true
    modele?: true
    numeroSerie?: true
    localisation?: true
    statut?: true
    dateAchat?: true
    qrCode?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    nom?: true
    modele?: true
    numeroSerie?: true
    localisation?: true
    statut?: true
    dateAchat?: true
    qrCode?: true
    commentaire?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithAggregationInput | MachineOrderByWithAggregationInput[]
    by: MachineScalarFieldEnum[] | MachineScalarFieldEnum
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }

  export type MachineGroupByOutputType = {
    id: string
    nom: string
    modele: string
    numeroSerie: string | null
    localisation: string
    statut: $Enums.Machine_statut
    dateAchat: Date | null
    qrCode: string
    commentaire: string | null
    createdAt: Date
    updatedAt: Date
    _count: MachineCountAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    modele?: boolean
    numeroSerie?: boolean
    localisation?: boolean
    statut?: boolean
    dateAchat?: boolean
    qrCode?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pret?: boolean | Machine$pretArgs<ExtArgs>
    _count?: boolean | MachineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>



  export type MachineSelectScalar = {
    id?: boolean
    nom?: boolean
    modele?: boolean
    numeroSerie?: boolean
    localisation?: boolean
    statut?: boolean
    dateAchat?: boolean
    qrCode?: boolean
    commentaire?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MachineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "modele" | "numeroSerie" | "localisation" | "statut" | "dateAchat" | "qrCode" | "commentaire" | "createdAt" | "updatedAt", ExtArgs["result"]["machine"]>
  export type MachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pret?: boolean | Machine$pretArgs<ExtArgs>
    _count?: boolean | MachineCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Machine"
    objects: {
      pret: Prisma.$pretPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      modele: string
      numeroSerie: string | null
      localisation: string
      statut: $Enums.Machine_statut
      dateAchat: Date | null
      qrCode: string
      commentaire: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["machine"]>
    composites: {}
  }

  type MachineGetPayload<S extends boolean | null | undefined | MachineDefaultArgs> = $Result.GetResult<Prisma.$MachinePayload, S>

  type MachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Machine'], meta: { name: 'Machine' } }
    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineFindUniqueArgs>(args: SelectSubset<T, MachineFindUniqueArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Machine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineFindFirstArgs>(args?: SelectSubset<T, MachineFindFirstArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineFindManyArgs>(args?: SelectSubset<T, MachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
     */
    create<T extends MachineCreateArgs>(args: SelectSubset<T, MachineCreateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Machines.
     * @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineCreateManyArgs>(args?: SelectSubset<T, MachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
     */
    delete<T extends MachineDeleteArgs>(args: SelectSubset<T, MachineDeleteArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineUpdateArgs>(args: SelectSubset<T, MachineUpdateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineDeleteManyArgs>(args?: SelectSubset<T, MachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineUpdateManyArgs>(args: SelectSubset<T, MachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
     */
    upsert<T extends MachineUpsertArgs>(args: SelectSubset<T, MachineUpsertArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Machine model
   */
  readonly fields: MachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pret<T extends Machine$pretArgs<ExtArgs> = {}>(args?: Subset<T, Machine$pretArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Machine model
   */ 
  interface MachineFieldRefs {
    readonly id: FieldRef<"Machine", 'String'>
    readonly nom: FieldRef<"Machine", 'String'>
    readonly modele: FieldRef<"Machine", 'String'>
    readonly numeroSerie: FieldRef<"Machine", 'String'>
    readonly localisation: FieldRef<"Machine", 'String'>
    readonly statut: FieldRef<"Machine", 'Machine_statut'>
    readonly dateAchat: FieldRef<"Machine", 'DateTime'>
    readonly qrCode: FieldRef<"Machine", 'String'>
    readonly commentaire: FieldRef<"Machine", 'String'>
    readonly createdAt: FieldRef<"Machine", 'DateTime'>
    readonly updatedAt: FieldRef<"Machine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Machine findUnique
   */
  export type MachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findFirst
   */
  export type MachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findMany
   */
  export type MachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine create
   */
  export type MachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }

  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Machine update
   */
  export type MachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
  }

  /**
   * Machine upsert
   */
  export type MachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }

  /**
   * Machine delete
   */
  export type MachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to delete.
     */
    limit?: number
  }

  /**
   * Machine.pret
   */
  export type Machine$pretArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    where?: pretWhereInput
    orderBy?: pretOrderByWithRelationInput | pretOrderByWithRelationInput[]
    cursor?: pretWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PretScalarFieldEnum | PretScalarFieldEnum[]
  }

  /**
   * Machine without action
   */
  export type MachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
  }


  /**
   * Model Marche
   */

  export type AggregateMarche = {
    _count: MarcheCountAggregateOutputType | null
    _avg: MarcheAvgAggregateOutputType | null
    _sum: MarcheSumAggregateOutputType | null
    _min: MarcheMinAggregateOutputType | null
    _max: MarcheMaxAggregateOutputType | null
  }

  export type MarcheAvgAggregateOutputType = {
    id: number | null
    montantTotal: number | null
  }

  export type MarcheSumAggregateOutputType = {
    id: number | null
    montantTotal: number | null
  }

  export type MarcheMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    dateImport: Date | null
    montantTotal: number | null
  }

  export type MarcheMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    dateImport: Date | null
    montantTotal: number | null
  }

  export type MarcheCountAggregateOutputType = {
    id: number
    chantierId: number
    dateImport: number
    montantTotal: number
    _all: number
  }


  export type MarcheAvgAggregateInputType = {
    id?: true
    montantTotal?: true
  }

  export type MarcheSumAggregateInputType = {
    id?: true
    montantTotal?: true
  }

  export type MarcheMinAggregateInputType = {
    id?: true
    chantierId?: true
    dateImport?: true
    montantTotal?: true
  }

  export type MarcheMaxAggregateInputType = {
    id?: true
    chantierId?: true
    dateImport?: true
    montantTotal?: true
  }

  export type MarcheCountAggregateInputType = {
    id?: true
    chantierId?: true
    dateImport?: true
    montantTotal?: true
    _all?: true
  }

  export type MarcheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marche to aggregate.
     */
    where?: MarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marches to fetch.
     */
    orderBy?: MarcheOrderByWithRelationInput | MarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marches
    **/
    _count?: true | MarcheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarcheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarcheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarcheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarcheMaxAggregateInputType
  }

  export type GetMarcheAggregateType<T extends MarcheAggregateArgs> = {
        [P in keyof T & keyof AggregateMarche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarche[P]>
      : GetScalarType<T[P], AggregateMarche[P]>
  }




  export type MarcheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarcheWhereInput
    orderBy?: MarcheOrderByWithAggregationInput | MarcheOrderByWithAggregationInput[]
    by: MarcheScalarFieldEnum[] | MarcheScalarFieldEnum
    having?: MarcheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarcheCountAggregateInputType | true
    _avg?: MarcheAvgAggregateInputType
    _sum?: MarcheSumAggregateInputType
    _min?: MarcheMinAggregateInputType
    _max?: MarcheMaxAggregateInputType
  }

  export type MarcheGroupByOutputType = {
    id: number
    chantierId: string
    dateImport: Date
    montantTotal: number
    _count: MarcheCountAggregateOutputType | null
    _avg: MarcheAvgAggregateOutputType | null
    _sum: MarcheSumAggregateOutputType | null
    _min: MarcheMinAggregateOutputType | null
    _max: MarcheMaxAggregateOutputType | null
  }

  type GetMarcheGroupByPayload<T extends MarcheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarcheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarcheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarcheGroupByOutputType[P]>
            : GetScalarType<T[P], MarcheGroupByOutputType[P]>
        }
      >
    >


  export type MarcheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    dateImport?: boolean
    montantTotal?: boolean
    Avenant?: boolean | Marche$AvenantArgs<ExtArgs>
    LigneMarche?: boolean | Marche$LigneMarcheArgs<ExtArgs>
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    _count?: boolean | MarcheCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marche"]>



  export type MarcheSelectScalar = {
    id?: boolean
    chantierId?: boolean
    dateImport?: boolean
    montantTotal?: boolean
  }

  export type MarcheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "dateImport" | "montantTotal", ExtArgs["result"]["marche"]>
  export type MarcheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Avenant?: boolean | Marche$AvenantArgs<ExtArgs>
    LigneMarche?: boolean | Marche$LigneMarcheArgs<ExtArgs>
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    _count?: boolean | MarcheCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MarchePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Marche"
    objects: {
      Avenant: Prisma.$AvenantPayload<ExtArgs>[]
      LigneMarche: Prisma.$LigneMarchePayload<ExtArgs>[]
      Chantier: Prisma.$ChantierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      dateImport: Date
      montantTotal: number
    }, ExtArgs["result"]["marche"]>
    composites: {}
  }

  type MarcheGetPayload<S extends boolean | null | undefined | MarcheDefaultArgs> = $Result.GetResult<Prisma.$MarchePayload, S>

  type MarcheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarcheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarcheCountAggregateInputType | true
    }

  export interface MarcheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Marche'], meta: { name: 'Marche' } }
    /**
     * Find zero or one Marche that matches the filter.
     * @param {MarcheFindUniqueArgs} args - Arguments to find a Marche
     * @example
     * // Get one Marche
     * const marche = await prisma.marche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarcheFindUniqueArgs>(args: SelectSubset<T, MarcheFindUniqueArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarcheFindUniqueOrThrowArgs} args - Arguments to find a Marche
     * @example
     * // Get one Marche
     * const marche = await prisma.marche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarcheFindUniqueOrThrowArgs>(args: SelectSubset<T, MarcheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheFindFirstArgs} args - Arguments to find a Marche
     * @example
     * // Get one Marche
     * const marche = await prisma.marche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarcheFindFirstArgs>(args?: SelectSubset<T, MarcheFindFirstArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheFindFirstOrThrowArgs} args - Arguments to find a Marche
     * @example
     * // Get one Marche
     * const marche = await prisma.marche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarcheFindFirstOrThrowArgs>(args?: SelectSubset<T, MarcheFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marches
     * const marches = await prisma.marche.findMany()
     * 
     * // Get first 10 Marches
     * const marches = await prisma.marche.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marcheWithIdOnly = await prisma.marche.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarcheFindManyArgs>(args?: SelectSubset<T, MarcheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marche.
     * @param {MarcheCreateArgs} args - Arguments to create a Marche.
     * @example
     * // Create one Marche
     * const Marche = await prisma.marche.create({
     *   data: {
     *     // ... data to create a Marche
     *   }
     * })
     * 
     */
    create<T extends MarcheCreateArgs>(args: SelectSubset<T, MarcheCreateArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marches.
     * @param {MarcheCreateManyArgs} args - Arguments to create many Marches.
     * @example
     * // Create many Marches
     * const marche = await prisma.marche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarcheCreateManyArgs>(args?: SelectSubset<T, MarcheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Marche.
     * @param {MarcheDeleteArgs} args - Arguments to delete one Marche.
     * @example
     * // Delete one Marche
     * const Marche = await prisma.marche.delete({
     *   where: {
     *     // ... filter to delete one Marche
     *   }
     * })
     * 
     */
    delete<T extends MarcheDeleteArgs>(args: SelectSubset<T, MarcheDeleteArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marche.
     * @param {MarcheUpdateArgs} args - Arguments to update one Marche.
     * @example
     * // Update one Marche
     * const marche = await prisma.marche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarcheUpdateArgs>(args: SelectSubset<T, MarcheUpdateArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marches.
     * @param {MarcheDeleteManyArgs} args - Arguments to filter Marches to delete.
     * @example
     * // Delete a few Marches
     * const { count } = await prisma.marche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarcheDeleteManyArgs>(args?: SelectSubset<T, MarcheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marches
     * const marche = await prisma.marche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarcheUpdateManyArgs>(args: SelectSubset<T, MarcheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marche.
     * @param {MarcheUpsertArgs} args - Arguments to update or create a Marche.
     * @example
     * // Update or create a Marche
     * const marche = await prisma.marche.upsert({
     *   create: {
     *     // ... data to create a Marche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marche we want to update
     *   }
     * })
     */
    upsert<T extends MarcheUpsertArgs>(args: SelectSubset<T, MarcheUpsertArgs<ExtArgs>>): Prisma__MarcheClient<$Result.GetResult<Prisma.$MarchePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Marches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheCountArgs} args - Arguments to filter Marches to count.
     * @example
     * // Count the number of Marches
     * const count = await prisma.marche.count({
     *   where: {
     *     // ... the filter for the Marches we want to count
     *   }
     * })
    **/
    count<T extends MarcheCountArgs>(
      args?: Subset<T, MarcheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarcheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarcheAggregateArgs>(args: Subset<T, MarcheAggregateArgs>): Prisma.PrismaPromise<GetMarcheAggregateType<T>>

    /**
     * Group by Marche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarcheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarcheGroupByArgs['orderBy'] }
        : { orderBy?: MarcheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarcheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarcheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Marche model
   */
  readonly fields: MarcheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarcheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Avenant<T extends Marche$AvenantArgs<ExtArgs> = {}>(args?: Subset<T, Marche$AvenantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LigneMarche<T extends Marche$LigneMarcheArgs<ExtArgs> = {}>(args?: Subset<T, Marche$LigneMarcheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneMarchePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Marche model
   */ 
  interface MarcheFieldRefs {
    readonly id: FieldRef<"Marche", 'Int'>
    readonly chantierId: FieldRef<"Marche", 'String'>
    readonly dateImport: FieldRef<"Marche", 'DateTime'>
    readonly montantTotal: FieldRef<"Marche", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Marche findUnique
   */
  export type MarcheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * Filter, which Marche to fetch.
     */
    where: MarcheWhereUniqueInput
  }

  /**
   * Marche findUniqueOrThrow
   */
  export type MarcheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * Filter, which Marche to fetch.
     */
    where: MarcheWhereUniqueInput
  }

  /**
   * Marche findFirst
   */
  export type MarcheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * Filter, which Marche to fetch.
     */
    where?: MarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marches to fetch.
     */
    orderBy?: MarcheOrderByWithRelationInput | MarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marches.
     */
    cursor?: MarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marches.
     */
    distinct?: MarcheScalarFieldEnum | MarcheScalarFieldEnum[]
  }

  /**
   * Marche findFirstOrThrow
   */
  export type MarcheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * Filter, which Marche to fetch.
     */
    where?: MarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marches to fetch.
     */
    orderBy?: MarcheOrderByWithRelationInput | MarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marches.
     */
    cursor?: MarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marches.
     */
    distinct?: MarcheScalarFieldEnum | MarcheScalarFieldEnum[]
  }

  /**
   * Marche findMany
   */
  export type MarcheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * Filter, which Marches to fetch.
     */
    where?: MarcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marches to fetch.
     */
    orderBy?: MarcheOrderByWithRelationInput | MarcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marches.
     */
    cursor?: MarcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marches.
     */
    skip?: number
    distinct?: MarcheScalarFieldEnum | MarcheScalarFieldEnum[]
  }

  /**
   * Marche create
   */
  export type MarcheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * The data needed to create a Marche.
     */
    data: XOR<MarcheCreateInput, MarcheUncheckedCreateInput>
  }

  /**
   * Marche createMany
   */
  export type MarcheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Marches.
     */
    data: MarcheCreateManyInput | MarcheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Marche update
   */
  export type MarcheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * The data needed to update a Marche.
     */
    data: XOR<MarcheUpdateInput, MarcheUncheckedUpdateInput>
    /**
     * Choose, which Marche to update.
     */
    where: MarcheWhereUniqueInput
  }

  /**
   * Marche updateMany
   */
  export type MarcheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Marches.
     */
    data: XOR<MarcheUpdateManyMutationInput, MarcheUncheckedUpdateManyInput>
    /**
     * Filter which Marches to update
     */
    where?: MarcheWhereInput
    /**
     * Limit how many Marches to update.
     */
    limit?: number
  }

  /**
   * Marche upsert
   */
  export type MarcheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * The filter to search for the Marche to update in case it exists.
     */
    where: MarcheWhereUniqueInput
    /**
     * In case the Marche found by the `where` argument doesn't exist, create a new Marche with this data.
     */
    create: XOR<MarcheCreateInput, MarcheUncheckedCreateInput>
    /**
     * In case the Marche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarcheUpdateInput, MarcheUncheckedUpdateInput>
  }

  /**
   * Marche delete
   */
  export type MarcheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
    /**
     * Filter which Marche to delete.
     */
    where: MarcheWhereUniqueInput
  }

  /**
   * Marche deleteMany
   */
  export type MarcheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marches to delete
     */
    where?: MarcheWhereInput
    /**
     * Limit how many Marches to delete.
     */
    limit?: number
  }

  /**
   * Marche.Avenant
   */
  export type Marche$AvenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avenant
     */
    select?: AvenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avenant
     */
    omit?: AvenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvenantInclude<ExtArgs> | null
    where?: AvenantWhereInput
    orderBy?: AvenantOrderByWithRelationInput | AvenantOrderByWithRelationInput[]
    cursor?: AvenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvenantScalarFieldEnum | AvenantScalarFieldEnum[]
  }

  /**
   * Marche.LigneMarche
   */
  export type Marche$LigneMarcheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneMarche
     */
    select?: LigneMarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneMarche
     */
    omit?: LigneMarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneMarcheInclude<ExtArgs> | null
    where?: LigneMarcheWhereInput
    orderBy?: LigneMarcheOrderByWithRelationInput | LigneMarcheOrderByWithRelationInput[]
    cursor?: LigneMarcheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneMarcheScalarFieldEnum | LigneMarcheScalarFieldEnum[]
  }

  /**
   * Marche without action
   */
  export type MarcheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marche
     */
    select?: MarcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marche
     */
    omit?: MarcheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarcheInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteAvgAggregateOutputType = {
    id: number | null
  }

  export type NoteSumAggregateOutputType = {
    id: number | null
  }

  export type NoteMinAggregateOutputType = {
    id: number | null
    chantierId: string | null
    contenu: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: number | null
    chantierId: string | null
    contenu: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    chantierId: number
    contenu: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteAvgAggregateInputType = {
    id?: true
  }

  export type NoteSumAggregateInputType = {
    id?: true
  }

  export type NoteMinAggregateInputType = {
    id?: true
    chantierId?: true
    contenu?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    chantierId?: true
    contenu?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    chantierId?: true
    contenu?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _avg?: NoteAvgAggregateInputType
    _sum?: NoteSumAggregateInputType
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: number
    chantierId: string
    contenu: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chantierId?: boolean
    contenu?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>



  export type NoteSelectScalar = {
    id?: boolean
    chantierId?: boolean
    contenu?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chantierId" | "contenu" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["note"]>
  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      Chantier: Prisma.$ChantierPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chantierId: string
      contenu: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'Int'>
    readonly chantierId: FieldRef<"Note", 'String'>
    readonly contenu: FieldRef<"Note", 'String'>
    readonly createdBy: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model Ouvrier
   */

  export type AggregateOuvrier = {
    _count: OuvrierCountAggregateOutputType | null
    _min: OuvrierMinAggregateOutputType | null
    _max: OuvrierMaxAggregateOutputType | null
  }

  export type OuvrierMinAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    dateEntree: Date | null
    poste: string | null
    sousTraitantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OuvrierMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    dateEntree: Date | null
    poste: string | null
    sousTraitantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OuvrierCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    email: number
    telephone: number
    dateEntree: number
    poste: number
    sousTraitantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OuvrierMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    dateEntree?: true
    poste?: true
    sousTraitantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OuvrierMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    dateEntree?: true
    poste?: true
    sousTraitantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OuvrierCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    dateEntree?: true
    poste?: true
    sousTraitantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OuvrierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ouvrier to aggregate.
     */
    where?: OuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ouvriers to fetch.
     */
    orderBy?: OuvrierOrderByWithRelationInput | OuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ouvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ouvriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ouvriers
    **/
    _count?: true | OuvrierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OuvrierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OuvrierMaxAggregateInputType
  }

  export type GetOuvrierAggregateType<T extends OuvrierAggregateArgs> = {
        [P in keyof T & keyof AggregateOuvrier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOuvrier[P]>
      : GetScalarType<T[P], AggregateOuvrier[P]>
  }




  export type OuvrierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OuvrierWhereInput
    orderBy?: OuvrierOrderByWithAggregationInput | OuvrierOrderByWithAggregationInput[]
    by: OuvrierScalarFieldEnum[] | OuvrierScalarFieldEnum
    having?: OuvrierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OuvrierCountAggregateInputType | true
    _min?: OuvrierMinAggregateInputType
    _max?: OuvrierMaxAggregateInputType
  }

  export type OuvrierGroupByOutputType = {
    id: string
    nom: string
    prenom: string
    email: string | null
    telephone: string | null
    dateEntree: Date
    poste: string
    sousTraitantId: string
    createdAt: Date
    updatedAt: Date
    _count: OuvrierCountAggregateOutputType | null
    _min: OuvrierMinAggregateOutputType | null
    _max: OuvrierMaxAggregateOutputType | null
  }

  type GetOuvrierGroupByPayload<T extends OuvrierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OuvrierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OuvrierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OuvrierGroupByOutputType[P]>
            : GetScalarType<T[P], OuvrierGroupByOutputType[P]>
        }
      >
    >


  export type OuvrierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    dateEntree?: boolean
    poste?: boolean
    sousTraitantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DocumentOuvrier?: boolean | Ouvrier$DocumentOuvrierArgs<ExtArgs>
    _count?: boolean | OuvrierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ouvrier"]>



  export type OuvrierSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    dateEntree?: boolean
    poste?: boolean
    sousTraitantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OuvrierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "prenom" | "email" | "telephone" | "dateEntree" | "poste" | "sousTraitantId" | "createdAt" | "updatedAt", ExtArgs["result"]["ouvrier"]>
  export type OuvrierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DocumentOuvrier?: boolean | Ouvrier$DocumentOuvrierArgs<ExtArgs>
    _count?: boolean | OuvrierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OuvrierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ouvrier"
    objects: {
      DocumentOuvrier: Prisma.$DocumentOuvrierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      prenom: string
      email: string | null
      telephone: string | null
      dateEntree: Date
      poste: string
      sousTraitantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ouvrier"]>
    composites: {}
  }

  type OuvrierGetPayload<S extends boolean | null | undefined | OuvrierDefaultArgs> = $Result.GetResult<Prisma.$OuvrierPayload, S>

  type OuvrierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OuvrierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OuvrierCountAggregateInputType | true
    }

  export interface OuvrierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ouvrier'], meta: { name: 'Ouvrier' } }
    /**
     * Find zero or one Ouvrier that matches the filter.
     * @param {OuvrierFindUniqueArgs} args - Arguments to find a Ouvrier
     * @example
     * // Get one Ouvrier
     * const ouvrier = await prisma.ouvrier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OuvrierFindUniqueArgs>(args: SelectSubset<T, OuvrierFindUniqueArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ouvrier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OuvrierFindUniqueOrThrowArgs} args - Arguments to find a Ouvrier
     * @example
     * // Get one Ouvrier
     * const ouvrier = await prisma.ouvrier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OuvrierFindUniqueOrThrowArgs>(args: SelectSubset<T, OuvrierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ouvrier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierFindFirstArgs} args - Arguments to find a Ouvrier
     * @example
     * // Get one Ouvrier
     * const ouvrier = await prisma.ouvrier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OuvrierFindFirstArgs>(args?: SelectSubset<T, OuvrierFindFirstArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ouvrier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierFindFirstOrThrowArgs} args - Arguments to find a Ouvrier
     * @example
     * // Get one Ouvrier
     * const ouvrier = await prisma.ouvrier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OuvrierFindFirstOrThrowArgs>(args?: SelectSubset<T, OuvrierFindFirstOrThrowArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ouvriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ouvriers
     * const ouvriers = await prisma.ouvrier.findMany()
     * 
     * // Get first 10 Ouvriers
     * const ouvriers = await prisma.ouvrier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ouvrierWithIdOnly = await prisma.ouvrier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OuvrierFindManyArgs>(args?: SelectSubset<T, OuvrierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ouvrier.
     * @param {OuvrierCreateArgs} args - Arguments to create a Ouvrier.
     * @example
     * // Create one Ouvrier
     * const Ouvrier = await prisma.ouvrier.create({
     *   data: {
     *     // ... data to create a Ouvrier
     *   }
     * })
     * 
     */
    create<T extends OuvrierCreateArgs>(args: SelectSubset<T, OuvrierCreateArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ouvriers.
     * @param {OuvrierCreateManyArgs} args - Arguments to create many Ouvriers.
     * @example
     * // Create many Ouvriers
     * const ouvrier = await prisma.ouvrier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OuvrierCreateManyArgs>(args?: SelectSubset<T, OuvrierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ouvrier.
     * @param {OuvrierDeleteArgs} args - Arguments to delete one Ouvrier.
     * @example
     * // Delete one Ouvrier
     * const Ouvrier = await prisma.ouvrier.delete({
     *   where: {
     *     // ... filter to delete one Ouvrier
     *   }
     * })
     * 
     */
    delete<T extends OuvrierDeleteArgs>(args: SelectSubset<T, OuvrierDeleteArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ouvrier.
     * @param {OuvrierUpdateArgs} args - Arguments to update one Ouvrier.
     * @example
     * // Update one Ouvrier
     * const ouvrier = await prisma.ouvrier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OuvrierUpdateArgs>(args: SelectSubset<T, OuvrierUpdateArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ouvriers.
     * @param {OuvrierDeleteManyArgs} args - Arguments to filter Ouvriers to delete.
     * @example
     * // Delete a few Ouvriers
     * const { count } = await prisma.ouvrier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OuvrierDeleteManyArgs>(args?: SelectSubset<T, OuvrierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ouvriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ouvriers
     * const ouvrier = await prisma.ouvrier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OuvrierUpdateManyArgs>(args: SelectSubset<T, OuvrierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ouvrier.
     * @param {OuvrierUpsertArgs} args - Arguments to update or create a Ouvrier.
     * @example
     * // Update or create a Ouvrier
     * const ouvrier = await prisma.ouvrier.upsert({
     *   create: {
     *     // ... data to create a Ouvrier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ouvrier we want to update
     *   }
     * })
     */
    upsert<T extends OuvrierUpsertArgs>(args: SelectSubset<T, OuvrierUpsertArgs<ExtArgs>>): Prisma__OuvrierClient<$Result.GetResult<Prisma.$OuvrierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ouvriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierCountArgs} args - Arguments to filter Ouvriers to count.
     * @example
     * // Count the number of Ouvriers
     * const count = await prisma.ouvrier.count({
     *   where: {
     *     // ... the filter for the Ouvriers we want to count
     *   }
     * })
    **/
    count<T extends OuvrierCountArgs>(
      args?: Subset<T, OuvrierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OuvrierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ouvrier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OuvrierAggregateArgs>(args: Subset<T, OuvrierAggregateArgs>): Prisma.PrismaPromise<GetOuvrierAggregateType<T>>

    /**
     * Group by Ouvrier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuvrierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OuvrierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OuvrierGroupByArgs['orderBy'] }
        : { orderBy?: OuvrierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OuvrierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOuvrierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ouvrier model
   */
  readonly fields: OuvrierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ouvrier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OuvrierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DocumentOuvrier<T extends Ouvrier$DocumentOuvrierArgs<ExtArgs> = {}>(args?: Subset<T, Ouvrier$DocumentOuvrierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentOuvrierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ouvrier model
   */ 
  interface OuvrierFieldRefs {
    readonly id: FieldRef<"Ouvrier", 'String'>
    readonly nom: FieldRef<"Ouvrier", 'String'>
    readonly prenom: FieldRef<"Ouvrier", 'String'>
    readonly email: FieldRef<"Ouvrier", 'String'>
    readonly telephone: FieldRef<"Ouvrier", 'String'>
    readonly dateEntree: FieldRef<"Ouvrier", 'DateTime'>
    readonly poste: FieldRef<"Ouvrier", 'String'>
    readonly sousTraitantId: FieldRef<"Ouvrier", 'String'>
    readonly createdAt: FieldRef<"Ouvrier", 'DateTime'>
    readonly updatedAt: FieldRef<"Ouvrier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ouvrier findUnique
   */
  export type OuvrierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * Filter, which Ouvrier to fetch.
     */
    where: OuvrierWhereUniqueInput
  }

  /**
   * Ouvrier findUniqueOrThrow
   */
  export type OuvrierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * Filter, which Ouvrier to fetch.
     */
    where: OuvrierWhereUniqueInput
  }

  /**
   * Ouvrier findFirst
   */
  export type OuvrierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * Filter, which Ouvrier to fetch.
     */
    where?: OuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ouvriers to fetch.
     */
    orderBy?: OuvrierOrderByWithRelationInput | OuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ouvriers.
     */
    cursor?: OuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ouvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ouvriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ouvriers.
     */
    distinct?: OuvrierScalarFieldEnum | OuvrierScalarFieldEnum[]
  }

  /**
   * Ouvrier findFirstOrThrow
   */
  export type OuvrierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * Filter, which Ouvrier to fetch.
     */
    where?: OuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ouvriers to fetch.
     */
    orderBy?: OuvrierOrderByWithRelationInput | OuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ouvriers.
     */
    cursor?: OuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ouvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ouvriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ouvriers.
     */
    distinct?: OuvrierScalarFieldEnum | OuvrierScalarFieldEnum[]
  }

  /**
   * Ouvrier findMany
   */
  export type OuvrierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * Filter, which Ouvriers to fetch.
     */
    where?: OuvrierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ouvriers to fetch.
     */
    orderBy?: OuvrierOrderByWithRelationInput | OuvrierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ouvriers.
     */
    cursor?: OuvrierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ouvriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ouvriers.
     */
    skip?: number
    distinct?: OuvrierScalarFieldEnum | OuvrierScalarFieldEnum[]
  }

  /**
   * Ouvrier create
   */
  export type OuvrierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * The data needed to create a Ouvrier.
     */
    data: XOR<OuvrierCreateInput, OuvrierUncheckedCreateInput>
  }

  /**
   * Ouvrier createMany
   */
  export type OuvrierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ouvriers.
     */
    data: OuvrierCreateManyInput | OuvrierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ouvrier update
   */
  export type OuvrierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * The data needed to update a Ouvrier.
     */
    data: XOR<OuvrierUpdateInput, OuvrierUncheckedUpdateInput>
    /**
     * Choose, which Ouvrier to update.
     */
    where: OuvrierWhereUniqueInput
  }

  /**
   * Ouvrier updateMany
   */
  export type OuvrierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ouvriers.
     */
    data: XOR<OuvrierUpdateManyMutationInput, OuvrierUncheckedUpdateManyInput>
    /**
     * Filter which Ouvriers to update
     */
    where?: OuvrierWhereInput
    /**
     * Limit how many Ouvriers to update.
     */
    limit?: number
  }

  /**
   * Ouvrier upsert
   */
  export type OuvrierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * The filter to search for the Ouvrier to update in case it exists.
     */
    where: OuvrierWhereUniqueInput
    /**
     * In case the Ouvrier found by the `where` argument doesn't exist, create a new Ouvrier with this data.
     */
    create: XOR<OuvrierCreateInput, OuvrierUncheckedCreateInput>
    /**
     * In case the Ouvrier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OuvrierUpdateInput, OuvrierUncheckedUpdateInput>
  }

  /**
   * Ouvrier delete
   */
  export type OuvrierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
    /**
     * Filter which Ouvrier to delete.
     */
    where: OuvrierWhereUniqueInput
  }

  /**
   * Ouvrier deleteMany
   */
  export type OuvrierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ouvriers to delete
     */
    where?: OuvrierWhereInput
    /**
     * Limit how many Ouvriers to delete.
     */
    limit?: number
  }

  /**
   * Ouvrier.DocumentOuvrier
   */
  export type Ouvrier$DocumentOuvrierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentOuvrier
     */
    select?: DocumentOuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentOuvrier
     */
    omit?: DocumentOuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentOuvrierInclude<ExtArgs> | null
    where?: DocumentOuvrierWhereInput
    orderBy?: DocumentOuvrierOrderByWithRelationInput | DocumentOuvrierOrderByWithRelationInput[]
    cursor?: DocumentOuvrierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentOuvrierScalarFieldEnum | DocumentOuvrierScalarFieldEnum[]
  }

  /**
   * Ouvrier without action
   */
  export type OuvrierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ouvrier
     */
    select?: OuvrierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ouvrier
     */
    omit?: OuvrierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OuvrierInclude<ExtArgs> | null
  }


  /**
   * Model Tache
   */

  export type AggregateTache = {
    _count: TacheCountAggregateOutputType | null
    _min: TacheMinAggregateOutputType | null
    _max: TacheMaxAggregateOutputType | null
  }

  export type TacheMinAggregateOutputType = {
    id: string | null
    label: string | null
    completed: boolean | null
    completedAt: Date | null
    chantierId: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TacheMaxAggregateOutputType = {
    id: string | null
    label: string | null
    completed: boolean | null
    completedAt: Date | null
    chantierId: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TacheCountAggregateOutputType = {
    id: number
    label: number
    completed: number
    completedAt: number
    chantierId: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TacheMinAggregateInputType = {
    id?: true
    label?: true
    completed?: true
    completedAt?: true
    chantierId?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TacheMaxAggregateInputType = {
    id?: true
    label?: true
    completed?: true
    completedAt?: true
    chantierId?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TacheCountAggregateInputType = {
    id?: true
    label?: true
    completed?: true
    completedAt?: true
    chantierId?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tache to aggregate.
     */
    where?: TacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taches to fetch.
     */
    orderBy?: TacheOrderByWithRelationInput | TacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Taches
    **/
    _count?: true | TacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TacheMaxAggregateInputType
  }

  export type GetTacheAggregateType<T extends TacheAggregateArgs> = {
        [P in keyof T & keyof AggregateTache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTache[P]>
      : GetScalarType<T[P], AggregateTache[P]>
  }




  export type TacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TacheWhereInput
    orderBy?: TacheOrderByWithAggregationInput | TacheOrderByWithAggregationInput[]
    by: TacheScalarFieldEnum[] | TacheScalarFieldEnum
    having?: TacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TacheCountAggregateInputType | true
    _min?: TacheMinAggregateInputType
    _max?: TacheMaxAggregateInputType
  }

  export type TacheGroupByOutputType = {
    id: string
    label: string
    completed: boolean
    completedAt: Date | null
    chantierId: string
    category: string
    createdAt: Date
    updatedAt: Date
    _count: TacheCountAggregateOutputType | null
    _min: TacheMinAggregateOutputType | null
    _max: TacheMaxAggregateOutputType | null
  }

  type GetTacheGroupByPayload<T extends TacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TacheGroupByOutputType[P]>
            : GetScalarType<T[P], TacheGroupByOutputType[P]>
        }
      >
    >


  export type TacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    completed?: boolean
    completedAt?: boolean
    chantierId?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tache"]>



  export type TacheSelectScalar = {
    id?: boolean
    label?: boolean
    completed?: boolean
    completedAt?: boolean
    chantierId?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "completed" | "completedAt" | "chantierId" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["tache"]>
  export type TacheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chantier?: boolean | ChantierDefaultArgs<ExtArgs>
  }

  export type $TachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tache"
    objects: {
      Chantier: Prisma.$ChantierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      completed: boolean
      completedAt: Date | null
      chantierId: string
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tache"]>
    composites: {}
  }

  type TacheGetPayload<S extends boolean | null | undefined | TacheDefaultArgs> = $Result.GetResult<Prisma.$TachePayload, S>

  type TacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TacheCountAggregateInputType | true
    }

  export interface TacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tache'], meta: { name: 'Tache' } }
    /**
     * Find zero or one Tache that matches the filter.
     * @param {TacheFindUniqueArgs} args - Arguments to find a Tache
     * @example
     * // Get one Tache
     * const tache = await prisma.tache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TacheFindUniqueArgs>(args: SelectSubset<T, TacheFindUniqueArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TacheFindUniqueOrThrowArgs} args - Arguments to find a Tache
     * @example
     * // Get one Tache
     * const tache = await prisma.tache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TacheFindUniqueOrThrowArgs>(args: SelectSubset<T, TacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheFindFirstArgs} args - Arguments to find a Tache
     * @example
     * // Get one Tache
     * const tache = await prisma.tache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TacheFindFirstArgs>(args?: SelectSubset<T, TacheFindFirstArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheFindFirstOrThrowArgs} args - Arguments to find a Tache
     * @example
     * // Get one Tache
     * const tache = await prisma.tache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TacheFindFirstOrThrowArgs>(args?: SelectSubset<T, TacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Taches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taches
     * const taches = await prisma.tache.findMany()
     * 
     * // Get first 10 Taches
     * const taches = await prisma.tache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tacheWithIdOnly = await prisma.tache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TacheFindManyArgs>(args?: SelectSubset<T, TacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tache.
     * @param {TacheCreateArgs} args - Arguments to create a Tache.
     * @example
     * // Create one Tache
     * const Tache = await prisma.tache.create({
     *   data: {
     *     // ... data to create a Tache
     *   }
     * })
     * 
     */
    create<T extends TacheCreateArgs>(args: SelectSubset<T, TacheCreateArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Taches.
     * @param {TacheCreateManyArgs} args - Arguments to create many Taches.
     * @example
     * // Create many Taches
     * const tache = await prisma.tache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TacheCreateManyArgs>(args?: SelectSubset<T, TacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tache.
     * @param {TacheDeleteArgs} args - Arguments to delete one Tache.
     * @example
     * // Delete one Tache
     * const Tache = await prisma.tache.delete({
     *   where: {
     *     // ... filter to delete one Tache
     *   }
     * })
     * 
     */
    delete<T extends TacheDeleteArgs>(args: SelectSubset<T, TacheDeleteArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tache.
     * @param {TacheUpdateArgs} args - Arguments to update one Tache.
     * @example
     * // Update one Tache
     * const tache = await prisma.tache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TacheUpdateArgs>(args: SelectSubset<T, TacheUpdateArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Taches.
     * @param {TacheDeleteManyArgs} args - Arguments to filter Taches to delete.
     * @example
     * // Delete a few Taches
     * const { count } = await prisma.tache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TacheDeleteManyArgs>(args?: SelectSubset<T, TacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taches
     * const tache = await prisma.tache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TacheUpdateManyArgs>(args: SelectSubset<T, TacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tache.
     * @param {TacheUpsertArgs} args - Arguments to update or create a Tache.
     * @example
     * // Update or create a Tache
     * const tache = await prisma.tache.upsert({
     *   create: {
     *     // ... data to create a Tache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tache we want to update
     *   }
     * })
     */
    upsert<T extends TacheUpsertArgs>(args: SelectSubset<T, TacheUpsertArgs<ExtArgs>>): Prisma__TacheClient<$Result.GetResult<Prisma.$TachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Taches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheCountArgs} args - Arguments to filter Taches to count.
     * @example
     * // Count the number of Taches
     * const count = await prisma.tache.count({
     *   where: {
     *     // ... the filter for the Taches we want to count
     *   }
     * })
    **/
    count<T extends TacheCountArgs>(
      args?: Subset<T, TacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TacheAggregateArgs>(args: Subset<T, TacheAggregateArgs>): Prisma.PrismaPromise<GetTacheAggregateType<T>>

    /**
     * Group by Tache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TacheGroupByArgs['orderBy'] }
        : { orderBy?: TacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tache model
   */
  readonly fields: TacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chantier<T extends ChantierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChantierDefaultArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tache model
   */ 
  interface TacheFieldRefs {
    readonly id: FieldRef<"Tache", 'String'>
    readonly label: FieldRef<"Tache", 'String'>
    readonly completed: FieldRef<"Tache", 'Boolean'>
    readonly completedAt: FieldRef<"Tache", 'DateTime'>
    readonly chantierId: FieldRef<"Tache", 'String'>
    readonly category: FieldRef<"Tache", 'String'>
    readonly createdAt: FieldRef<"Tache", 'DateTime'>
    readonly updatedAt: FieldRef<"Tache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tache findUnique
   */
  export type TacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * Filter, which Tache to fetch.
     */
    where: TacheWhereUniqueInput
  }

  /**
   * Tache findUniqueOrThrow
   */
  export type TacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * Filter, which Tache to fetch.
     */
    where: TacheWhereUniqueInput
  }

  /**
   * Tache findFirst
   */
  export type TacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * Filter, which Tache to fetch.
     */
    where?: TacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taches to fetch.
     */
    orderBy?: TacheOrderByWithRelationInput | TacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Taches.
     */
    cursor?: TacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Taches.
     */
    distinct?: TacheScalarFieldEnum | TacheScalarFieldEnum[]
  }

  /**
   * Tache findFirstOrThrow
   */
  export type TacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * Filter, which Tache to fetch.
     */
    where?: TacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taches to fetch.
     */
    orderBy?: TacheOrderByWithRelationInput | TacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Taches.
     */
    cursor?: TacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Taches.
     */
    distinct?: TacheScalarFieldEnum | TacheScalarFieldEnum[]
  }

  /**
   * Tache findMany
   */
  export type TacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * Filter, which Taches to fetch.
     */
    where?: TacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taches to fetch.
     */
    orderBy?: TacheOrderByWithRelationInput | TacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Taches.
     */
    cursor?: TacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taches.
     */
    skip?: number
    distinct?: TacheScalarFieldEnum | TacheScalarFieldEnum[]
  }

  /**
   * Tache create
   */
  export type TacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * The data needed to create a Tache.
     */
    data: XOR<TacheCreateInput, TacheUncheckedCreateInput>
  }

  /**
   * Tache createMany
   */
  export type TacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Taches.
     */
    data: TacheCreateManyInput | TacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tache update
   */
  export type TacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * The data needed to update a Tache.
     */
    data: XOR<TacheUpdateInput, TacheUncheckedUpdateInput>
    /**
     * Choose, which Tache to update.
     */
    where: TacheWhereUniqueInput
  }

  /**
   * Tache updateMany
   */
  export type TacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Taches.
     */
    data: XOR<TacheUpdateManyMutationInput, TacheUncheckedUpdateManyInput>
    /**
     * Filter which Taches to update
     */
    where?: TacheWhereInput
    /**
     * Limit how many Taches to update.
     */
    limit?: number
  }

  /**
   * Tache upsert
   */
  export type TacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * The filter to search for the Tache to update in case it exists.
     */
    where: TacheWhereUniqueInput
    /**
     * In case the Tache found by the `where` argument doesn't exist, create a new Tache with this data.
     */
    create: XOR<TacheCreateInput, TacheUncheckedCreateInput>
    /**
     * In case the Tache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TacheUpdateInput, TacheUncheckedUpdateInput>
  }

  /**
   * Tache delete
   */
  export type TacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
    /**
     * Filter which Tache to delete.
     */
    where: TacheWhereUniqueInput
  }

  /**
   * Tache deleteMany
   */
  export type TacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Taches to delete
     */
    where?: TacheWhereInput
    /**
     * Limit how many Taches to delete.
     */
    limit?: number
  }

  /**
   * Tache without action
   */
  export type TacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tache
     */
    select?: TacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tache
     */
    omit?: TacheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TacheInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.User_role | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.User_role | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    name: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: $Enums.User_role
    createdAt: Date
    updatedAt: Date
    name: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    Document?: boolean | User$DocumentArgs<ExtArgs>
    Note?: boolean | User$NoteArgs<ExtArgs>
    admintask?: boolean | User$admintaskArgs<ExtArgs>
    pret?: boolean | User$pretArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "createdAt" | "updatedAt" | "name", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | User$DocumentArgs<ExtArgs>
    Note?: boolean | User$NoteArgs<ExtArgs>
    admintask?: boolean | User$admintaskArgs<ExtArgs>
    pret?: boolean | User$pretArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Document: Prisma.$DocumentPayload<ExtArgs>[]
      Note: Prisma.$NotePayload<ExtArgs>[]
      admintask: Prisma.$admintaskPayload<ExtArgs>[]
      pret: Prisma.$pretPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: $Enums.User_role
      createdAt: Date
      updatedAt: Date
      name: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Document<T extends User$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Note<T extends User$NoteArgs<ExtArgs> = {}>(args?: Subset<T, User$NoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admintask<T extends User$admintaskArgs<ExtArgs> = {}>(args?: Subset<T, User$admintaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admintaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pret<T extends User$pretArgs<ExtArgs> = {}>(args?: Subset<T, User$pretArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pretPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'User_role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Document
   */
  export type User$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.Note
   */
  export type User$NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.admintask
   */
  export type User$admintaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admintask
     */
    select?: admintaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admintask
     */
    omit?: admintaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admintaskInclude<ExtArgs> | null
    where?: admintaskWhereInput
    orderBy?: admintaskOrderByWithRelationInput | admintaskOrderByWithRelationInput[]
    cursor?: admintaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmintaskScalarFieldEnum | AdmintaskScalarFieldEnum[]
  }

  /**
   * User.pret
   */
  export type User$pretArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pret
     */
    select?: pretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pret
     */
    omit?: pretOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pretInclude<ExtArgs> | null
    where?: pretWhereInput
    orderBy?: pretOrderByWithRelationInput | pretOrderByWithRelationInput[]
    cursor?: pretWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PretScalarFieldEnum | PretScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model BonRegie
   */

  export type AggregateBonRegie = {
    _count: BonRegieCountAggregateOutputType | null
    _avg: BonRegieAvgAggregateOutputType | null
    _sum: BonRegieSumAggregateOutputType | null
    _min: BonRegieMinAggregateOutputType | null
    _max: BonRegieMaxAggregateOutputType | null
  }

  export type BonRegieAvgAggregateOutputType = {
    id: number | null
    tempsPreparation: number | null
    tempsTrajets: number | null
    tempsChantier: number | null
    nombreTechniciens: number | null
  }

  export type BonRegieSumAggregateOutputType = {
    id: number | null
    tempsPreparation: number | null
    tempsTrajets: number | null
    tempsChantier: number | null
    nombreTechniciens: number | null
  }

  export type BonRegieMinAggregateOutputType = {
    id: number | null
    dates: string | null
    client: string | null
    nomChantier: string | null
    description: string | null
    tempsPreparation: number | null
    tempsTrajets: number | null
    tempsChantier: number | null
    nombreTechniciens: number | null
    materiaux: string | null
    nomSignataire: string | null
    signature: string | null
    dateSignature: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    chantierId: string | null
  }

  export type BonRegieMaxAggregateOutputType = {
    id: number | null
    dates: string | null
    client: string | null
    nomChantier: string | null
    description: string | null
    tempsPreparation: number | null
    tempsTrajets: number | null
    tempsChantier: number | null
    nombreTechniciens: number | null
    materiaux: string | null
    nomSignataire: string | null
    signature: string | null
    dateSignature: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    chantierId: string | null
  }

  export type BonRegieCountAggregateOutputType = {
    id: number
    dates: number
    client: number
    nomChantier: number
    description: number
    tempsPreparation: number
    tempsTrajets: number
    tempsChantier: number
    nombreTechniciens: number
    materiaux: number
    nomSignataire: number
    signature: number
    dateSignature: number
    createdAt: number
    updatedAt: number
    chantierId: number
    _all: number
  }


  export type BonRegieAvgAggregateInputType = {
    id?: true
    tempsPreparation?: true
    tempsTrajets?: true
    tempsChantier?: true
    nombreTechniciens?: true
  }

  export type BonRegieSumAggregateInputType = {
    id?: true
    tempsPreparation?: true
    tempsTrajets?: true
    tempsChantier?: true
    nombreTechniciens?: true
  }

  export type BonRegieMinAggregateInputType = {
    id?: true
    dates?: true
    client?: true
    nomChantier?: true
    description?: true
    tempsPreparation?: true
    tempsTrajets?: true
    tempsChantier?: true
    nombreTechniciens?: true
    materiaux?: true
    nomSignataire?: true
    signature?: true
    dateSignature?: true
    createdAt?: true
    updatedAt?: true
    chantierId?: true
  }

  export type BonRegieMaxAggregateInputType = {
    id?: true
    dates?: true
    client?: true
    nomChantier?: true
    description?: true
    tempsPreparation?: true
    tempsTrajets?: true
    tempsChantier?: true
    nombreTechniciens?: true
    materiaux?: true
    nomSignataire?: true
    signature?: true
    dateSignature?: true
    createdAt?: true
    updatedAt?: true
    chantierId?: true
  }

  export type BonRegieCountAggregateInputType = {
    id?: true
    dates?: true
    client?: true
    nomChantier?: true
    description?: true
    tempsPreparation?: true
    tempsTrajets?: true
    tempsChantier?: true
    nombreTechniciens?: true
    materiaux?: true
    nomSignataire?: true
    signature?: true
    dateSignature?: true
    createdAt?: true
    updatedAt?: true
    chantierId?: true
    _all?: true
  }

  export type BonRegieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BonRegie to aggregate.
     */
    where?: BonRegieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BonRegies to fetch.
     */
    orderBy?: BonRegieOrderByWithRelationInput | BonRegieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BonRegieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BonRegies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BonRegies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BonRegies
    **/
    _count?: true | BonRegieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BonRegieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BonRegieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BonRegieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BonRegieMaxAggregateInputType
  }

  export type GetBonRegieAggregateType<T extends BonRegieAggregateArgs> = {
        [P in keyof T & keyof AggregateBonRegie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBonRegie[P]>
      : GetScalarType<T[P], AggregateBonRegie[P]>
  }




  export type BonRegieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonRegieWhereInput
    orderBy?: BonRegieOrderByWithAggregationInput | BonRegieOrderByWithAggregationInput[]
    by: BonRegieScalarFieldEnum[] | BonRegieScalarFieldEnum
    having?: BonRegieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BonRegieCountAggregateInputType | true
    _avg?: BonRegieAvgAggregateInputType
    _sum?: BonRegieSumAggregateInputType
    _min?: BonRegieMinAggregateInputType
    _max?: BonRegieMaxAggregateInputType
  }

  export type BonRegieGroupByOutputType = {
    id: number
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation: number | null
    tempsTrajets: number | null
    tempsChantier: number | null
    nombreTechniciens: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date
    createdAt: Date
    updatedAt: Date
    chantierId: string | null
    _count: BonRegieCountAggregateOutputType | null
    _avg: BonRegieAvgAggregateOutputType | null
    _sum: BonRegieSumAggregateOutputType | null
    _min: BonRegieMinAggregateOutputType | null
    _max: BonRegieMaxAggregateOutputType | null
  }

  type GetBonRegieGroupByPayload<T extends BonRegieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BonRegieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BonRegieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BonRegieGroupByOutputType[P]>
            : GetScalarType<T[P], BonRegieGroupByOutputType[P]>
        }
      >
    >


  export type BonRegieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dates?: boolean
    client?: boolean
    nomChantier?: boolean
    description?: boolean
    tempsPreparation?: boolean
    tempsTrajets?: boolean
    tempsChantier?: boolean
    nombreTechniciens?: boolean
    materiaux?: boolean
    nomSignataire?: boolean
    signature?: boolean
    dateSignature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chantierId?: boolean
    chantier?: boolean | BonRegie$chantierArgs<ExtArgs>
  }, ExtArgs["result"]["bonRegie"]>



  export type BonRegieSelectScalar = {
    id?: boolean
    dates?: boolean
    client?: boolean
    nomChantier?: boolean
    description?: boolean
    tempsPreparation?: boolean
    tempsTrajets?: boolean
    tempsChantier?: boolean
    nombreTechniciens?: boolean
    materiaux?: boolean
    nomSignataire?: boolean
    signature?: boolean
    dateSignature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chantierId?: boolean
  }

  export type BonRegieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dates" | "client" | "nomChantier" | "description" | "tempsPreparation" | "tempsTrajets" | "tempsChantier" | "nombreTechniciens" | "materiaux" | "nomSignataire" | "signature" | "dateSignature" | "createdAt" | "updatedAt" | "chantierId", ExtArgs["result"]["bonRegie"]>
  export type BonRegieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chantier?: boolean | BonRegie$chantierArgs<ExtArgs>
  }

  export type $BonRegiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BonRegie"
    objects: {
      chantier: Prisma.$ChantierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dates: string
      client: string
      nomChantier: string
      description: string
      tempsPreparation: number | null
      tempsTrajets: number | null
      tempsChantier: number | null
      nombreTechniciens: number | null
      materiaux: string
      nomSignataire: string
      signature: string
      dateSignature: Date
      createdAt: Date
      updatedAt: Date
      chantierId: string | null
    }, ExtArgs["result"]["bonRegie"]>
    composites: {}
  }

  type BonRegieGetPayload<S extends boolean | null | undefined | BonRegieDefaultArgs> = $Result.GetResult<Prisma.$BonRegiePayload, S>

  type BonRegieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BonRegieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BonRegieCountAggregateInputType | true
    }

  export interface BonRegieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BonRegie'], meta: { name: 'BonRegie' } }
    /**
     * Find zero or one BonRegie that matches the filter.
     * @param {BonRegieFindUniqueArgs} args - Arguments to find a BonRegie
     * @example
     * // Get one BonRegie
     * const bonRegie = await prisma.bonRegie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BonRegieFindUniqueArgs>(args: SelectSubset<T, BonRegieFindUniqueArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BonRegie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BonRegieFindUniqueOrThrowArgs} args - Arguments to find a BonRegie
     * @example
     * // Get one BonRegie
     * const bonRegie = await prisma.bonRegie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BonRegieFindUniqueOrThrowArgs>(args: SelectSubset<T, BonRegieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BonRegie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieFindFirstArgs} args - Arguments to find a BonRegie
     * @example
     * // Get one BonRegie
     * const bonRegie = await prisma.bonRegie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BonRegieFindFirstArgs>(args?: SelectSubset<T, BonRegieFindFirstArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BonRegie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieFindFirstOrThrowArgs} args - Arguments to find a BonRegie
     * @example
     * // Get one BonRegie
     * const bonRegie = await prisma.bonRegie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BonRegieFindFirstOrThrowArgs>(args?: SelectSubset<T, BonRegieFindFirstOrThrowArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BonRegies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BonRegies
     * const bonRegies = await prisma.bonRegie.findMany()
     * 
     * // Get first 10 BonRegies
     * const bonRegies = await prisma.bonRegie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bonRegieWithIdOnly = await prisma.bonRegie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BonRegieFindManyArgs>(args?: SelectSubset<T, BonRegieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BonRegie.
     * @param {BonRegieCreateArgs} args - Arguments to create a BonRegie.
     * @example
     * // Create one BonRegie
     * const BonRegie = await prisma.bonRegie.create({
     *   data: {
     *     // ... data to create a BonRegie
     *   }
     * })
     * 
     */
    create<T extends BonRegieCreateArgs>(args: SelectSubset<T, BonRegieCreateArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BonRegies.
     * @param {BonRegieCreateManyArgs} args - Arguments to create many BonRegies.
     * @example
     * // Create many BonRegies
     * const bonRegie = await prisma.bonRegie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BonRegieCreateManyArgs>(args?: SelectSubset<T, BonRegieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BonRegie.
     * @param {BonRegieDeleteArgs} args - Arguments to delete one BonRegie.
     * @example
     * // Delete one BonRegie
     * const BonRegie = await prisma.bonRegie.delete({
     *   where: {
     *     // ... filter to delete one BonRegie
     *   }
     * })
     * 
     */
    delete<T extends BonRegieDeleteArgs>(args: SelectSubset<T, BonRegieDeleteArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BonRegie.
     * @param {BonRegieUpdateArgs} args - Arguments to update one BonRegie.
     * @example
     * // Update one BonRegie
     * const bonRegie = await prisma.bonRegie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BonRegieUpdateArgs>(args: SelectSubset<T, BonRegieUpdateArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BonRegies.
     * @param {BonRegieDeleteManyArgs} args - Arguments to filter BonRegies to delete.
     * @example
     * // Delete a few BonRegies
     * const { count } = await prisma.bonRegie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BonRegieDeleteManyArgs>(args?: SelectSubset<T, BonRegieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BonRegies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BonRegies
     * const bonRegie = await prisma.bonRegie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BonRegieUpdateManyArgs>(args: SelectSubset<T, BonRegieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BonRegie.
     * @param {BonRegieUpsertArgs} args - Arguments to update or create a BonRegie.
     * @example
     * // Update or create a BonRegie
     * const bonRegie = await prisma.bonRegie.upsert({
     *   create: {
     *     // ... data to create a BonRegie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BonRegie we want to update
     *   }
     * })
     */
    upsert<T extends BonRegieUpsertArgs>(args: SelectSubset<T, BonRegieUpsertArgs<ExtArgs>>): Prisma__BonRegieClient<$Result.GetResult<Prisma.$BonRegiePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BonRegies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieCountArgs} args - Arguments to filter BonRegies to count.
     * @example
     * // Count the number of BonRegies
     * const count = await prisma.bonRegie.count({
     *   where: {
     *     // ... the filter for the BonRegies we want to count
     *   }
     * })
    **/
    count<T extends BonRegieCountArgs>(
      args?: Subset<T, BonRegieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BonRegieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BonRegie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BonRegieAggregateArgs>(args: Subset<T, BonRegieAggregateArgs>): Prisma.PrismaPromise<GetBonRegieAggregateType<T>>

    /**
     * Group by BonRegie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonRegieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BonRegieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BonRegieGroupByArgs['orderBy'] }
        : { orderBy?: BonRegieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BonRegieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBonRegieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BonRegie model
   */
  readonly fields: BonRegieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BonRegie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BonRegieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chantier<T extends BonRegie$chantierArgs<ExtArgs> = {}>(args?: Subset<T, BonRegie$chantierArgs<ExtArgs>>): Prisma__ChantierClient<$Result.GetResult<Prisma.$ChantierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BonRegie model
   */ 
  interface BonRegieFieldRefs {
    readonly id: FieldRef<"BonRegie", 'Int'>
    readonly dates: FieldRef<"BonRegie", 'String'>
    readonly client: FieldRef<"BonRegie", 'String'>
    readonly nomChantier: FieldRef<"BonRegie", 'String'>
    readonly description: FieldRef<"BonRegie", 'String'>
    readonly tempsPreparation: FieldRef<"BonRegie", 'Float'>
    readonly tempsTrajets: FieldRef<"BonRegie", 'Float'>
    readonly tempsChantier: FieldRef<"BonRegie", 'Float'>
    readonly nombreTechniciens: FieldRef<"BonRegie", 'Int'>
    readonly materiaux: FieldRef<"BonRegie", 'String'>
    readonly nomSignataire: FieldRef<"BonRegie", 'String'>
    readonly signature: FieldRef<"BonRegie", 'String'>
    readonly dateSignature: FieldRef<"BonRegie", 'DateTime'>
    readonly createdAt: FieldRef<"BonRegie", 'DateTime'>
    readonly updatedAt: FieldRef<"BonRegie", 'DateTime'>
    readonly chantierId: FieldRef<"BonRegie", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BonRegie findUnique
   */
  export type BonRegieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * Filter, which BonRegie to fetch.
     */
    where: BonRegieWhereUniqueInput
  }

  /**
   * BonRegie findUniqueOrThrow
   */
  export type BonRegieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * Filter, which BonRegie to fetch.
     */
    where: BonRegieWhereUniqueInput
  }

  /**
   * BonRegie findFirst
   */
  export type BonRegieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * Filter, which BonRegie to fetch.
     */
    where?: BonRegieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BonRegies to fetch.
     */
    orderBy?: BonRegieOrderByWithRelationInput | BonRegieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BonRegies.
     */
    cursor?: BonRegieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BonRegies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BonRegies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BonRegies.
     */
    distinct?: BonRegieScalarFieldEnum | BonRegieScalarFieldEnum[]
  }

  /**
   * BonRegie findFirstOrThrow
   */
  export type BonRegieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * Filter, which BonRegie to fetch.
     */
    where?: BonRegieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BonRegies to fetch.
     */
    orderBy?: BonRegieOrderByWithRelationInput | BonRegieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BonRegies.
     */
    cursor?: BonRegieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BonRegies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BonRegies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BonRegies.
     */
    distinct?: BonRegieScalarFieldEnum | BonRegieScalarFieldEnum[]
  }

  /**
   * BonRegie findMany
   */
  export type BonRegieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * Filter, which BonRegies to fetch.
     */
    where?: BonRegieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BonRegies to fetch.
     */
    orderBy?: BonRegieOrderByWithRelationInput | BonRegieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BonRegies.
     */
    cursor?: BonRegieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BonRegies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BonRegies.
     */
    skip?: number
    distinct?: BonRegieScalarFieldEnum | BonRegieScalarFieldEnum[]
  }

  /**
   * BonRegie create
   */
  export type BonRegieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * The data needed to create a BonRegie.
     */
    data: XOR<BonRegieCreateInput, BonRegieUncheckedCreateInput>
  }

  /**
   * BonRegie createMany
   */
  export type BonRegieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BonRegies.
     */
    data: BonRegieCreateManyInput | BonRegieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BonRegie update
   */
  export type BonRegieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * The data needed to update a BonRegie.
     */
    data: XOR<BonRegieUpdateInput, BonRegieUncheckedUpdateInput>
    /**
     * Choose, which BonRegie to update.
     */
    where: BonRegieWhereUniqueInput
  }

  /**
   * BonRegie updateMany
   */
  export type BonRegieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BonRegies.
     */
    data: XOR<BonRegieUpdateManyMutationInput, BonRegieUncheckedUpdateManyInput>
    /**
     * Filter which BonRegies to update
     */
    where?: BonRegieWhereInput
    /**
     * Limit how many BonRegies to update.
     */
    limit?: number
  }

  /**
   * BonRegie upsert
   */
  export type BonRegieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * The filter to search for the BonRegie to update in case it exists.
     */
    where: BonRegieWhereUniqueInput
    /**
     * In case the BonRegie found by the `where` argument doesn't exist, create a new BonRegie with this data.
     */
    create: XOR<BonRegieCreateInput, BonRegieUncheckedCreateInput>
    /**
     * In case the BonRegie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BonRegieUpdateInput, BonRegieUncheckedUpdateInput>
  }

  /**
   * BonRegie delete
   */
  export type BonRegieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
    /**
     * Filter which BonRegie to delete.
     */
    where: BonRegieWhereUniqueInput
  }

  /**
   * BonRegie deleteMany
   */
  export type BonRegieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BonRegies to delete
     */
    where?: BonRegieWhereInput
    /**
     * Limit how many BonRegies to delete.
     */
    limit?: number
  }

  /**
   * BonRegie.chantier
   */
  export type BonRegie$chantierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chantier
     */
    select?: ChantierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chantier
     */
    omit?: ChantierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChantierInclude<ExtArgs> | null
    where?: ChantierWhereInput
  }

  /**
   * BonRegie without action
   */
  export type BonRegieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonRegie
     */
    select?: BonRegieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BonRegie
     */
    omit?: BonRegieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonRegieInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    logo: 'logo',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const AdmintaskScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    completedBy: 'completedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completed: 'completed',
    completedAt: 'completedAt',
    taskType: 'taskType',
    title: 'title'
  };

  export type AdmintaskScalarFieldEnum = (typeof AdmintaskScalarFieldEnum)[keyof typeof AdmintaskScalarFieldEnum]


  export const PretScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    userId: 'userId',
    datePret: 'datePret',
    dateRetourPrevue: 'dateRetourPrevue',
    dateRetourEffective: 'dateRetourEffective',
    statut: 'statut',
    commentaire: 'commentaire',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emprunteur: 'emprunteur'
  };

  export type PretScalarFieldEnum = (typeof PretScalarFieldEnum)[keyof typeof PretScalarFieldEnum]


  export const SoustraitantScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    contact: 'contact',
    adresse: 'adresse',
    telephone: 'telephone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tva: 'tva'
  };

  export type SoustraitantScalarFieldEnum = (typeof SoustraitantScalarFieldEnum)[keyof typeof SoustraitantScalarFieldEnum]


  export const ContratScalarFieldEnum: {
    id: 'id',
    soustraitantId: 'soustraitantId',
    url: 'url',
    dateGeneration: 'dateGeneration',
    dateSignature: 'dateSignature',
    estSigne: 'estSigne',
    token: 'token'
  };

  export type ContratScalarFieldEnum = (typeof ContratScalarFieldEnum)[keyof typeof ContratScalarFieldEnum]


  export const FicheTechniqueScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    categorie: 'categorie',
    sousCategorie: 'sousCategorie',
    fichierUrl: 'fichierUrl',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referenceCSC: 'referenceCSC'
  };

  export type FicheTechniqueScalarFieldEnum = (typeof FicheTechniqueScalarFieldEnum)[keyof typeof FicheTechniqueScalarFieldEnum]


  export const CommandeScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    clientId: 'clientId',
    dateCommande: 'dateCommande',
    reference: 'reference',
    tauxTVA: 'tauxTVA',
    sousTotal: 'sousTotal',
    totalOptions: 'totalOptions',
    tva: 'tva',
    total: 'total',
    statut: 'statut',
    estVerrouillee: 'estVerrouillee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandeScalarFieldEnum = (typeof CommandeScalarFieldEnum)[keyof typeof CommandeScalarFieldEnum]


  export const LigneCommandeScalarFieldEnum: {
    id: 'id',
    commandeId: 'commandeId',
    ordre: 'ordre',
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite',
    prixUnitaire: 'prixUnitaire',
    quantite: 'quantite',
    total: 'total',
    estOption: 'estOption',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LigneCommandeScalarFieldEnum = (typeof LigneCommandeScalarFieldEnum)[keyof typeof LigneCommandeScalarFieldEnum]


  export const EtatAvancementScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    numero: 'numero',
    date: 'date',
    commentaires: 'commentaires',
    estFinalise: 'estFinalise',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type EtatAvancementScalarFieldEnum = (typeof EtatAvancementScalarFieldEnum)[keyof typeof EtatAvancementScalarFieldEnum]


  export const LigneEtatAvancementScalarFieldEnum: {
    id: 'id',
    etatAvancementId: 'etatAvancementId',
    ligneCommandeId: 'ligneCommandeId',
    quantitePrecedente: 'quantitePrecedente',
    quantiteActuelle: 'quantiteActuelle',
    quantiteTotale: 'quantiteTotale',
    montantPrecedent: 'montantPrecedent',
    montantActuel: 'montantActuel',
    montantTotal: 'montantTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    article: 'article',
    description: 'description',
    prixUnitaire: 'prixUnitaire',
    quantite: 'quantite',
    type: 'type',
    unite: 'unite'
  };

  export type LigneEtatAvancementScalarFieldEnum = (typeof LigneEtatAvancementScalarFieldEnum)[keyof typeof LigneEtatAvancementScalarFieldEnum]


  export const AvenantEtatAvancementScalarFieldEnum: {
    id: 'id',
    etatAvancementId: 'etatAvancementId',
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite',
    prixUnitaire: 'prixUnitaire',
    quantite: 'quantite',
    quantitePrecedente: 'quantitePrecedente',
    quantiteActuelle: 'quantiteActuelle',
    quantiteTotale: 'quantiteTotale',
    montantPrecedent: 'montantPrecedent',
    montantActuel: 'montantActuel',
    montantTotal: 'montantTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvenantEtatAvancementScalarFieldEnum = (typeof AvenantEtatAvancementScalarFieldEnum)[keyof typeof AvenantEtatAvancementScalarFieldEnum]


  export const CompanysettingsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    zipCode: 'zipCode',
    city: 'city',
    phone: 'phone',
    email: 'email',
    tva: 'tva',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailFrom: 'emailFrom',
    emailFromName: 'emailFromName',
    emailHost: 'emailHost',
    emailPassword: 'emailPassword',
    emailPort: 'emailPort',
    emailSecure: 'emailSecure',
    emailUser: 'emailUser',
    iban: 'iban'
  };

  export type CompanysettingsScalarFieldEnum = (typeof CompanysettingsScalarFieldEnum)[keyof typeof CompanysettingsScalarFieldEnum]


  export const CommandeSousTraitantScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    soustraitantId: 'soustraitantId',
    dateCommande: 'dateCommande',
    reference: 'reference',
    tauxTVA: 'tauxTVA',
    sousTotal: 'sousTotal',
    tva: 'tva',
    total: 'total',
    statut: 'statut',
    estVerrouillee: 'estVerrouillee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandeSousTraitantScalarFieldEnum = (typeof CommandeSousTraitantScalarFieldEnum)[keyof typeof CommandeSousTraitantScalarFieldEnum]


  export const LigneCommandeSousTraitantScalarFieldEnum: {
    id: 'id',
    commandeSousTraitantId: 'commandeSousTraitantId',
    ordre: 'ordre',
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite',
    prixUnitaire: 'prixUnitaire',
    quantite: 'quantite',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LigneCommandeSousTraitantScalarFieldEnum = (typeof LigneCommandeSousTraitantScalarFieldEnum)[keyof typeof LigneCommandeSousTraitantScalarFieldEnum]


  export const Avenant_soustraitant_etat_avancementScalarFieldEnum: {
    id: 'id',
    soustraitantEtatAvancementId: 'soustraitantEtatAvancementId',
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite',
    prixUnitaire: 'prixUnitaire',
    quantite: 'quantite',
    quantitePrecedente: 'quantitePrecedente',
    quantiteActuelle: 'quantiteActuelle',
    quantiteTotale: 'quantiteTotale',
    montantPrecedent: 'montantPrecedent',
    montantActuel: 'montantActuel',
    montantTotal: 'montantTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Avenant_soustraitant_etat_avancementScalarFieldEnum = (typeof Avenant_soustraitant_etat_avancementScalarFieldEnum)[keyof typeof Avenant_soustraitant_etat_avancementScalarFieldEnum]


  export const Ligne_soustraitant_etat_avancementScalarFieldEnum: {
    id: 'id',
    soustraitantEtatAvancementId: 'soustraitantEtatAvancementId',
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite',
    prixUnitaire: 'prixUnitaire',
    quantite: 'quantite',
    quantitePrecedente: 'quantitePrecedente',
    quantiteActuelle: 'quantiteActuelle',
    quantiteTotale: 'quantiteTotale',
    montantPrecedent: 'montantPrecedent',
    montantActuel: 'montantActuel',
    montantTotal: 'montantTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Ligne_soustraitant_etat_avancementScalarFieldEnum = (typeof Ligne_soustraitant_etat_avancementScalarFieldEnum)[keyof typeof Ligne_soustraitant_etat_avancementScalarFieldEnum]


  export const Soustraitant_etat_avancementScalarFieldEnum: {
    id: 'id',
    soustraitantId: 'soustraitantId',
    numero: 'numero',
    date: 'date',
    commentaires: 'commentaires',
    estFinalise: 'estFinalise',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    commandeSousTraitantId: 'commandeSousTraitantId',
    etatAvancementId: 'etatAvancementId'
  };

  export type Soustraitant_etat_avancementScalarFieldEnum = (typeof Soustraitant_etat_avancementScalarFieldEnum)[keyof typeof Soustraitant_etat_avancementScalarFieldEnum]


  export const Photo_soustraitant_etat_avancementScalarFieldEnum: {
    id: 'id',
    soustraitantEtatAvancementId: 'soustraitantEtatAvancementId',
    url: 'url',
    description: 'description',
    dateAjout: 'dateAjout'
  };

  export type Photo_soustraitant_etat_avancementScalarFieldEnum = (typeof Photo_soustraitant_etat_avancementScalarFieldEnum)[keyof typeof Photo_soustraitant_etat_avancementScalarFieldEnum]


  export const DepenseScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    date: 'date',
    montant: 'montant',
    description: 'description',
    categorie: 'categorie',
    fournisseur: 'fournisseur',
    reference: 'reference',
    justificatif: 'justificatif',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepenseScalarFieldEnum = (typeof DepenseScalarFieldEnum)[keyof typeof DepenseScalarFieldEnum]


  export const UserNotesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserNotesScalarFieldEnum = (typeof UserNotesScalarFieldEnum)[keyof typeof UserNotesScalarFieldEnum]


  export const RackScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    position: 'position',
    lignes: 'lignes',
    colonnes: 'colonnes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RackScalarFieldEnum = (typeof RackScalarFieldEnum)[keyof typeof RackScalarFieldEnum]


  export const EmplacementScalarFieldEnum: {
    id: 'id',
    rackId: 'rackId',
    ligne: 'ligne',
    colonne: 'colonne',
    codeQR: 'codeQR',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmplacementScalarFieldEnum = (typeof EmplacementScalarFieldEnum)[keyof typeof EmplacementScalarFieldEnum]


  export const MateriauScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    quantite: 'quantite',
    codeQR: 'codeQR',
    emplacementId: 'emplacementId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MateriauScalarFieldEnum = (typeof MateriauScalarFieldEnum)[keyof typeof MateriauScalarFieldEnum]


  export const AvenantScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    date: 'date',
    description: 'description',
    chantierId: 'chantierId',
    marcheId: 'marcheId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvenantScalarFieldEnum = (typeof AvenantScalarFieldEnum)[keyof typeof AvenantScalarFieldEnum]


  export const ChantierScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    nomChantier: 'nomChantier',
    adresseChantier: 'adresseChantier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    budget: 'budget',
    dateDebut: 'dateDebut',
    dateFinPrevue: 'dateFinPrevue',
    dateFinReelle: 'dateFinReelle',
    description: 'description',
    statut: 'statut',
    villeChantier: 'villeChantier',
    dureeEnJours: 'dureeEnJours',
    typeDuree: 'typeDuree'
  };

  export type ChantierScalarFieldEnum = (typeof ChantierScalarFieldEnum)[keyof typeof ChantierScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    adresse: 'adresse',
    telephone: 'telephone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    type: 'type',
    url: 'url',
    taille: 'taille',
    mimeType: 'mimeType',
    chantierId: 'chantierId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentOuvrierScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    type: 'type',
    url: 'url',
    dateExpiration: 'dateExpiration',
    ouvrierId: 'ouvrierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentOuvrierScalarFieldEnum = (typeof DocumentOuvrierScalarFieldEnum)[keyof typeof DocumentOuvrierScalarFieldEnum]


  export const EtatScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    date: 'date',
    chantierId: 'chantierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EtatScalarFieldEnum = (typeof EtatScalarFieldEnum)[keyof typeof EtatScalarFieldEnum]


  export const LigneEtatScalarFieldEnum: {
    id: 'id',
    etatId: 'etatId',
    ligneMarcheId: 'ligneMarcheId',
    quantite: 'quantite',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LigneEtatScalarFieldEnum = (typeof LigneEtatScalarFieldEnum)[keyof typeof LigneEtatScalarFieldEnum]


  export const LigneMarcheScalarFieldEnum: {
    id: 'id',
    article: 'article',
    descriptif: 'descriptif',
    unite: 'unite',
    quantite: 'quantite',
    prixUnitaire: 'prixUnitaire',
    marcheId: 'marcheId'
  };

  export type LigneMarcheScalarFieldEnum = (typeof LigneMarcheScalarFieldEnum)[keyof typeof LigneMarcheScalarFieldEnum]


  export const MachineScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    modele: 'modele',
    numeroSerie: 'numeroSerie',
    localisation: 'localisation',
    statut: 'statut',
    dateAchat: 'dateAchat',
    qrCode: 'qrCode',
    commentaire: 'commentaire',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const MarcheScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    dateImport: 'dateImport',
    montantTotal: 'montantTotal'
  };

  export type MarcheScalarFieldEnum = (typeof MarcheScalarFieldEnum)[keyof typeof MarcheScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    contenu: 'contenu',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const OuvrierScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    telephone: 'telephone',
    dateEntree: 'dateEntree',
    poste: 'poste',
    sousTraitantId: 'sousTraitantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OuvrierScalarFieldEnum = (typeof OuvrierScalarFieldEnum)[keyof typeof OuvrierScalarFieldEnum]


  export const TacheScalarFieldEnum: {
    id: 'id',
    label: 'label',
    completed: 'completed',
    completedAt: 'completedAt',
    chantierId: 'chantierId',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TacheScalarFieldEnum = (typeof TacheScalarFieldEnum)[keyof typeof TacheScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BonRegieScalarFieldEnum: {
    id: 'id',
    dates: 'dates',
    client: 'client',
    nomChantier: 'nomChantier',
    description: 'description',
    tempsPreparation: 'tempsPreparation',
    tempsTrajets: 'tempsTrajets',
    tempsChantier: 'tempsChantier',
    nombreTechniciens: 'nombreTechniciens',
    materiaux: 'materiaux',
    nomSignataire: 'nomSignataire',
    signature: 'signature',
    dateSignature: 'dateSignature',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    chantierId: 'chantierId'
  };

  export type BonRegieScalarFieldEnum = (typeof BonRegieScalarFieldEnum)[keyof typeof BonRegieScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SettingsOrderByRelevanceFieldEnum: {
    logo: 'logo'
  };

  export type SettingsOrderByRelevanceFieldEnum = (typeof SettingsOrderByRelevanceFieldEnum)[keyof typeof SettingsOrderByRelevanceFieldEnum]


  export const admintaskOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId',
    completedBy: 'completedBy',
    taskType: 'taskType',
    title: 'title'
  };

  export type admintaskOrderByRelevanceFieldEnum = (typeof admintaskOrderByRelevanceFieldEnum)[keyof typeof admintaskOrderByRelevanceFieldEnum]


  export const pretOrderByRelevanceFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    userId: 'userId',
    commentaire: 'commentaire',
    emprunteur: 'emprunteur'
  };

  export type pretOrderByRelevanceFieldEnum = (typeof pretOrderByRelevanceFieldEnum)[keyof typeof pretOrderByRelevanceFieldEnum]


  export const soustraitantOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    contact: 'contact',
    adresse: 'adresse',
    telephone: 'telephone',
    tva: 'tva'
  };

  export type soustraitantOrderByRelevanceFieldEnum = (typeof soustraitantOrderByRelevanceFieldEnum)[keyof typeof soustraitantOrderByRelevanceFieldEnum]


  export const contratOrderByRelevanceFieldEnum: {
    id: 'id',
    soustraitantId: 'soustraitantId',
    url: 'url',
    token: 'token'
  };

  export type contratOrderByRelevanceFieldEnum = (typeof contratOrderByRelevanceFieldEnum)[keyof typeof contratOrderByRelevanceFieldEnum]


  export const FicheTechniqueOrderByRelevanceFieldEnum: {
    id: 'id',
    titre: 'titre',
    categorie: 'categorie',
    sousCategorie: 'sousCategorie',
    fichierUrl: 'fichierUrl',
    description: 'description',
    referenceCSC: 'referenceCSC'
  };

  export type FicheTechniqueOrderByRelevanceFieldEnum = (typeof FicheTechniqueOrderByRelevanceFieldEnum)[keyof typeof FicheTechniqueOrderByRelevanceFieldEnum]


  export const CommandeOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId',
    clientId: 'clientId',
    reference: 'reference',
    statut: 'statut'
  };

  export type CommandeOrderByRelevanceFieldEnum = (typeof CommandeOrderByRelevanceFieldEnum)[keyof typeof CommandeOrderByRelevanceFieldEnum]


  export const LigneCommandeOrderByRelevanceFieldEnum: {
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite'
  };

  export type LigneCommandeOrderByRelevanceFieldEnum = (typeof LigneCommandeOrderByRelevanceFieldEnum)[keyof typeof LigneCommandeOrderByRelevanceFieldEnum]


  export const EtatAvancementOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId',
    commentaires: 'commentaires',
    createdBy: 'createdBy'
  };

  export type EtatAvancementOrderByRelevanceFieldEnum = (typeof EtatAvancementOrderByRelevanceFieldEnum)[keyof typeof EtatAvancementOrderByRelevanceFieldEnum]


  export const LigneEtatAvancementOrderByRelevanceFieldEnum: {
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite'
  };

  export type LigneEtatAvancementOrderByRelevanceFieldEnum = (typeof LigneEtatAvancementOrderByRelevanceFieldEnum)[keyof typeof LigneEtatAvancementOrderByRelevanceFieldEnum]


  export const AvenantEtatAvancementOrderByRelevanceFieldEnum: {
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite'
  };

  export type AvenantEtatAvancementOrderByRelevanceFieldEnum = (typeof AvenantEtatAvancementOrderByRelevanceFieldEnum)[keyof typeof AvenantEtatAvancementOrderByRelevanceFieldEnum]


  export const companysettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    zipCode: 'zipCode',
    city: 'city',
    phone: 'phone',
    email: 'email',
    tva: 'tva',
    logo: 'logo',
    emailFrom: 'emailFrom',
    emailFromName: 'emailFromName',
    emailHost: 'emailHost',
    emailPassword: 'emailPassword',
    emailPort: 'emailPort',
    emailUser: 'emailUser',
    iban: 'iban'
  };

  export type companysettingsOrderByRelevanceFieldEnum = (typeof companysettingsOrderByRelevanceFieldEnum)[keyof typeof companysettingsOrderByRelevanceFieldEnum]


  export const CommandeSousTraitantOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId',
    soustraitantId: 'soustraitantId',
    reference: 'reference',
    statut: 'statut'
  };

  export type CommandeSousTraitantOrderByRelevanceFieldEnum = (typeof CommandeSousTraitantOrderByRelevanceFieldEnum)[keyof typeof CommandeSousTraitantOrderByRelevanceFieldEnum]


  export const LigneCommandeSousTraitantOrderByRelevanceFieldEnum: {
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite'
  };

  export type LigneCommandeSousTraitantOrderByRelevanceFieldEnum = (typeof LigneCommandeSousTraitantOrderByRelevanceFieldEnum)[keyof typeof LigneCommandeSousTraitantOrderByRelevanceFieldEnum]


  export const avenant_soustraitant_etat_avancementOrderByRelevanceFieldEnum: {
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite'
  };

  export type avenant_soustraitant_etat_avancementOrderByRelevanceFieldEnum = (typeof avenant_soustraitant_etat_avancementOrderByRelevanceFieldEnum)[keyof typeof avenant_soustraitant_etat_avancementOrderByRelevanceFieldEnum]


  export const ligne_soustraitant_etat_avancementOrderByRelevanceFieldEnum: {
    article: 'article',
    description: 'description',
    type: 'type',
    unite: 'unite'
  };

  export type ligne_soustraitant_etat_avancementOrderByRelevanceFieldEnum = (typeof ligne_soustraitant_etat_avancementOrderByRelevanceFieldEnum)[keyof typeof ligne_soustraitant_etat_avancementOrderByRelevanceFieldEnum]


  export const soustraitant_etat_avancementOrderByRelevanceFieldEnum: {
    soustraitantId: 'soustraitantId',
    commentaires: 'commentaires'
  };

  export type soustraitant_etat_avancementOrderByRelevanceFieldEnum = (typeof soustraitant_etat_avancementOrderByRelevanceFieldEnum)[keyof typeof soustraitant_etat_avancementOrderByRelevanceFieldEnum]


  export const photo_soustraitant_etat_avancementOrderByRelevanceFieldEnum: {
    url: 'url',
    description: 'description'
  };

  export type photo_soustraitant_etat_avancementOrderByRelevanceFieldEnum = (typeof photo_soustraitant_etat_avancementOrderByRelevanceFieldEnum)[keyof typeof photo_soustraitant_etat_avancementOrderByRelevanceFieldEnum]


  export const DepenseOrderByRelevanceFieldEnum: {
    id: 'id',
    chantierId: 'chantierId',
    description: 'description',
    categorie: 'categorie',
    fournisseur: 'fournisseur',
    reference: 'reference',
    justificatif: 'justificatif',
    createdBy: 'createdBy'
  };

  export type DepenseOrderByRelevanceFieldEnum = (typeof DepenseOrderByRelevanceFieldEnum)[keyof typeof DepenseOrderByRelevanceFieldEnum]


  export const UserNotesOrderByRelevanceFieldEnum: {
    userId: 'userId',
    content: 'content'
  };

  export type UserNotesOrderByRelevanceFieldEnum = (typeof UserNotesOrderByRelevanceFieldEnum)[keyof typeof UserNotesOrderByRelevanceFieldEnum]


  export const RackOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    position: 'position'
  };

  export type RackOrderByRelevanceFieldEnum = (typeof RackOrderByRelevanceFieldEnum)[keyof typeof RackOrderByRelevanceFieldEnum]


  export const EmplacementOrderByRelevanceFieldEnum: {
    id: 'id',
    rackId: 'rackId',
    codeQR: 'codeQR',
    statut: 'statut'
  };

  export type EmplacementOrderByRelevanceFieldEnum = (typeof EmplacementOrderByRelevanceFieldEnum)[keyof typeof EmplacementOrderByRelevanceFieldEnum]


  export const MateriauOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    codeQR: 'codeQR',
    emplacementId: 'emplacementId'
  };

  export type MateriauOrderByRelevanceFieldEnum = (typeof MateriauOrderByRelevanceFieldEnum)[keyof typeof MateriauOrderByRelevanceFieldEnum]


  export const AvenantOrderByRelevanceFieldEnum: {
    description: 'description',
    chantierId: 'chantierId'
  };

  export type AvenantOrderByRelevanceFieldEnum = (typeof AvenantOrderByRelevanceFieldEnum)[keyof typeof AvenantOrderByRelevanceFieldEnum]


  export const ChantierOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId',
    nomChantier: 'nomChantier',
    adresseChantier: 'adresseChantier',
    clientId: 'clientId',
    description: 'description',
    statut: 'statut',
    villeChantier: 'villeChantier',
    typeDuree: 'typeDuree'
  };

  export type ChantierOrderByRelevanceFieldEnum = (typeof ChantierOrderByRelevanceFieldEnum)[keyof typeof ChantierOrderByRelevanceFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    adresse: 'adresse',
    telephone: 'telephone'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const DocumentOrderByRelevanceFieldEnum: {
    nom: 'nom',
    type: 'type',
    url: 'url',
    mimeType: 'mimeType',
    chantierId: 'chantierId',
    createdBy: 'createdBy'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const DocumentOuvrierOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    type: 'type',
    url: 'url',
    ouvrierId: 'ouvrierId'
  };

  export type DocumentOuvrierOrderByRelevanceFieldEnum = (typeof DocumentOuvrierOrderByRelevanceFieldEnum)[keyof typeof DocumentOuvrierOrderByRelevanceFieldEnum]


  export const EtatOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId'
  };

  export type EtatOrderByRelevanceFieldEnum = (typeof EtatOrderByRelevanceFieldEnum)[keyof typeof EtatOrderByRelevanceFieldEnum]


  export const LigneMarcheOrderByRelevanceFieldEnum: {
    descriptif: 'descriptif',
    unite: 'unite'
  };

  export type LigneMarcheOrderByRelevanceFieldEnum = (typeof LigneMarcheOrderByRelevanceFieldEnum)[keyof typeof LigneMarcheOrderByRelevanceFieldEnum]


  export const MachineOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    modele: 'modele',
    numeroSerie: 'numeroSerie',
    localisation: 'localisation',
    qrCode: 'qrCode',
    commentaire: 'commentaire'
  };

  export type MachineOrderByRelevanceFieldEnum = (typeof MachineOrderByRelevanceFieldEnum)[keyof typeof MachineOrderByRelevanceFieldEnum]


  export const MarcheOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId'
  };

  export type MarcheOrderByRelevanceFieldEnum = (typeof MarcheOrderByRelevanceFieldEnum)[keyof typeof MarcheOrderByRelevanceFieldEnum]


  export const NoteOrderByRelevanceFieldEnum: {
    chantierId: 'chantierId',
    contenu: 'contenu',
    createdBy: 'createdBy'
  };

  export type NoteOrderByRelevanceFieldEnum = (typeof NoteOrderByRelevanceFieldEnum)[keyof typeof NoteOrderByRelevanceFieldEnum]


  export const OuvrierOrderByRelevanceFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    telephone: 'telephone',
    poste: 'poste',
    sousTraitantId: 'sousTraitantId'
  };

  export type OuvrierOrderByRelevanceFieldEnum = (typeof OuvrierOrderByRelevanceFieldEnum)[keyof typeof OuvrierOrderByRelevanceFieldEnum]


  export const TacheOrderByRelevanceFieldEnum: {
    id: 'id',
    label: 'label',
    chantierId: 'chantierId',
    category: 'category'
  };

  export type TacheOrderByRelevanceFieldEnum = (typeof TacheOrderByRelevanceFieldEnum)[keyof typeof TacheOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const BonRegieOrderByRelevanceFieldEnum: {
    dates: 'dates',
    client: 'client',
    nomChantier: 'nomChantier',
    description: 'description',
    materiaux: 'materiaux',
    nomSignataire: 'nomSignataire',
    signature: 'signature',
    chantierId: 'chantierId'
  };

  export type BonRegieOrderByRelevanceFieldEnum = (typeof BonRegieOrderByRelevanceFieldEnum)[keyof typeof BonRegieOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'pret_statut'
   */
  export type Enumpret_statutFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'pret_statut'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Machine_statut'
   */
  export type EnumMachine_statutFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Machine_statut'>
    


  /**
   * Reference to a field of type 'User_role'
   */
  export type EnumUser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'User_role'>
    
  /**
   * Deep Input Types
   */


  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    logo?: StringNullableFilter<"Settings"> | string | null
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    logo?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _relevance?: SettingsOrderByRelevanceInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    logo?: StringNullableFilter<"Settings"> | string | null
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    logo?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    logo?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type admintaskWhereInput = {
    AND?: admintaskWhereInput | admintaskWhereInput[]
    OR?: admintaskWhereInput[]
    NOT?: admintaskWhereInput | admintaskWhereInput[]
    id?: IntFilter<"admintask"> | number
    chantierId?: StringFilter<"admintask"> | string
    completedBy?: StringNullableFilter<"admintask"> | string | null
    createdAt?: DateTimeFilter<"admintask"> | Date | string
    updatedAt?: DateTimeFilter<"admintask"> | Date | string
    completed?: BoolFilter<"admintask"> | boolean
    completedAt?: DateTimeNullableFilter<"admintask"> | Date | string | null
    taskType?: StringFilter<"admintask"> | string
    title?: StringNullableFilter<"admintask"> | string | null
    chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type admintaskOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    taskType?: SortOrder
    title?: SortOrderInput | SortOrder
    chantier?: ChantierOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: admintaskOrderByRelevanceInput
  }

  export type admintaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chantierId_taskType?: admintaskChantierIdTaskTypeCompoundUniqueInput
    AND?: admintaskWhereInput | admintaskWhereInput[]
    OR?: admintaskWhereInput[]
    NOT?: admintaskWhereInput | admintaskWhereInput[]
    chantierId?: StringFilter<"admintask"> | string
    completedBy?: StringNullableFilter<"admintask"> | string | null
    createdAt?: DateTimeFilter<"admintask"> | Date | string
    updatedAt?: DateTimeFilter<"admintask"> | Date | string
    completed?: BoolFilter<"admintask"> | boolean
    completedAt?: DateTimeNullableFilter<"admintask"> | Date | string | null
    taskType?: StringFilter<"admintask"> | string
    title?: StringNullableFilter<"admintask"> | string | null
    chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "chantierId_taskType">

  export type admintaskOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    taskType?: SortOrder
    title?: SortOrderInput | SortOrder
    _count?: admintaskCountOrderByAggregateInput
    _avg?: admintaskAvgOrderByAggregateInput
    _max?: admintaskMaxOrderByAggregateInput
    _min?: admintaskMinOrderByAggregateInput
    _sum?: admintaskSumOrderByAggregateInput
  }

  export type admintaskScalarWhereWithAggregatesInput = {
    AND?: admintaskScalarWhereWithAggregatesInput | admintaskScalarWhereWithAggregatesInput[]
    OR?: admintaskScalarWhereWithAggregatesInput[]
    NOT?: admintaskScalarWhereWithAggregatesInput | admintaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admintask"> | number
    chantierId?: StringWithAggregatesFilter<"admintask"> | string
    completedBy?: StringNullableWithAggregatesFilter<"admintask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"admintask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"admintask"> | Date | string
    completed?: BoolWithAggregatesFilter<"admintask"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"admintask"> | Date | string | null
    taskType?: StringWithAggregatesFilter<"admintask"> | string
    title?: StringNullableWithAggregatesFilter<"admintask"> | string | null
  }

  export type pretWhereInput = {
    AND?: pretWhereInput | pretWhereInput[]
    OR?: pretWhereInput[]
    NOT?: pretWhereInput | pretWhereInput[]
    id?: StringFilter<"pret"> | string
    machineId?: StringFilter<"pret"> | string
    userId?: StringFilter<"pret"> | string
    datePret?: DateTimeFilter<"pret"> | Date | string
    dateRetourPrevue?: DateTimeFilter<"pret"> | Date | string
    dateRetourEffective?: DateTimeNullableFilter<"pret"> | Date | string | null
    statut?: Enumpret_statutFilter<"pret"> | $Enums.pret_statut
    commentaire?: StringNullableFilter<"pret"> | string | null
    createdAt?: DateTimeFilter<"pret"> | Date | string
    updatedAt?: DateTimeFilter<"pret"> | Date | string
    emprunteur?: StringFilter<"pret"> | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type pretOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
    datePret?: SortOrder
    dateRetourPrevue?: SortOrder
    dateRetourEffective?: SortOrderInput | SortOrder
    statut?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprunteur?: SortOrder
    machine?: MachineOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: pretOrderByRelevanceInput
  }

  export type pretWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: pretWhereInput | pretWhereInput[]
    OR?: pretWhereInput[]
    NOT?: pretWhereInput | pretWhereInput[]
    machineId?: StringFilter<"pret"> | string
    userId?: StringFilter<"pret"> | string
    datePret?: DateTimeFilter<"pret"> | Date | string
    dateRetourPrevue?: DateTimeFilter<"pret"> | Date | string
    dateRetourEffective?: DateTimeNullableFilter<"pret"> | Date | string | null
    statut?: Enumpret_statutFilter<"pret"> | $Enums.pret_statut
    commentaire?: StringNullableFilter<"pret"> | string | null
    createdAt?: DateTimeFilter<"pret"> | Date | string
    updatedAt?: DateTimeFilter<"pret"> | Date | string
    emprunteur?: StringFilter<"pret"> | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type pretOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
    datePret?: SortOrder
    dateRetourPrevue?: SortOrder
    dateRetourEffective?: SortOrderInput | SortOrder
    statut?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprunteur?: SortOrder
    _count?: pretCountOrderByAggregateInput
    _max?: pretMaxOrderByAggregateInput
    _min?: pretMinOrderByAggregateInput
  }

  export type pretScalarWhereWithAggregatesInput = {
    AND?: pretScalarWhereWithAggregatesInput | pretScalarWhereWithAggregatesInput[]
    OR?: pretScalarWhereWithAggregatesInput[]
    NOT?: pretScalarWhereWithAggregatesInput | pretScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pret"> | string
    machineId?: StringWithAggregatesFilter<"pret"> | string
    userId?: StringWithAggregatesFilter<"pret"> | string
    datePret?: DateTimeWithAggregatesFilter<"pret"> | Date | string
    dateRetourPrevue?: DateTimeWithAggregatesFilter<"pret"> | Date | string
    dateRetourEffective?: DateTimeNullableWithAggregatesFilter<"pret"> | Date | string | null
    statut?: Enumpret_statutWithAggregatesFilter<"pret"> | $Enums.pret_statut
    commentaire?: StringNullableWithAggregatesFilter<"pret"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"pret"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pret"> | Date | string
    emprunteur?: StringWithAggregatesFilter<"pret"> | string
  }

  export type soustraitantWhereInput = {
    AND?: soustraitantWhereInput | soustraitantWhereInput[]
    OR?: soustraitantWhereInput[]
    NOT?: soustraitantWhereInput | soustraitantWhereInput[]
    id?: StringFilter<"soustraitant"> | string
    nom?: StringFilter<"soustraitant"> | string
    email?: StringFilter<"soustraitant"> | string
    contact?: StringNullableFilter<"soustraitant"> | string | null
    adresse?: StringNullableFilter<"soustraitant"> | string | null
    telephone?: StringNullableFilter<"soustraitant"> | string | null
    createdAt?: DateTimeFilter<"soustraitant"> | Date | string
    updatedAt?: DateTimeFilter<"soustraitant"> | Date | string
    tva?: StringNullableFilter<"soustraitant"> | string | null
    commandes?: CommandeSousTraitantListRelationFilter
    contrats?: ContratListRelationFilter
    soustraitant_etat_avancement?: Soustraitant_etat_avancementListRelationFilter
  }

  export type soustraitantOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    contact?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tva?: SortOrderInput | SortOrder
    commandes?: CommandeSousTraitantOrderByRelationAggregateInput
    contrats?: contratOrderByRelationAggregateInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementOrderByRelationAggregateInput
    _relevance?: soustraitantOrderByRelevanceInput
  }

  export type soustraitantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: soustraitantWhereInput | soustraitantWhereInput[]
    OR?: soustraitantWhereInput[]
    NOT?: soustraitantWhereInput | soustraitantWhereInput[]
    nom?: StringFilter<"soustraitant"> | string
    contact?: StringNullableFilter<"soustraitant"> | string | null
    adresse?: StringNullableFilter<"soustraitant"> | string | null
    telephone?: StringNullableFilter<"soustraitant"> | string | null
    createdAt?: DateTimeFilter<"soustraitant"> | Date | string
    updatedAt?: DateTimeFilter<"soustraitant"> | Date | string
    tva?: StringNullableFilter<"soustraitant"> | string | null
    commandes?: CommandeSousTraitantListRelationFilter
    contrats?: ContratListRelationFilter
    soustraitant_etat_avancement?: Soustraitant_etat_avancementListRelationFilter
  }, "id" | "email">

  export type soustraitantOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    contact?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tva?: SortOrderInput | SortOrder
    _count?: soustraitantCountOrderByAggregateInput
    _max?: soustraitantMaxOrderByAggregateInput
    _min?: soustraitantMinOrderByAggregateInput
  }

  export type soustraitantScalarWhereWithAggregatesInput = {
    AND?: soustraitantScalarWhereWithAggregatesInput | soustraitantScalarWhereWithAggregatesInput[]
    OR?: soustraitantScalarWhereWithAggregatesInput[]
    NOT?: soustraitantScalarWhereWithAggregatesInput | soustraitantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"soustraitant"> | string
    nom?: StringWithAggregatesFilter<"soustraitant"> | string
    email?: StringWithAggregatesFilter<"soustraitant"> | string
    contact?: StringNullableWithAggregatesFilter<"soustraitant"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"soustraitant"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"soustraitant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"soustraitant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"soustraitant"> | Date | string
    tva?: StringNullableWithAggregatesFilter<"soustraitant"> | string | null
  }

  export type contratWhereInput = {
    AND?: contratWhereInput | contratWhereInput[]
    OR?: contratWhereInput[]
    NOT?: contratWhereInput | contratWhereInput[]
    id?: StringFilter<"contrat"> | string
    soustraitantId?: StringFilter<"contrat"> | string
    url?: StringFilter<"contrat"> | string
    dateGeneration?: DateTimeFilter<"contrat"> | Date | string
    dateSignature?: DateTimeNullableFilter<"contrat"> | Date | string | null
    estSigne?: BoolFilter<"contrat"> | boolean
    token?: StringNullableFilter<"contrat"> | string | null
    soustraitant?: XOR<SoustraitantScalarRelationFilter, soustraitantWhereInput>
  }

  export type contratOrderByWithRelationInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    url?: SortOrder
    dateGeneration?: SortOrder
    dateSignature?: SortOrderInput | SortOrder
    estSigne?: SortOrder
    token?: SortOrderInput | SortOrder
    soustraitant?: soustraitantOrderByWithRelationInput
    _relevance?: contratOrderByRelevanceInput
  }

  export type contratWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: contratWhereInput | contratWhereInput[]
    OR?: contratWhereInput[]
    NOT?: contratWhereInput | contratWhereInput[]
    soustraitantId?: StringFilter<"contrat"> | string
    url?: StringFilter<"contrat"> | string
    dateGeneration?: DateTimeFilter<"contrat"> | Date | string
    dateSignature?: DateTimeNullableFilter<"contrat"> | Date | string | null
    estSigne?: BoolFilter<"contrat"> | boolean
    soustraitant?: XOR<SoustraitantScalarRelationFilter, soustraitantWhereInput>
  }, "id" | "token">

  export type contratOrderByWithAggregationInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    url?: SortOrder
    dateGeneration?: SortOrder
    dateSignature?: SortOrderInput | SortOrder
    estSigne?: SortOrder
    token?: SortOrderInput | SortOrder
    _count?: contratCountOrderByAggregateInput
    _max?: contratMaxOrderByAggregateInput
    _min?: contratMinOrderByAggregateInput
  }

  export type contratScalarWhereWithAggregatesInput = {
    AND?: contratScalarWhereWithAggregatesInput | contratScalarWhereWithAggregatesInput[]
    OR?: contratScalarWhereWithAggregatesInput[]
    NOT?: contratScalarWhereWithAggregatesInput | contratScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contrat"> | string
    soustraitantId?: StringWithAggregatesFilter<"contrat"> | string
    url?: StringWithAggregatesFilter<"contrat"> | string
    dateGeneration?: DateTimeWithAggregatesFilter<"contrat"> | Date | string
    dateSignature?: DateTimeNullableWithAggregatesFilter<"contrat"> | Date | string | null
    estSigne?: BoolWithAggregatesFilter<"contrat"> | boolean
    token?: StringNullableWithAggregatesFilter<"contrat"> | string | null
  }

  export type FicheTechniqueWhereInput = {
    AND?: FicheTechniqueWhereInput | FicheTechniqueWhereInput[]
    OR?: FicheTechniqueWhereInput[]
    NOT?: FicheTechniqueWhereInput | FicheTechniqueWhereInput[]
    id?: StringFilter<"FicheTechnique"> | string
    titre?: StringFilter<"FicheTechnique"> | string
    categorie?: StringFilter<"FicheTechnique"> | string
    sousCategorie?: StringNullableFilter<"FicheTechnique"> | string | null
    fichierUrl?: StringFilter<"FicheTechnique"> | string
    description?: StringNullableFilter<"FicheTechnique"> | string | null
    createdAt?: DateTimeFilter<"FicheTechnique"> | Date | string
    updatedAt?: DateTimeFilter<"FicheTechnique"> | Date | string
    referenceCSC?: StringNullableFilter<"FicheTechnique"> | string | null
  }

  export type FicheTechniqueOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    categorie?: SortOrder
    sousCategorie?: SortOrderInput | SortOrder
    fichierUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceCSC?: SortOrderInput | SortOrder
    _relevance?: FicheTechniqueOrderByRelevanceInput
  }

  export type FicheTechniqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FicheTechniqueWhereInput | FicheTechniqueWhereInput[]
    OR?: FicheTechniqueWhereInput[]
    NOT?: FicheTechniqueWhereInput | FicheTechniqueWhereInput[]
    titre?: StringFilter<"FicheTechnique"> | string
    categorie?: StringFilter<"FicheTechnique"> | string
    sousCategorie?: StringNullableFilter<"FicheTechnique"> | string | null
    fichierUrl?: StringFilter<"FicheTechnique"> | string
    description?: StringNullableFilter<"FicheTechnique"> | string | null
    createdAt?: DateTimeFilter<"FicheTechnique"> | Date | string
    updatedAt?: DateTimeFilter<"FicheTechnique"> | Date | string
    referenceCSC?: StringNullableFilter<"FicheTechnique"> | string | null
  }, "id">

  export type FicheTechniqueOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    categorie?: SortOrder
    sousCategorie?: SortOrderInput | SortOrder
    fichierUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceCSC?: SortOrderInput | SortOrder
    _count?: FicheTechniqueCountOrderByAggregateInput
    _max?: FicheTechniqueMaxOrderByAggregateInput
    _min?: FicheTechniqueMinOrderByAggregateInput
  }

  export type FicheTechniqueScalarWhereWithAggregatesInput = {
    AND?: FicheTechniqueScalarWhereWithAggregatesInput | FicheTechniqueScalarWhereWithAggregatesInput[]
    OR?: FicheTechniqueScalarWhereWithAggregatesInput[]
    NOT?: FicheTechniqueScalarWhereWithAggregatesInput | FicheTechniqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FicheTechnique"> | string
    titre?: StringWithAggregatesFilter<"FicheTechnique"> | string
    categorie?: StringWithAggregatesFilter<"FicheTechnique"> | string
    sousCategorie?: StringNullableWithAggregatesFilter<"FicheTechnique"> | string | null
    fichierUrl?: StringWithAggregatesFilter<"FicheTechnique"> | string
    description?: StringNullableWithAggregatesFilter<"FicheTechnique"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FicheTechnique"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FicheTechnique"> | Date | string
    referenceCSC?: StringNullableWithAggregatesFilter<"FicheTechnique"> | string | null
  }

  export type CommandeWhereInput = {
    AND?: CommandeWhereInput | CommandeWhereInput[]
    OR?: CommandeWhereInput[]
    NOT?: CommandeWhereInput | CommandeWhereInput[]
    id?: IntFilter<"Commande"> | number
    chantierId?: StringFilter<"Commande"> | string
    clientId?: StringNullableFilter<"Commande"> | string | null
    dateCommande?: DateTimeFilter<"Commande"> | Date | string
    reference?: StringNullableFilter<"Commande"> | string | null
    tauxTVA?: FloatFilter<"Commande"> | number
    sousTotal?: FloatFilter<"Commande"> | number
    totalOptions?: FloatFilter<"Commande"> | number
    tva?: FloatFilter<"Commande"> | number
    total?: FloatFilter<"Commande"> | number
    statut?: StringFilter<"Commande"> | string
    estVerrouillee?: BoolFilter<"Commande"> | boolean
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
    lignes?: LigneCommandeListRelationFilter
  }

  export type CommandeOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    dateCommande?: SortOrder
    reference?: SortOrderInput | SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lignes?: LigneCommandeOrderByRelationAggregateInput
    _relevance?: CommandeOrderByRelevanceInput
  }

  export type CommandeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandeWhereInput | CommandeWhereInput[]
    OR?: CommandeWhereInput[]
    NOT?: CommandeWhereInput | CommandeWhereInput[]
    chantierId?: StringFilter<"Commande"> | string
    clientId?: StringNullableFilter<"Commande"> | string | null
    dateCommande?: DateTimeFilter<"Commande"> | Date | string
    reference?: StringNullableFilter<"Commande"> | string | null
    tauxTVA?: FloatFilter<"Commande"> | number
    sousTotal?: FloatFilter<"Commande"> | number
    totalOptions?: FloatFilter<"Commande"> | number
    tva?: FloatFilter<"Commande"> | number
    total?: FloatFilter<"Commande"> | number
    statut?: StringFilter<"Commande"> | string
    estVerrouillee?: BoolFilter<"Commande"> | boolean
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
    lignes?: LigneCommandeListRelationFilter
  }, "id">

  export type CommandeOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    dateCommande?: SortOrder
    reference?: SortOrderInput | SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandeCountOrderByAggregateInput
    _avg?: CommandeAvgOrderByAggregateInput
    _max?: CommandeMaxOrderByAggregateInput
    _min?: CommandeMinOrderByAggregateInput
    _sum?: CommandeSumOrderByAggregateInput
  }

  export type CommandeScalarWhereWithAggregatesInput = {
    AND?: CommandeScalarWhereWithAggregatesInput | CommandeScalarWhereWithAggregatesInput[]
    OR?: CommandeScalarWhereWithAggregatesInput[]
    NOT?: CommandeScalarWhereWithAggregatesInput | CommandeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commande"> | number
    chantierId?: StringWithAggregatesFilter<"Commande"> | string
    clientId?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    dateCommande?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    tauxTVA?: FloatWithAggregatesFilter<"Commande"> | number
    sousTotal?: FloatWithAggregatesFilter<"Commande"> | number
    totalOptions?: FloatWithAggregatesFilter<"Commande"> | number
    tva?: FloatWithAggregatesFilter<"Commande"> | number
    total?: FloatWithAggregatesFilter<"Commande"> | number
    statut?: StringWithAggregatesFilter<"Commande"> | string
    estVerrouillee?: BoolWithAggregatesFilter<"Commande"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
  }

  export type LigneCommandeWhereInput = {
    AND?: LigneCommandeWhereInput | LigneCommandeWhereInput[]
    OR?: LigneCommandeWhereInput[]
    NOT?: LigneCommandeWhereInput | LigneCommandeWhereInput[]
    id?: IntFilter<"LigneCommande"> | number
    commandeId?: IntFilter<"LigneCommande"> | number
    ordre?: IntFilter<"LigneCommande"> | number
    article?: StringFilter<"LigneCommande"> | string
    description?: StringFilter<"LigneCommande"> | string
    type?: StringFilter<"LigneCommande"> | string
    unite?: StringFilter<"LigneCommande"> | string
    prixUnitaire?: FloatFilter<"LigneCommande"> | number
    quantite?: FloatFilter<"LigneCommande"> | number
    total?: FloatFilter<"LigneCommande"> | number
    estOption?: BoolFilter<"LigneCommande"> | boolean
    createdAt?: DateTimeFilter<"LigneCommande"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCommande"> | Date | string
    commande?: XOR<CommandeScalarRelationFilter, CommandeWhereInput>
  }

  export type LigneCommandeOrderByWithRelationInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    estOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commande?: CommandeOrderByWithRelationInput
    _relevance?: LigneCommandeOrderByRelevanceInput
  }

  export type LigneCommandeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LigneCommandeWhereInput | LigneCommandeWhereInput[]
    OR?: LigneCommandeWhereInput[]
    NOT?: LigneCommandeWhereInput | LigneCommandeWhereInput[]
    commandeId?: IntFilter<"LigneCommande"> | number
    ordre?: IntFilter<"LigneCommande"> | number
    article?: StringFilter<"LigneCommande"> | string
    description?: StringFilter<"LigneCommande"> | string
    type?: StringFilter<"LigneCommande"> | string
    unite?: StringFilter<"LigneCommande"> | string
    prixUnitaire?: FloatFilter<"LigneCommande"> | number
    quantite?: FloatFilter<"LigneCommande"> | number
    total?: FloatFilter<"LigneCommande"> | number
    estOption?: BoolFilter<"LigneCommande"> | boolean
    createdAt?: DateTimeFilter<"LigneCommande"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCommande"> | Date | string
    commande?: XOR<CommandeScalarRelationFilter, CommandeWhereInput>
  }, "id">

  export type LigneCommandeOrderByWithAggregationInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    estOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LigneCommandeCountOrderByAggregateInput
    _avg?: LigneCommandeAvgOrderByAggregateInput
    _max?: LigneCommandeMaxOrderByAggregateInput
    _min?: LigneCommandeMinOrderByAggregateInput
    _sum?: LigneCommandeSumOrderByAggregateInput
  }

  export type LigneCommandeScalarWhereWithAggregatesInput = {
    AND?: LigneCommandeScalarWhereWithAggregatesInput | LigneCommandeScalarWhereWithAggregatesInput[]
    OR?: LigneCommandeScalarWhereWithAggregatesInput[]
    NOT?: LigneCommandeScalarWhereWithAggregatesInput | LigneCommandeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LigneCommande"> | number
    commandeId?: IntWithAggregatesFilter<"LigneCommande"> | number
    ordre?: IntWithAggregatesFilter<"LigneCommande"> | number
    article?: StringWithAggregatesFilter<"LigneCommande"> | string
    description?: StringWithAggregatesFilter<"LigneCommande"> | string
    type?: StringWithAggregatesFilter<"LigneCommande"> | string
    unite?: StringWithAggregatesFilter<"LigneCommande"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"LigneCommande"> | number
    quantite?: FloatWithAggregatesFilter<"LigneCommande"> | number
    total?: FloatWithAggregatesFilter<"LigneCommande"> | number
    estOption?: BoolWithAggregatesFilter<"LigneCommande"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LigneCommande"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LigneCommande"> | Date | string
  }

  export type EtatAvancementWhereInput = {
    AND?: EtatAvancementWhereInput | EtatAvancementWhereInput[]
    OR?: EtatAvancementWhereInput[]
    NOT?: EtatAvancementWhereInput | EtatAvancementWhereInput[]
    id?: IntFilter<"EtatAvancement"> | number
    chantierId?: StringFilter<"EtatAvancement"> | string
    numero?: IntFilter<"EtatAvancement"> | number
    date?: DateTimeFilter<"EtatAvancement"> | Date | string
    commentaires?: StringNullableFilter<"EtatAvancement"> | string | null
    estFinalise?: BoolFilter<"EtatAvancement"> | boolean
    createdAt?: DateTimeFilter<"EtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"EtatAvancement"> | Date | string
    createdBy?: StringFilter<"EtatAvancement"> | string
    avenants?: AvenantEtatAvancementListRelationFilter
    lignes?: LigneEtatAvancementListRelationFilter
    soustraitant_etat_avancement?: Soustraitant_etat_avancementListRelationFilter
  }

  export type EtatAvancementOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrderInput | SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    avenants?: AvenantEtatAvancementOrderByRelationAggregateInput
    lignes?: LigneEtatAvancementOrderByRelationAggregateInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementOrderByRelationAggregateInput
    _relevance?: EtatAvancementOrderByRelevanceInput
  }

  export type EtatAvancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chantierId_numero?: EtatAvancementChantierIdNumeroCompoundUniqueInput
    AND?: EtatAvancementWhereInput | EtatAvancementWhereInput[]
    OR?: EtatAvancementWhereInput[]
    NOT?: EtatAvancementWhereInput | EtatAvancementWhereInput[]
    chantierId?: StringFilter<"EtatAvancement"> | string
    numero?: IntFilter<"EtatAvancement"> | number
    date?: DateTimeFilter<"EtatAvancement"> | Date | string
    commentaires?: StringNullableFilter<"EtatAvancement"> | string | null
    estFinalise?: BoolFilter<"EtatAvancement"> | boolean
    createdAt?: DateTimeFilter<"EtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"EtatAvancement"> | Date | string
    createdBy?: StringFilter<"EtatAvancement"> | string
    avenants?: AvenantEtatAvancementListRelationFilter
    lignes?: LigneEtatAvancementListRelationFilter
    soustraitant_etat_avancement?: Soustraitant_etat_avancementListRelationFilter
  }, "id" | "chantierId_numero">

  export type EtatAvancementOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrderInput | SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: EtatAvancementCountOrderByAggregateInput
    _avg?: EtatAvancementAvgOrderByAggregateInput
    _max?: EtatAvancementMaxOrderByAggregateInput
    _min?: EtatAvancementMinOrderByAggregateInput
    _sum?: EtatAvancementSumOrderByAggregateInput
  }

  export type EtatAvancementScalarWhereWithAggregatesInput = {
    AND?: EtatAvancementScalarWhereWithAggregatesInput | EtatAvancementScalarWhereWithAggregatesInput[]
    OR?: EtatAvancementScalarWhereWithAggregatesInput[]
    NOT?: EtatAvancementScalarWhereWithAggregatesInput | EtatAvancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EtatAvancement"> | number
    chantierId?: StringWithAggregatesFilter<"EtatAvancement"> | string
    numero?: IntWithAggregatesFilter<"EtatAvancement"> | number
    date?: DateTimeWithAggregatesFilter<"EtatAvancement"> | Date | string
    commentaires?: StringNullableWithAggregatesFilter<"EtatAvancement"> | string | null
    estFinalise?: BoolWithAggregatesFilter<"EtatAvancement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EtatAvancement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EtatAvancement"> | Date | string
    createdBy?: StringWithAggregatesFilter<"EtatAvancement"> | string
  }

  export type LigneEtatAvancementWhereInput = {
    AND?: LigneEtatAvancementWhereInput | LigneEtatAvancementWhereInput[]
    OR?: LigneEtatAvancementWhereInput[]
    NOT?: LigneEtatAvancementWhereInput | LigneEtatAvancementWhereInput[]
    id?: IntFilter<"LigneEtatAvancement"> | number
    etatAvancementId?: IntFilter<"LigneEtatAvancement"> | number
    ligneCommandeId?: IntFilter<"LigneEtatAvancement"> | number
    quantitePrecedente?: FloatFilter<"LigneEtatAvancement"> | number
    quantiteActuelle?: FloatFilter<"LigneEtatAvancement"> | number
    quantiteTotale?: FloatFilter<"LigneEtatAvancement"> | number
    montantPrecedent?: FloatFilter<"LigneEtatAvancement"> | number
    montantActuel?: FloatFilter<"LigneEtatAvancement"> | number
    montantTotal?: FloatFilter<"LigneEtatAvancement"> | number
    createdAt?: DateTimeFilter<"LigneEtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"LigneEtatAvancement"> | Date | string
    article?: StringFilter<"LigneEtatAvancement"> | string
    description?: StringFilter<"LigneEtatAvancement"> | string
    prixUnitaire?: FloatFilter<"LigneEtatAvancement"> | number
    quantite?: FloatFilter<"LigneEtatAvancement"> | number
    type?: StringFilter<"LigneEtatAvancement"> | string
    unite?: StringFilter<"LigneEtatAvancement"> | string
    etatAvancement?: XOR<EtatAvancementScalarRelationFilter, EtatAvancementWhereInput>
  }

  export type LigneEtatAvancementOrderByWithRelationInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    description?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    etatAvancement?: EtatAvancementOrderByWithRelationInput
    _relevance?: LigneEtatAvancementOrderByRelevanceInput
  }

  export type LigneEtatAvancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LigneEtatAvancementWhereInput | LigneEtatAvancementWhereInput[]
    OR?: LigneEtatAvancementWhereInput[]
    NOT?: LigneEtatAvancementWhereInput | LigneEtatAvancementWhereInput[]
    etatAvancementId?: IntFilter<"LigneEtatAvancement"> | number
    ligneCommandeId?: IntFilter<"LigneEtatAvancement"> | number
    quantitePrecedente?: FloatFilter<"LigneEtatAvancement"> | number
    quantiteActuelle?: FloatFilter<"LigneEtatAvancement"> | number
    quantiteTotale?: FloatFilter<"LigneEtatAvancement"> | number
    montantPrecedent?: FloatFilter<"LigneEtatAvancement"> | number
    montantActuel?: FloatFilter<"LigneEtatAvancement"> | number
    montantTotal?: FloatFilter<"LigneEtatAvancement"> | number
    createdAt?: DateTimeFilter<"LigneEtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"LigneEtatAvancement"> | Date | string
    article?: StringFilter<"LigneEtatAvancement"> | string
    description?: StringFilter<"LigneEtatAvancement"> | string
    prixUnitaire?: FloatFilter<"LigneEtatAvancement"> | number
    quantite?: FloatFilter<"LigneEtatAvancement"> | number
    type?: StringFilter<"LigneEtatAvancement"> | string
    unite?: StringFilter<"LigneEtatAvancement"> | string
    etatAvancement?: XOR<EtatAvancementScalarRelationFilter, EtatAvancementWhereInput>
  }, "id">

  export type LigneEtatAvancementOrderByWithAggregationInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    description?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    _count?: LigneEtatAvancementCountOrderByAggregateInput
    _avg?: LigneEtatAvancementAvgOrderByAggregateInput
    _max?: LigneEtatAvancementMaxOrderByAggregateInput
    _min?: LigneEtatAvancementMinOrderByAggregateInput
    _sum?: LigneEtatAvancementSumOrderByAggregateInput
  }

  export type LigneEtatAvancementScalarWhereWithAggregatesInput = {
    AND?: LigneEtatAvancementScalarWhereWithAggregatesInput | LigneEtatAvancementScalarWhereWithAggregatesInput[]
    OR?: LigneEtatAvancementScalarWhereWithAggregatesInput[]
    NOT?: LigneEtatAvancementScalarWhereWithAggregatesInput | LigneEtatAvancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LigneEtatAvancement"> | number
    etatAvancementId?: IntWithAggregatesFilter<"LigneEtatAvancement"> | number
    ligneCommandeId?: IntWithAggregatesFilter<"LigneEtatAvancement"> | number
    quantitePrecedente?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    quantiteActuelle?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    quantiteTotale?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    montantPrecedent?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    montantActuel?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    montantTotal?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LigneEtatAvancement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LigneEtatAvancement"> | Date | string
    article?: StringWithAggregatesFilter<"LigneEtatAvancement"> | string
    description?: StringWithAggregatesFilter<"LigneEtatAvancement"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    quantite?: FloatWithAggregatesFilter<"LigneEtatAvancement"> | number
    type?: StringWithAggregatesFilter<"LigneEtatAvancement"> | string
    unite?: StringWithAggregatesFilter<"LigneEtatAvancement"> | string
  }

  export type AvenantEtatAvancementWhereInput = {
    AND?: AvenantEtatAvancementWhereInput | AvenantEtatAvancementWhereInput[]
    OR?: AvenantEtatAvancementWhereInput[]
    NOT?: AvenantEtatAvancementWhereInput | AvenantEtatAvancementWhereInput[]
    id?: IntFilter<"AvenantEtatAvancement"> | number
    etatAvancementId?: IntFilter<"AvenantEtatAvancement"> | number
    article?: StringFilter<"AvenantEtatAvancement"> | string
    description?: StringFilter<"AvenantEtatAvancement"> | string
    type?: StringFilter<"AvenantEtatAvancement"> | string
    unite?: StringFilter<"AvenantEtatAvancement"> | string
    prixUnitaire?: FloatFilter<"AvenantEtatAvancement"> | number
    quantite?: FloatFilter<"AvenantEtatAvancement"> | number
    quantitePrecedente?: FloatFilter<"AvenantEtatAvancement"> | number
    quantiteActuelle?: FloatFilter<"AvenantEtatAvancement"> | number
    quantiteTotale?: FloatFilter<"AvenantEtatAvancement"> | number
    montantPrecedent?: FloatFilter<"AvenantEtatAvancement"> | number
    montantActuel?: FloatFilter<"AvenantEtatAvancement"> | number
    montantTotal?: FloatFilter<"AvenantEtatAvancement"> | number
    createdAt?: DateTimeFilter<"AvenantEtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"AvenantEtatAvancement"> | Date | string
    etatAvancement?: XOR<EtatAvancementScalarRelationFilter, EtatAvancementWhereInput>
  }

  export type AvenantEtatAvancementOrderByWithRelationInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    etatAvancement?: EtatAvancementOrderByWithRelationInput
    _relevance?: AvenantEtatAvancementOrderByRelevanceInput
  }

  export type AvenantEtatAvancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AvenantEtatAvancementWhereInput | AvenantEtatAvancementWhereInput[]
    OR?: AvenantEtatAvancementWhereInput[]
    NOT?: AvenantEtatAvancementWhereInput | AvenantEtatAvancementWhereInput[]
    etatAvancementId?: IntFilter<"AvenantEtatAvancement"> | number
    article?: StringFilter<"AvenantEtatAvancement"> | string
    description?: StringFilter<"AvenantEtatAvancement"> | string
    type?: StringFilter<"AvenantEtatAvancement"> | string
    unite?: StringFilter<"AvenantEtatAvancement"> | string
    prixUnitaire?: FloatFilter<"AvenantEtatAvancement"> | number
    quantite?: FloatFilter<"AvenantEtatAvancement"> | number
    quantitePrecedente?: FloatFilter<"AvenantEtatAvancement"> | number
    quantiteActuelle?: FloatFilter<"AvenantEtatAvancement"> | number
    quantiteTotale?: FloatFilter<"AvenantEtatAvancement"> | number
    montantPrecedent?: FloatFilter<"AvenantEtatAvancement"> | number
    montantActuel?: FloatFilter<"AvenantEtatAvancement"> | number
    montantTotal?: FloatFilter<"AvenantEtatAvancement"> | number
    createdAt?: DateTimeFilter<"AvenantEtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"AvenantEtatAvancement"> | Date | string
    etatAvancement?: XOR<EtatAvancementScalarRelationFilter, EtatAvancementWhereInput>
  }, "id">

  export type AvenantEtatAvancementOrderByWithAggregationInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvenantEtatAvancementCountOrderByAggregateInput
    _avg?: AvenantEtatAvancementAvgOrderByAggregateInput
    _max?: AvenantEtatAvancementMaxOrderByAggregateInput
    _min?: AvenantEtatAvancementMinOrderByAggregateInput
    _sum?: AvenantEtatAvancementSumOrderByAggregateInput
  }

  export type AvenantEtatAvancementScalarWhereWithAggregatesInput = {
    AND?: AvenantEtatAvancementScalarWhereWithAggregatesInput | AvenantEtatAvancementScalarWhereWithAggregatesInput[]
    OR?: AvenantEtatAvancementScalarWhereWithAggregatesInput[]
    NOT?: AvenantEtatAvancementScalarWhereWithAggregatesInput | AvenantEtatAvancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AvenantEtatAvancement"> | number
    etatAvancementId?: IntWithAggregatesFilter<"AvenantEtatAvancement"> | number
    article?: StringWithAggregatesFilter<"AvenantEtatAvancement"> | string
    description?: StringWithAggregatesFilter<"AvenantEtatAvancement"> | string
    type?: StringWithAggregatesFilter<"AvenantEtatAvancement"> | string
    unite?: StringWithAggregatesFilter<"AvenantEtatAvancement"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    quantite?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    quantitePrecedente?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    quantiteActuelle?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    quantiteTotale?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    montantPrecedent?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    montantActuel?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    montantTotal?: FloatWithAggregatesFilter<"AvenantEtatAvancement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AvenantEtatAvancement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AvenantEtatAvancement"> | Date | string
  }

  export type companysettingsWhereInput = {
    AND?: companysettingsWhereInput | companysettingsWhereInput[]
    OR?: companysettingsWhereInput[]
    NOT?: companysettingsWhereInput | companysettingsWhereInput[]
    id?: StringFilter<"companysettings"> | string
    name?: StringFilter<"companysettings"> | string
    address?: StringFilter<"companysettings"> | string
    zipCode?: StringFilter<"companysettings"> | string
    city?: StringFilter<"companysettings"> | string
    phone?: StringFilter<"companysettings"> | string
    email?: StringFilter<"companysettings"> | string
    tva?: StringFilter<"companysettings"> | string
    logo?: StringNullableFilter<"companysettings"> | string | null
    createdAt?: DateTimeFilter<"companysettings"> | Date | string
    updatedAt?: DateTimeFilter<"companysettings"> | Date | string
    emailFrom?: StringNullableFilter<"companysettings"> | string | null
    emailFromName?: StringNullableFilter<"companysettings"> | string | null
    emailHost?: StringNullableFilter<"companysettings"> | string | null
    emailPassword?: StringNullableFilter<"companysettings"> | string | null
    emailPort?: StringNullableFilter<"companysettings"> | string | null
    emailSecure?: BoolNullableFilter<"companysettings"> | boolean | null
    emailUser?: StringNullableFilter<"companysettings"> | string | null
    iban?: StringFilter<"companysettings"> | string
  }

  export type companysettingsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    tva?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailFrom?: SortOrderInput | SortOrder
    emailFromName?: SortOrderInput | SortOrder
    emailHost?: SortOrderInput | SortOrder
    emailPassword?: SortOrderInput | SortOrder
    emailPort?: SortOrderInput | SortOrder
    emailSecure?: SortOrderInput | SortOrder
    emailUser?: SortOrderInput | SortOrder
    iban?: SortOrder
    _relevance?: companysettingsOrderByRelevanceInput
  }

  export type companysettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: companysettingsWhereInput | companysettingsWhereInput[]
    OR?: companysettingsWhereInput[]
    NOT?: companysettingsWhereInput | companysettingsWhereInput[]
    name?: StringFilter<"companysettings"> | string
    address?: StringFilter<"companysettings"> | string
    zipCode?: StringFilter<"companysettings"> | string
    city?: StringFilter<"companysettings"> | string
    phone?: StringFilter<"companysettings"> | string
    email?: StringFilter<"companysettings"> | string
    tva?: StringFilter<"companysettings"> | string
    logo?: StringNullableFilter<"companysettings"> | string | null
    createdAt?: DateTimeFilter<"companysettings"> | Date | string
    updatedAt?: DateTimeFilter<"companysettings"> | Date | string
    emailFrom?: StringNullableFilter<"companysettings"> | string | null
    emailFromName?: StringNullableFilter<"companysettings"> | string | null
    emailHost?: StringNullableFilter<"companysettings"> | string | null
    emailPassword?: StringNullableFilter<"companysettings"> | string | null
    emailPort?: StringNullableFilter<"companysettings"> | string | null
    emailSecure?: BoolNullableFilter<"companysettings"> | boolean | null
    emailUser?: StringNullableFilter<"companysettings"> | string | null
    iban?: StringFilter<"companysettings"> | string
  }, "id">

  export type companysettingsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    tva?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailFrom?: SortOrderInput | SortOrder
    emailFromName?: SortOrderInput | SortOrder
    emailHost?: SortOrderInput | SortOrder
    emailPassword?: SortOrderInput | SortOrder
    emailPort?: SortOrderInput | SortOrder
    emailSecure?: SortOrderInput | SortOrder
    emailUser?: SortOrderInput | SortOrder
    iban?: SortOrder
    _count?: companysettingsCountOrderByAggregateInput
    _max?: companysettingsMaxOrderByAggregateInput
    _min?: companysettingsMinOrderByAggregateInput
  }

  export type companysettingsScalarWhereWithAggregatesInput = {
    AND?: companysettingsScalarWhereWithAggregatesInput | companysettingsScalarWhereWithAggregatesInput[]
    OR?: companysettingsScalarWhereWithAggregatesInput[]
    NOT?: companysettingsScalarWhereWithAggregatesInput | companysettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"companysettings"> | string
    name?: StringWithAggregatesFilter<"companysettings"> | string
    address?: StringWithAggregatesFilter<"companysettings"> | string
    zipCode?: StringWithAggregatesFilter<"companysettings"> | string
    city?: StringWithAggregatesFilter<"companysettings"> | string
    phone?: StringWithAggregatesFilter<"companysettings"> | string
    email?: StringWithAggregatesFilter<"companysettings"> | string
    tva?: StringWithAggregatesFilter<"companysettings"> | string
    logo?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"companysettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"companysettings"> | Date | string
    emailFrom?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    emailFromName?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    emailHost?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    emailPassword?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    emailPort?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    emailSecure?: BoolNullableWithAggregatesFilter<"companysettings"> | boolean | null
    emailUser?: StringNullableWithAggregatesFilter<"companysettings"> | string | null
    iban?: StringWithAggregatesFilter<"companysettings"> | string
  }

  export type CommandeSousTraitantWhereInput = {
    AND?: CommandeSousTraitantWhereInput | CommandeSousTraitantWhereInput[]
    OR?: CommandeSousTraitantWhereInput[]
    NOT?: CommandeSousTraitantWhereInput | CommandeSousTraitantWhereInput[]
    id?: IntFilter<"CommandeSousTraitant"> | number
    chantierId?: StringFilter<"CommandeSousTraitant"> | string
    soustraitantId?: StringFilter<"CommandeSousTraitant"> | string
    dateCommande?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    reference?: StringNullableFilter<"CommandeSousTraitant"> | string | null
    tauxTVA?: FloatFilter<"CommandeSousTraitant"> | number
    sousTotal?: FloatFilter<"CommandeSousTraitant"> | number
    tva?: FloatFilter<"CommandeSousTraitant"> | number
    total?: FloatFilter<"CommandeSousTraitant"> | number
    statut?: StringFilter<"CommandeSousTraitant"> | string
    estVerrouillee?: BoolFilter<"CommandeSousTraitant"> | boolean
    createdAt?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    soustraitant?: XOR<SoustraitantScalarRelationFilter, soustraitantWhereInput>
    lignes?: LigneCommandeSousTraitantListRelationFilter
    soustraitant_etat_avancement?: Soustraitant_etat_avancementListRelationFilter
  }

  export type CommandeSousTraitantOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    soustraitantId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrderInput | SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    soustraitant?: soustraitantOrderByWithRelationInput
    lignes?: LigneCommandeSousTraitantOrderByRelationAggregateInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementOrderByRelationAggregateInput
    _relevance?: CommandeSousTraitantOrderByRelevanceInput
  }

  export type CommandeSousTraitantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandeSousTraitantWhereInput | CommandeSousTraitantWhereInput[]
    OR?: CommandeSousTraitantWhereInput[]
    NOT?: CommandeSousTraitantWhereInput | CommandeSousTraitantWhereInput[]
    chantierId?: StringFilter<"CommandeSousTraitant"> | string
    soustraitantId?: StringFilter<"CommandeSousTraitant"> | string
    dateCommande?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    reference?: StringNullableFilter<"CommandeSousTraitant"> | string | null
    tauxTVA?: FloatFilter<"CommandeSousTraitant"> | number
    sousTotal?: FloatFilter<"CommandeSousTraitant"> | number
    tva?: FloatFilter<"CommandeSousTraitant"> | number
    total?: FloatFilter<"CommandeSousTraitant"> | number
    statut?: StringFilter<"CommandeSousTraitant"> | string
    estVerrouillee?: BoolFilter<"CommandeSousTraitant"> | boolean
    createdAt?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    soustraitant?: XOR<SoustraitantScalarRelationFilter, soustraitantWhereInput>
    lignes?: LigneCommandeSousTraitantListRelationFilter
    soustraitant_etat_avancement?: Soustraitant_etat_avancementListRelationFilter
  }, "id">

  export type CommandeSousTraitantOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    soustraitantId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrderInput | SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandeSousTraitantCountOrderByAggregateInput
    _avg?: CommandeSousTraitantAvgOrderByAggregateInput
    _max?: CommandeSousTraitantMaxOrderByAggregateInput
    _min?: CommandeSousTraitantMinOrderByAggregateInput
    _sum?: CommandeSousTraitantSumOrderByAggregateInput
  }

  export type CommandeSousTraitantScalarWhereWithAggregatesInput = {
    AND?: CommandeSousTraitantScalarWhereWithAggregatesInput | CommandeSousTraitantScalarWhereWithAggregatesInput[]
    OR?: CommandeSousTraitantScalarWhereWithAggregatesInput[]
    NOT?: CommandeSousTraitantScalarWhereWithAggregatesInput | CommandeSousTraitantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommandeSousTraitant"> | number
    chantierId?: StringWithAggregatesFilter<"CommandeSousTraitant"> | string
    soustraitantId?: StringWithAggregatesFilter<"CommandeSousTraitant"> | string
    dateCommande?: DateTimeWithAggregatesFilter<"CommandeSousTraitant"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"CommandeSousTraitant"> | string | null
    tauxTVA?: FloatWithAggregatesFilter<"CommandeSousTraitant"> | number
    sousTotal?: FloatWithAggregatesFilter<"CommandeSousTraitant"> | number
    tva?: FloatWithAggregatesFilter<"CommandeSousTraitant"> | number
    total?: FloatWithAggregatesFilter<"CommandeSousTraitant"> | number
    statut?: StringWithAggregatesFilter<"CommandeSousTraitant"> | string
    estVerrouillee?: BoolWithAggregatesFilter<"CommandeSousTraitant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommandeSousTraitant"> | Date | string
  }

  export type LigneCommandeSousTraitantWhereInput = {
    AND?: LigneCommandeSousTraitantWhereInput | LigneCommandeSousTraitantWhereInput[]
    OR?: LigneCommandeSousTraitantWhereInput[]
    NOT?: LigneCommandeSousTraitantWhereInput | LigneCommandeSousTraitantWhereInput[]
    id?: IntFilter<"LigneCommandeSousTraitant"> | number
    commandeSousTraitantId?: IntFilter<"LigneCommandeSousTraitant"> | number
    ordre?: IntFilter<"LigneCommandeSousTraitant"> | number
    article?: StringFilter<"LigneCommandeSousTraitant"> | string
    description?: StringFilter<"LigneCommandeSousTraitant"> | string
    type?: StringFilter<"LigneCommandeSousTraitant"> | string
    unite?: StringFilter<"LigneCommandeSousTraitant"> | string
    prixUnitaire?: FloatFilter<"LigneCommandeSousTraitant"> | number
    quantite?: FloatFilter<"LigneCommandeSousTraitant"> | number
    total?: FloatFilter<"LigneCommandeSousTraitant"> | number
    createdAt?: DateTimeFilter<"LigneCommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCommandeSousTraitant"> | Date | string
    commandeSousTraitant?: XOR<CommandeSousTraitantScalarRelationFilter, CommandeSousTraitantWhereInput>
  }

  export type LigneCommandeSousTraitantOrderByWithRelationInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandeSousTraitant?: CommandeSousTraitantOrderByWithRelationInput
    _relevance?: LigneCommandeSousTraitantOrderByRelevanceInput
  }

  export type LigneCommandeSousTraitantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LigneCommandeSousTraitantWhereInput | LigneCommandeSousTraitantWhereInput[]
    OR?: LigneCommandeSousTraitantWhereInput[]
    NOT?: LigneCommandeSousTraitantWhereInput | LigneCommandeSousTraitantWhereInput[]
    commandeSousTraitantId?: IntFilter<"LigneCommandeSousTraitant"> | number
    ordre?: IntFilter<"LigneCommandeSousTraitant"> | number
    article?: StringFilter<"LigneCommandeSousTraitant"> | string
    description?: StringFilter<"LigneCommandeSousTraitant"> | string
    type?: StringFilter<"LigneCommandeSousTraitant"> | string
    unite?: StringFilter<"LigneCommandeSousTraitant"> | string
    prixUnitaire?: FloatFilter<"LigneCommandeSousTraitant"> | number
    quantite?: FloatFilter<"LigneCommandeSousTraitant"> | number
    total?: FloatFilter<"LigneCommandeSousTraitant"> | number
    createdAt?: DateTimeFilter<"LigneCommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCommandeSousTraitant"> | Date | string
    commandeSousTraitant?: XOR<CommandeSousTraitantScalarRelationFilter, CommandeSousTraitantWhereInput>
  }, "id">

  export type LigneCommandeSousTraitantOrderByWithAggregationInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LigneCommandeSousTraitantCountOrderByAggregateInput
    _avg?: LigneCommandeSousTraitantAvgOrderByAggregateInput
    _max?: LigneCommandeSousTraitantMaxOrderByAggregateInput
    _min?: LigneCommandeSousTraitantMinOrderByAggregateInput
    _sum?: LigneCommandeSousTraitantSumOrderByAggregateInput
  }

  export type LigneCommandeSousTraitantScalarWhereWithAggregatesInput = {
    AND?: LigneCommandeSousTraitantScalarWhereWithAggregatesInput | LigneCommandeSousTraitantScalarWhereWithAggregatesInput[]
    OR?: LigneCommandeSousTraitantScalarWhereWithAggregatesInput[]
    NOT?: LigneCommandeSousTraitantScalarWhereWithAggregatesInput | LigneCommandeSousTraitantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LigneCommandeSousTraitant"> | number
    commandeSousTraitantId?: IntWithAggregatesFilter<"LigneCommandeSousTraitant"> | number
    ordre?: IntWithAggregatesFilter<"LigneCommandeSousTraitant"> | number
    article?: StringWithAggregatesFilter<"LigneCommandeSousTraitant"> | string
    description?: StringWithAggregatesFilter<"LigneCommandeSousTraitant"> | string
    type?: StringWithAggregatesFilter<"LigneCommandeSousTraitant"> | string
    unite?: StringWithAggregatesFilter<"LigneCommandeSousTraitant"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"LigneCommandeSousTraitant"> | number
    quantite?: FloatWithAggregatesFilter<"LigneCommandeSousTraitant"> | number
    total?: FloatWithAggregatesFilter<"LigneCommandeSousTraitant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LigneCommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LigneCommandeSousTraitant"> | Date | string
  }

  export type avenant_soustraitant_etat_avancementWhereInput = {
    AND?: avenant_soustraitant_etat_avancementWhereInput | avenant_soustraitant_etat_avancementWhereInput[]
    OR?: avenant_soustraitant_etat_avancementWhereInput[]
    NOT?: avenant_soustraitant_etat_avancementWhereInput | avenant_soustraitant_etat_avancementWhereInput[]
    id?: IntFilter<"avenant_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntFilter<"avenant_soustraitant_etat_avancement"> | number
    article?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    description?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    type?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    unite?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantite?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantActuel?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantTotal?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeFilter<"avenant_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"avenant_soustraitant_etat_avancement"> | Date | string
    soustraitant_etat_avancement?: XOR<Soustraitant_etat_avancementScalarRelationFilter, soustraitant_etat_avancementWhereInput>
  }

  export type avenant_soustraitant_etat_avancementOrderByWithRelationInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    soustraitant_etat_avancement?: soustraitant_etat_avancementOrderByWithRelationInput
    _relevance?: avenant_soustraitant_etat_avancementOrderByRelevanceInput
  }

  export type avenant_soustraitant_etat_avancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: avenant_soustraitant_etat_avancementWhereInput | avenant_soustraitant_etat_avancementWhereInput[]
    OR?: avenant_soustraitant_etat_avancementWhereInput[]
    NOT?: avenant_soustraitant_etat_avancementWhereInput | avenant_soustraitant_etat_avancementWhereInput[]
    soustraitantEtatAvancementId?: IntFilter<"avenant_soustraitant_etat_avancement"> | number
    article?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    description?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    type?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    unite?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantite?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantActuel?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantTotal?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeFilter<"avenant_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"avenant_soustraitant_etat_avancement"> | Date | string
    soustraitant_etat_avancement?: XOR<Soustraitant_etat_avancementScalarRelationFilter, soustraitant_etat_avancementWhereInput>
  }, "id">

  export type avenant_soustraitant_etat_avancementOrderByWithAggregationInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: avenant_soustraitant_etat_avancementCountOrderByAggregateInput
    _avg?: avenant_soustraitant_etat_avancementAvgOrderByAggregateInput
    _max?: avenant_soustraitant_etat_avancementMaxOrderByAggregateInput
    _min?: avenant_soustraitant_etat_avancementMinOrderByAggregateInput
    _sum?: avenant_soustraitant_etat_avancementSumOrderByAggregateInput
  }

  export type avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput = {
    AND?: avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput | avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    OR?: avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    NOT?: avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput | avenant_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    article?: StringWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | string
    description?: StringWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | string
    type?: StringWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | string
    unite?: StringWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    quantite?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    montantActuel?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    montantTotal?: FloatWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"avenant_soustraitant_etat_avancement"> | Date | string
  }

  export type ligne_soustraitant_etat_avancementWhereInput = {
    AND?: ligne_soustraitant_etat_avancementWhereInput | ligne_soustraitant_etat_avancementWhereInput[]
    OR?: ligne_soustraitant_etat_avancementWhereInput[]
    NOT?: ligne_soustraitant_etat_avancementWhereInput | ligne_soustraitant_etat_avancementWhereInput[]
    id?: IntFilter<"ligne_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntFilter<"ligne_soustraitant_etat_avancement"> | number
    article?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    description?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    type?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    unite?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantite?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantActuel?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantTotal?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeFilter<"ligne_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"ligne_soustraitant_etat_avancement"> | Date | string
    soustraitant_etat_avancement?: XOR<Soustraitant_etat_avancementScalarRelationFilter, soustraitant_etat_avancementWhereInput>
  }

  export type ligne_soustraitant_etat_avancementOrderByWithRelationInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    soustraitant_etat_avancement?: soustraitant_etat_avancementOrderByWithRelationInput
    _relevance?: ligne_soustraitant_etat_avancementOrderByRelevanceInput
  }

  export type ligne_soustraitant_etat_avancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ligne_soustraitant_etat_avancementWhereInput | ligne_soustraitant_etat_avancementWhereInput[]
    OR?: ligne_soustraitant_etat_avancementWhereInput[]
    NOT?: ligne_soustraitant_etat_avancementWhereInput | ligne_soustraitant_etat_avancementWhereInput[]
    soustraitantEtatAvancementId?: IntFilter<"ligne_soustraitant_etat_avancement"> | number
    article?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    description?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    type?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    unite?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantite?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantActuel?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantTotal?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeFilter<"ligne_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"ligne_soustraitant_etat_avancement"> | Date | string
    soustraitant_etat_avancement?: XOR<Soustraitant_etat_avancementScalarRelationFilter, soustraitant_etat_avancementWhereInput>
  }, "id">

  export type ligne_soustraitant_etat_avancementOrderByWithAggregationInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ligne_soustraitant_etat_avancementCountOrderByAggregateInput
    _avg?: ligne_soustraitant_etat_avancementAvgOrderByAggregateInput
    _max?: ligne_soustraitant_etat_avancementMaxOrderByAggregateInput
    _min?: ligne_soustraitant_etat_avancementMinOrderByAggregateInput
    _sum?: ligne_soustraitant_etat_avancementSumOrderByAggregateInput
  }

  export type ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput = {
    AND?: ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput | ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    OR?: ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    NOT?: ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput | ligne_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    article?: StringWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | string
    description?: StringWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | string
    type?: StringWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | string
    unite?: StringWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    quantite?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    montantActuel?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    montantTotal?: FloatWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ligne_soustraitant_etat_avancement"> | Date | string
  }

  export type soustraitant_etat_avancementWhereInput = {
    AND?: soustraitant_etat_avancementWhereInput | soustraitant_etat_avancementWhereInput[]
    OR?: soustraitant_etat_avancementWhereInput[]
    NOT?: soustraitant_etat_avancementWhereInput | soustraitant_etat_avancementWhereInput[]
    id?: IntFilter<"soustraitant_etat_avancement"> | number
    soustraitantId?: StringFilter<"soustraitant_etat_avancement"> | string
    numero?: IntFilter<"soustraitant_etat_avancement"> | number
    date?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    commentaires?: StringNullableFilter<"soustraitant_etat_avancement"> | string | null
    estFinalise?: BoolFilter<"soustraitant_etat_avancement"> | boolean
    createdAt?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    commandeSousTraitantId?: IntNullableFilter<"soustraitant_etat_avancement"> | number | null
    etatAvancementId?: IntFilter<"soustraitant_etat_avancement"> | number
    avenant_soustraitant_etat_avancement?: Avenant_soustraitant_etat_avancementListRelationFilter
    ligne_soustraitant_etat_avancement?: Ligne_soustraitant_etat_avancementListRelationFilter
    photos?: Photo_soustraitant_etat_avancementListRelationFilter
    commande_soustraitant?: XOR<CommandeSousTraitantNullableScalarRelationFilter, CommandeSousTraitantWhereInput> | null
    etat_avancement?: XOR<EtatAvancementScalarRelationFilter, EtatAvancementWhereInput>
    soustraitant?: XOR<SoustraitantScalarRelationFilter, soustraitantWhereInput>
  }

  export type soustraitant_etat_avancementOrderByWithRelationInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrderInput | SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandeSousTraitantId?: SortOrderInput | SortOrder
    etatAvancementId?: SortOrder
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementOrderByRelationAggregateInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementOrderByRelationAggregateInput
    photos?: photo_soustraitant_etat_avancementOrderByRelationAggregateInput
    commande_soustraitant?: CommandeSousTraitantOrderByWithRelationInput
    etat_avancement?: EtatAvancementOrderByWithRelationInput
    soustraitant?: soustraitantOrderByWithRelationInput
    _relevance?: soustraitant_etat_avancementOrderByRelevanceInput
  }

  export type soustraitant_etat_avancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    etatAvancementId_soustraitantId_numero?: soustraitant_etat_avancementEtatAvancementIdSoustraitantIdNumeroCompoundUniqueInput
    AND?: soustraitant_etat_avancementWhereInput | soustraitant_etat_avancementWhereInput[]
    OR?: soustraitant_etat_avancementWhereInput[]
    NOT?: soustraitant_etat_avancementWhereInput | soustraitant_etat_avancementWhereInput[]
    soustraitantId?: StringFilter<"soustraitant_etat_avancement"> | string
    numero?: IntFilter<"soustraitant_etat_avancement"> | number
    date?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    commentaires?: StringNullableFilter<"soustraitant_etat_avancement"> | string | null
    estFinalise?: BoolFilter<"soustraitant_etat_avancement"> | boolean
    createdAt?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    commandeSousTraitantId?: IntNullableFilter<"soustraitant_etat_avancement"> | number | null
    etatAvancementId?: IntFilter<"soustraitant_etat_avancement"> | number
    avenant_soustraitant_etat_avancement?: Avenant_soustraitant_etat_avancementListRelationFilter
    ligne_soustraitant_etat_avancement?: Ligne_soustraitant_etat_avancementListRelationFilter
    photos?: Photo_soustraitant_etat_avancementListRelationFilter
    commande_soustraitant?: XOR<CommandeSousTraitantNullableScalarRelationFilter, CommandeSousTraitantWhereInput> | null
    etat_avancement?: XOR<EtatAvancementScalarRelationFilter, EtatAvancementWhereInput>
    soustraitant?: XOR<SoustraitantScalarRelationFilter, soustraitantWhereInput>
  }, "id" | "etatAvancementId_soustraitantId_numero">

  export type soustraitant_etat_avancementOrderByWithAggregationInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrderInput | SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandeSousTraitantId?: SortOrderInput | SortOrder
    etatAvancementId?: SortOrder
    _count?: soustraitant_etat_avancementCountOrderByAggregateInput
    _avg?: soustraitant_etat_avancementAvgOrderByAggregateInput
    _max?: soustraitant_etat_avancementMaxOrderByAggregateInput
    _min?: soustraitant_etat_avancementMinOrderByAggregateInput
    _sum?: soustraitant_etat_avancementSumOrderByAggregateInput
  }

  export type soustraitant_etat_avancementScalarWhereWithAggregatesInput = {
    AND?: soustraitant_etat_avancementScalarWhereWithAggregatesInput | soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    OR?: soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    NOT?: soustraitant_etat_avancementScalarWhereWithAggregatesInput | soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"soustraitant_etat_avancement"> | number
    soustraitantId?: StringWithAggregatesFilter<"soustraitant_etat_avancement"> | string
    numero?: IntWithAggregatesFilter<"soustraitant_etat_avancement"> | number
    date?: DateTimeWithAggregatesFilter<"soustraitant_etat_avancement"> | Date | string
    commentaires?: StringNullableWithAggregatesFilter<"soustraitant_etat_avancement"> | string | null
    estFinalise?: BoolWithAggregatesFilter<"soustraitant_etat_avancement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"soustraitant_etat_avancement"> | Date | string
    commandeSousTraitantId?: IntNullableWithAggregatesFilter<"soustraitant_etat_avancement"> | number | null
    etatAvancementId?: IntWithAggregatesFilter<"soustraitant_etat_avancement"> | number
  }

  export type photo_soustraitant_etat_avancementWhereInput = {
    AND?: photo_soustraitant_etat_avancementWhereInput | photo_soustraitant_etat_avancementWhereInput[]
    OR?: photo_soustraitant_etat_avancementWhereInput[]
    NOT?: photo_soustraitant_etat_avancementWhereInput | photo_soustraitant_etat_avancementWhereInput[]
    id?: IntFilter<"photo_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntFilter<"photo_soustraitant_etat_avancement"> | number
    url?: StringFilter<"photo_soustraitant_etat_avancement"> | string
    description?: StringNullableFilter<"photo_soustraitant_etat_avancement"> | string | null
    dateAjout?: DateTimeFilter<"photo_soustraitant_etat_avancement"> | Date | string
    soustraitant_etat_avancement?: XOR<Soustraitant_etat_avancementScalarRelationFilter, soustraitant_etat_avancementWhereInput>
  }

  export type photo_soustraitant_etat_avancementOrderByWithRelationInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    dateAjout?: SortOrder
    soustraitant_etat_avancement?: soustraitant_etat_avancementOrderByWithRelationInput
    _relevance?: photo_soustraitant_etat_avancementOrderByRelevanceInput
  }

  export type photo_soustraitant_etat_avancementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: photo_soustraitant_etat_avancementWhereInput | photo_soustraitant_etat_avancementWhereInput[]
    OR?: photo_soustraitant_etat_avancementWhereInput[]
    NOT?: photo_soustraitant_etat_avancementWhereInput | photo_soustraitant_etat_avancementWhereInput[]
    soustraitantEtatAvancementId?: IntFilter<"photo_soustraitant_etat_avancement"> | number
    url?: StringFilter<"photo_soustraitant_etat_avancement"> | string
    description?: StringNullableFilter<"photo_soustraitant_etat_avancement"> | string | null
    dateAjout?: DateTimeFilter<"photo_soustraitant_etat_avancement"> | Date | string
    soustraitant_etat_avancement?: XOR<Soustraitant_etat_avancementScalarRelationFilter, soustraitant_etat_avancementWhereInput>
  }, "id">

  export type photo_soustraitant_etat_avancementOrderByWithAggregationInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    dateAjout?: SortOrder
    _count?: photo_soustraitant_etat_avancementCountOrderByAggregateInput
    _avg?: photo_soustraitant_etat_avancementAvgOrderByAggregateInput
    _max?: photo_soustraitant_etat_avancementMaxOrderByAggregateInput
    _min?: photo_soustraitant_etat_avancementMinOrderByAggregateInput
    _sum?: photo_soustraitant_etat_avancementSumOrderByAggregateInput
  }

  export type photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput = {
    AND?: photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput | photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    OR?: photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    NOT?: photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput | photo_soustraitant_etat_avancementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"photo_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntWithAggregatesFilter<"photo_soustraitant_etat_avancement"> | number
    url?: StringWithAggregatesFilter<"photo_soustraitant_etat_avancement"> | string
    description?: StringNullableWithAggregatesFilter<"photo_soustraitant_etat_avancement"> | string | null
    dateAjout?: DateTimeWithAggregatesFilter<"photo_soustraitant_etat_avancement"> | Date | string
  }

  export type DepenseWhereInput = {
    AND?: DepenseWhereInput | DepenseWhereInput[]
    OR?: DepenseWhereInput[]
    NOT?: DepenseWhereInput | DepenseWhereInput[]
    id?: StringFilter<"Depense"> | string
    chantierId?: StringFilter<"Depense"> | string
    date?: DateTimeFilter<"Depense"> | Date | string
    montant?: FloatFilter<"Depense"> | number
    description?: StringFilter<"Depense"> | string
    categorie?: StringFilter<"Depense"> | string
    fournisseur?: StringNullableFilter<"Depense"> | string | null
    reference?: StringNullableFilter<"Depense"> | string | null
    justificatif?: StringNullableFilter<"Depense"> | string | null
    createdBy?: StringFilter<"Depense"> | string
    createdAt?: DateTimeFilter<"Depense"> | Date | string
    updatedAt?: DateTimeFilter<"Depense"> | Date | string
  }

  export type DepenseOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    date?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    fournisseur?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    justificatif?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: DepenseOrderByRelevanceInput
  }

  export type DepenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepenseWhereInput | DepenseWhereInput[]
    OR?: DepenseWhereInput[]
    NOT?: DepenseWhereInput | DepenseWhereInput[]
    chantierId?: StringFilter<"Depense"> | string
    date?: DateTimeFilter<"Depense"> | Date | string
    montant?: FloatFilter<"Depense"> | number
    description?: StringFilter<"Depense"> | string
    categorie?: StringFilter<"Depense"> | string
    fournisseur?: StringNullableFilter<"Depense"> | string | null
    reference?: StringNullableFilter<"Depense"> | string | null
    justificatif?: StringNullableFilter<"Depense"> | string | null
    createdBy?: StringFilter<"Depense"> | string
    createdAt?: DateTimeFilter<"Depense"> | Date | string
    updatedAt?: DateTimeFilter<"Depense"> | Date | string
  }, "id">

  export type DepenseOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    date?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    fournisseur?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    justificatif?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepenseCountOrderByAggregateInput
    _avg?: DepenseAvgOrderByAggregateInput
    _max?: DepenseMaxOrderByAggregateInput
    _min?: DepenseMinOrderByAggregateInput
    _sum?: DepenseSumOrderByAggregateInput
  }

  export type DepenseScalarWhereWithAggregatesInput = {
    AND?: DepenseScalarWhereWithAggregatesInput | DepenseScalarWhereWithAggregatesInput[]
    OR?: DepenseScalarWhereWithAggregatesInput[]
    NOT?: DepenseScalarWhereWithAggregatesInput | DepenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Depense"> | string
    chantierId?: StringWithAggregatesFilter<"Depense"> | string
    date?: DateTimeWithAggregatesFilter<"Depense"> | Date | string
    montant?: FloatWithAggregatesFilter<"Depense"> | number
    description?: StringWithAggregatesFilter<"Depense"> | string
    categorie?: StringWithAggregatesFilter<"Depense"> | string
    fournisseur?: StringNullableWithAggregatesFilter<"Depense"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Depense"> | string | null
    justificatif?: StringNullableWithAggregatesFilter<"Depense"> | string | null
    createdBy?: StringWithAggregatesFilter<"Depense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Depense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Depense"> | Date | string
  }

  export type UserNotesWhereInput = {
    AND?: UserNotesWhereInput | UserNotesWhereInput[]
    OR?: UserNotesWhereInput[]
    NOT?: UserNotesWhereInput | UserNotesWhereInput[]
    id?: IntFilter<"UserNotes"> | number
    userId?: StringFilter<"UserNotes"> | string
    content?: StringFilter<"UserNotes"> | string
    createdAt?: DateTimeFilter<"UserNotes"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotes"> | Date | string
  }

  export type UserNotesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: UserNotesOrderByRelevanceInput
  }

  export type UserNotesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    AND?: UserNotesWhereInput | UserNotesWhereInput[]
    OR?: UserNotesWhereInput[]
    NOT?: UserNotesWhereInput | UserNotesWhereInput[]
    content?: StringFilter<"UserNotes"> | string
    createdAt?: DateTimeFilter<"UserNotes"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotes"> | Date | string
  }, "id" | "userId">

  export type UserNotesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserNotesCountOrderByAggregateInput
    _avg?: UserNotesAvgOrderByAggregateInput
    _max?: UserNotesMaxOrderByAggregateInput
    _min?: UserNotesMinOrderByAggregateInput
    _sum?: UserNotesSumOrderByAggregateInput
  }

  export type UserNotesScalarWhereWithAggregatesInput = {
    AND?: UserNotesScalarWhereWithAggregatesInput | UserNotesScalarWhereWithAggregatesInput[]
    OR?: UserNotesScalarWhereWithAggregatesInput[]
    NOT?: UserNotesScalarWhereWithAggregatesInput | UserNotesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserNotes"> | number
    userId?: StringWithAggregatesFilter<"UserNotes"> | string
    content?: StringWithAggregatesFilter<"UserNotes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserNotes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserNotes"> | Date | string
  }

  export type RackWhereInput = {
    AND?: RackWhereInput | RackWhereInput[]
    OR?: RackWhereInput[]
    NOT?: RackWhereInput | RackWhereInput[]
    id?: StringFilter<"Rack"> | string
    nom?: StringFilter<"Rack"> | string
    position?: StringFilter<"Rack"> | string
    lignes?: IntFilter<"Rack"> | number
    colonnes?: IntFilter<"Rack"> | number
    createdAt?: DateTimeFilter<"Rack"> | Date | string
    updatedAt?: DateTimeFilter<"Rack"> | Date | string
    emplacements?: EmplacementListRelationFilter
  }

  export type RackOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    position?: SortOrder
    lignes?: SortOrder
    colonnes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emplacements?: EmplacementOrderByRelationAggregateInput
    _relevance?: RackOrderByRelevanceInput
  }

  export type RackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RackWhereInput | RackWhereInput[]
    OR?: RackWhereInput[]
    NOT?: RackWhereInput | RackWhereInput[]
    nom?: StringFilter<"Rack"> | string
    position?: StringFilter<"Rack"> | string
    lignes?: IntFilter<"Rack"> | number
    colonnes?: IntFilter<"Rack"> | number
    createdAt?: DateTimeFilter<"Rack"> | Date | string
    updatedAt?: DateTimeFilter<"Rack"> | Date | string
    emplacements?: EmplacementListRelationFilter
  }, "id">

  export type RackOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    position?: SortOrder
    lignes?: SortOrder
    colonnes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RackCountOrderByAggregateInput
    _avg?: RackAvgOrderByAggregateInput
    _max?: RackMaxOrderByAggregateInput
    _min?: RackMinOrderByAggregateInput
    _sum?: RackSumOrderByAggregateInput
  }

  export type RackScalarWhereWithAggregatesInput = {
    AND?: RackScalarWhereWithAggregatesInput | RackScalarWhereWithAggregatesInput[]
    OR?: RackScalarWhereWithAggregatesInput[]
    NOT?: RackScalarWhereWithAggregatesInput | RackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rack"> | string
    nom?: StringWithAggregatesFilter<"Rack"> | string
    position?: StringWithAggregatesFilter<"Rack"> | string
    lignes?: IntWithAggregatesFilter<"Rack"> | number
    colonnes?: IntWithAggregatesFilter<"Rack"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Rack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rack"> | Date | string
  }

  export type EmplacementWhereInput = {
    AND?: EmplacementWhereInput | EmplacementWhereInput[]
    OR?: EmplacementWhereInput[]
    NOT?: EmplacementWhereInput | EmplacementWhereInput[]
    id?: StringFilter<"Emplacement"> | string
    rackId?: StringFilter<"Emplacement"> | string
    ligne?: IntFilter<"Emplacement"> | number
    colonne?: IntFilter<"Emplacement"> | number
    codeQR?: StringFilter<"Emplacement"> | string
    statut?: StringFilter<"Emplacement"> | string
    createdAt?: DateTimeFilter<"Emplacement"> | Date | string
    updatedAt?: DateTimeFilter<"Emplacement"> | Date | string
    rack?: XOR<RackScalarRelationFilter, RackWhereInput>
    materiaux?: MateriauListRelationFilter
  }

  export type EmplacementOrderByWithRelationInput = {
    id?: SortOrder
    rackId?: SortOrder
    ligne?: SortOrder
    colonne?: SortOrder
    codeQR?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rack?: RackOrderByWithRelationInput
    materiaux?: MateriauOrderByRelationAggregateInput
    _relevance?: EmplacementOrderByRelevanceInput
  }

  export type EmplacementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codeQR?: string
    rackId_ligne_colonne?: EmplacementRackIdLigneColonneCompoundUniqueInput
    AND?: EmplacementWhereInput | EmplacementWhereInput[]
    OR?: EmplacementWhereInput[]
    NOT?: EmplacementWhereInput | EmplacementWhereInput[]
    rackId?: StringFilter<"Emplacement"> | string
    ligne?: IntFilter<"Emplacement"> | number
    colonne?: IntFilter<"Emplacement"> | number
    statut?: StringFilter<"Emplacement"> | string
    createdAt?: DateTimeFilter<"Emplacement"> | Date | string
    updatedAt?: DateTimeFilter<"Emplacement"> | Date | string
    rack?: XOR<RackScalarRelationFilter, RackWhereInput>
    materiaux?: MateriauListRelationFilter
  }, "id" | "codeQR" | "rackId_ligne_colonne">

  export type EmplacementOrderByWithAggregationInput = {
    id?: SortOrder
    rackId?: SortOrder
    ligne?: SortOrder
    colonne?: SortOrder
    codeQR?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmplacementCountOrderByAggregateInput
    _avg?: EmplacementAvgOrderByAggregateInput
    _max?: EmplacementMaxOrderByAggregateInput
    _min?: EmplacementMinOrderByAggregateInput
    _sum?: EmplacementSumOrderByAggregateInput
  }

  export type EmplacementScalarWhereWithAggregatesInput = {
    AND?: EmplacementScalarWhereWithAggregatesInput | EmplacementScalarWhereWithAggregatesInput[]
    OR?: EmplacementScalarWhereWithAggregatesInput[]
    NOT?: EmplacementScalarWhereWithAggregatesInput | EmplacementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Emplacement"> | string
    rackId?: StringWithAggregatesFilter<"Emplacement"> | string
    ligne?: IntWithAggregatesFilter<"Emplacement"> | number
    colonne?: IntWithAggregatesFilter<"Emplacement"> | number
    codeQR?: StringWithAggregatesFilter<"Emplacement"> | string
    statut?: StringWithAggregatesFilter<"Emplacement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Emplacement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Emplacement"> | Date | string
  }

  export type MateriauWhereInput = {
    AND?: MateriauWhereInput | MateriauWhereInput[]
    OR?: MateriauWhereInput[]
    NOT?: MateriauWhereInput | MateriauWhereInput[]
    id?: StringFilter<"Materiau"> | string
    nom?: StringFilter<"Materiau"> | string
    description?: StringNullableFilter<"Materiau"> | string | null
    quantite?: IntFilter<"Materiau"> | number
    codeQR?: StringNullableFilter<"Materiau"> | string | null
    emplacementId?: StringNullableFilter<"Materiau"> | string | null
    createdAt?: DateTimeFilter<"Materiau"> | Date | string
    updatedAt?: DateTimeFilter<"Materiau"> | Date | string
    emplacement?: XOR<EmplacementNullableScalarRelationFilter, EmplacementWhereInput> | null
  }

  export type MateriauOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    quantite?: SortOrder
    codeQR?: SortOrderInput | SortOrder
    emplacementId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emplacement?: EmplacementOrderByWithRelationInput
    _relevance?: MateriauOrderByRelevanceInput
  }

  export type MateriauWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codeQR?: string
    AND?: MateriauWhereInput | MateriauWhereInput[]
    OR?: MateriauWhereInput[]
    NOT?: MateriauWhereInput | MateriauWhereInput[]
    nom?: StringFilter<"Materiau"> | string
    description?: StringNullableFilter<"Materiau"> | string | null
    quantite?: IntFilter<"Materiau"> | number
    emplacementId?: StringNullableFilter<"Materiau"> | string | null
    createdAt?: DateTimeFilter<"Materiau"> | Date | string
    updatedAt?: DateTimeFilter<"Materiau"> | Date | string
    emplacement?: XOR<EmplacementNullableScalarRelationFilter, EmplacementWhereInput> | null
  }, "id" | "codeQR">

  export type MateriauOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    quantite?: SortOrder
    codeQR?: SortOrderInput | SortOrder
    emplacementId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MateriauCountOrderByAggregateInput
    _avg?: MateriauAvgOrderByAggregateInput
    _max?: MateriauMaxOrderByAggregateInput
    _min?: MateriauMinOrderByAggregateInput
    _sum?: MateriauSumOrderByAggregateInput
  }

  export type MateriauScalarWhereWithAggregatesInput = {
    AND?: MateriauScalarWhereWithAggregatesInput | MateriauScalarWhereWithAggregatesInput[]
    OR?: MateriauScalarWhereWithAggregatesInput[]
    NOT?: MateriauScalarWhereWithAggregatesInput | MateriauScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Materiau"> | string
    nom?: StringWithAggregatesFilter<"Materiau"> | string
    description?: StringNullableWithAggregatesFilter<"Materiau"> | string | null
    quantite?: IntWithAggregatesFilter<"Materiau"> | number
    codeQR?: StringNullableWithAggregatesFilter<"Materiau"> | string | null
    emplacementId?: StringNullableWithAggregatesFilter<"Materiau"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Materiau"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Materiau"> | Date | string
  }

  export type AvenantWhereInput = {
    AND?: AvenantWhereInput | AvenantWhereInput[]
    OR?: AvenantWhereInput[]
    NOT?: AvenantWhereInput | AvenantWhereInput[]
    id?: IntFilter<"Avenant"> | number
    numero?: IntFilter<"Avenant"> | number
    date?: DateTimeFilter<"Avenant"> | Date | string
    description?: StringNullableFilter<"Avenant"> | string | null
    chantierId?: StringFilter<"Avenant"> | string
    marcheId?: IntFilter<"Avenant"> | number
    createdAt?: DateTimeFilter<"Avenant"> | Date | string
    updatedAt?: DateTimeFilter<"Avenant"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    Marche?: XOR<MarcheScalarRelationFilter, MarcheWhereInput>
  }

  export type AvenantOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    chantierId?: SortOrder
    marcheId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Chantier?: ChantierOrderByWithRelationInput
    Marche?: MarcheOrderByWithRelationInput
    _relevance?: AvenantOrderByRelevanceInput
  }

  export type AvenantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chantierId_numero?: AvenantChantierIdNumeroCompoundUniqueInput
    AND?: AvenantWhereInput | AvenantWhereInput[]
    OR?: AvenantWhereInput[]
    NOT?: AvenantWhereInput | AvenantWhereInput[]
    numero?: IntFilter<"Avenant"> | number
    date?: DateTimeFilter<"Avenant"> | Date | string
    description?: StringNullableFilter<"Avenant"> | string | null
    chantierId?: StringFilter<"Avenant"> | string
    marcheId?: IntFilter<"Avenant"> | number
    createdAt?: DateTimeFilter<"Avenant"> | Date | string
    updatedAt?: DateTimeFilter<"Avenant"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    Marche?: XOR<MarcheScalarRelationFilter, MarcheWhereInput>
  }, "id" | "chantierId_numero">

  export type AvenantOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    chantierId?: SortOrder
    marcheId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvenantCountOrderByAggregateInput
    _avg?: AvenantAvgOrderByAggregateInput
    _max?: AvenantMaxOrderByAggregateInput
    _min?: AvenantMinOrderByAggregateInput
    _sum?: AvenantSumOrderByAggregateInput
  }

  export type AvenantScalarWhereWithAggregatesInput = {
    AND?: AvenantScalarWhereWithAggregatesInput | AvenantScalarWhereWithAggregatesInput[]
    OR?: AvenantScalarWhereWithAggregatesInput[]
    NOT?: AvenantScalarWhereWithAggregatesInput | AvenantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Avenant"> | number
    numero?: IntWithAggregatesFilter<"Avenant"> | number
    date?: DateTimeWithAggregatesFilter<"Avenant"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Avenant"> | string | null
    chantierId?: StringWithAggregatesFilter<"Avenant"> | string
    marcheId?: IntWithAggregatesFilter<"Avenant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Avenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Avenant"> | Date | string
  }

  export type ChantierWhereInput = {
    AND?: ChantierWhereInput | ChantierWhereInput[]
    OR?: ChantierWhereInput[]
    NOT?: ChantierWhereInput | ChantierWhereInput[]
    id?: IntFilter<"Chantier"> | number
    chantierId?: StringFilter<"Chantier"> | string
    nomChantier?: StringFilter<"Chantier"> | string
    adresseChantier?: StringNullableFilter<"Chantier"> | string | null
    createdAt?: DateTimeFilter<"Chantier"> | Date | string
    updatedAt?: DateTimeFilter<"Chantier"> | Date | string
    clientId?: StringNullableFilter<"Chantier"> | string | null
    budget?: FloatNullableFilter<"Chantier"> | number | null
    dateDebut?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    dateFinPrevue?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    dateFinReelle?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    description?: StringNullableFilter<"Chantier"> | string | null
    statut?: StringFilter<"Chantier"> | string
    villeChantier?: StringNullableFilter<"Chantier"> | string | null
    dureeEnJours?: IntNullableFilter<"Chantier"> | number | null
    typeDuree?: StringFilter<"Chantier"> | string
    avenants?: AvenantListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    documents?: DocumentListRelationFilter
    etats?: EtatListRelationFilter
    marches?: XOR<MarcheNullableScalarRelationFilter, MarcheWhereInput> | null
    notes?: NoteListRelationFilter
    taches?: TacheListRelationFilter
    admintasks?: AdmintaskListRelationFilter
    bonsRegie?: BonRegieListRelationFilter
  }

  export type ChantierOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    nomChantier?: SortOrder
    adresseChantier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFinPrevue?: SortOrderInput | SortOrder
    dateFinReelle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    statut?: SortOrder
    villeChantier?: SortOrderInput | SortOrder
    dureeEnJours?: SortOrderInput | SortOrder
    typeDuree?: SortOrder
    avenants?: AvenantOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    etats?: EtatOrderByRelationAggregateInput
    marches?: MarcheOrderByWithRelationInput
    notes?: NoteOrderByRelationAggregateInput
    taches?: TacheOrderByRelationAggregateInput
    admintasks?: admintaskOrderByRelationAggregateInput
    bonsRegie?: BonRegieOrderByRelationAggregateInput
    _relevance?: ChantierOrderByRelevanceInput
  }

  export type ChantierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chantierId?: string
    AND?: ChantierWhereInput | ChantierWhereInput[]
    OR?: ChantierWhereInput[]
    NOT?: ChantierWhereInput | ChantierWhereInput[]
    nomChantier?: StringFilter<"Chantier"> | string
    adresseChantier?: StringNullableFilter<"Chantier"> | string | null
    createdAt?: DateTimeFilter<"Chantier"> | Date | string
    updatedAt?: DateTimeFilter<"Chantier"> | Date | string
    clientId?: StringNullableFilter<"Chantier"> | string | null
    budget?: FloatNullableFilter<"Chantier"> | number | null
    dateDebut?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    dateFinPrevue?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    dateFinReelle?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    description?: StringNullableFilter<"Chantier"> | string | null
    statut?: StringFilter<"Chantier"> | string
    villeChantier?: StringNullableFilter<"Chantier"> | string | null
    dureeEnJours?: IntNullableFilter<"Chantier"> | number | null
    typeDuree?: StringFilter<"Chantier"> | string
    avenants?: AvenantListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    documents?: DocumentListRelationFilter
    etats?: EtatListRelationFilter
    marches?: XOR<MarcheNullableScalarRelationFilter, MarcheWhereInput> | null
    notes?: NoteListRelationFilter
    taches?: TacheListRelationFilter
    admintasks?: AdmintaskListRelationFilter
    bonsRegie?: BonRegieListRelationFilter
  }, "id" | "chantierId">

  export type ChantierOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    nomChantier?: SortOrder
    adresseChantier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFinPrevue?: SortOrderInput | SortOrder
    dateFinReelle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    statut?: SortOrder
    villeChantier?: SortOrderInput | SortOrder
    dureeEnJours?: SortOrderInput | SortOrder
    typeDuree?: SortOrder
    _count?: ChantierCountOrderByAggregateInput
    _avg?: ChantierAvgOrderByAggregateInput
    _max?: ChantierMaxOrderByAggregateInput
    _min?: ChantierMinOrderByAggregateInput
    _sum?: ChantierSumOrderByAggregateInput
  }

  export type ChantierScalarWhereWithAggregatesInput = {
    AND?: ChantierScalarWhereWithAggregatesInput | ChantierScalarWhereWithAggregatesInput[]
    OR?: ChantierScalarWhereWithAggregatesInput[]
    NOT?: ChantierScalarWhereWithAggregatesInput | ChantierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chantier"> | number
    chantierId?: StringWithAggregatesFilter<"Chantier"> | string
    nomChantier?: StringWithAggregatesFilter<"Chantier"> | string
    adresseChantier?: StringNullableWithAggregatesFilter<"Chantier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Chantier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chantier"> | Date | string
    clientId?: StringNullableWithAggregatesFilter<"Chantier"> | string | null
    budget?: FloatNullableWithAggregatesFilter<"Chantier"> | number | null
    dateDebut?: DateTimeNullableWithAggregatesFilter<"Chantier"> | Date | string | null
    dateFinPrevue?: DateTimeNullableWithAggregatesFilter<"Chantier"> | Date | string | null
    dateFinReelle?: DateTimeNullableWithAggregatesFilter<"Chantier"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Chantier"> | string | null
    statut?: StringWithAggregatesFilter<"Chantier"> | string
    villeChantier?: StringNullableWithAggregatesFilter<"Chantier"> | string | null
    dureeEnJours?: IntNullableWithAggregatesFilter<"Chantier"> | number | null
    typeDuree?: StringWithAggregatesFilter<"Chantier"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    nom?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    adresse?: StringNullableFilter<"Client"> | string | null
    telephone?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    Chantier?: ChantierListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Chantier?: ChantierOrderByRelationAggregateInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    nom?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    adresse?: StringNullableFilter<"Client"> | string | null
    telephone?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    Chantier?: ChantierListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    nom?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Client"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    nom?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    taille?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    chantierId?: StringFilter<"Document"> | string
    createdBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    metadata?: JsonNullableFilter<"Document">
    chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    taille?: SortOrder
    mimeType?: SortOrder
    chantierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    chantier?: ChantierOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    nom?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    taille?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    chantierId?: StringFilter<"Document"> | string
    createdBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    metadata?: JsonNullableFilter<"Document">
    chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    taille?: SortOrder
    mimeType?: SortOrder
    chantierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    nom?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    taille?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    chantierId?: StringWithAggregatesFilter<"Document"> | string
    createdBy?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Document">
  }

  export type DocumentOuvrierWhereInput = {
    AND?: DocumentOuvrierWhereInput | DocumentOuvrierWhereInput[]
    OR?: DocumentOuvrierWhereInput[]
    NOT?: DocumentOuvrierWhereInput | DocumentOuvrierWhereInput[]
    id?: StringFilter<"DocumentOuvrier"> | string
    nom?: StringFilter<"DocumentOuvrier"> | string
    type?: StringFilter<"DocumentOuvrier"> | string
    url?: StringFilter<"DocumentOuvrier"> | string
    dateExpiration?: DateTimeNullableFilter<"DocumentOuvrier"> | Date | string | null
    ouvrierId?: StringFilter<"DocumentOuvrier"> | string
    createdAt?: DateTimeFilter<"DocumentOuvrier"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentOuvrier"> | Date | string
    Ouvrier?: XOR<OuvrierScalarRelationFilter, OuvrierWhereInput>
  }

  export type DocumentOuvrierOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    dateExpiration?: SortOrderInput | SortOrder
    ouvrierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Ouvrier?: OuvrierOrderByWithRelationInput
    _relevance?: DocumentOuvrierOrderByRelevanceInput
  }

  export type DocumentOuvrierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentOuvrierWhereInput | DocumentOuvrierWhereInput[]
    OR?: DocumentOuvrierWhereInput[]
    NOT?: DocumentOuvrierWhereInput | DocumentOuvrierWhereInput[]
    nom?: StringFilter<"DocumentOuvrier"> | string
    type?: StringFilter<"DocumentOuvrier"> | string
    url?: StringFilter<"DocumentOuvrier"> | string
    dateExpiration?: DateTimeNullableFilter<"DocumentOuvrier"> | Date | string | null
    ouvrierId?: StringFilter<"DocumentOuvrier"> | string
    createdAt?: DateTimeFilter<"DocumentOuvrier"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentOuvrier"> | Date | string
    Ouvrier?: XOR<OuvrierScalarRelationFilter, OuvrierWhereInput>
  }, "id">

  export type DocumentOuvrierOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    dateExpiration?: SortOrderInput | SortOrder
    ouvrierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentOuvrierCountOrderByAggregateInput
    _max?: DocumentOuvrierMaxOrderByAggregateInput
    _min?: DocumentOuvrierMinOrderByAggregateInput
  }

  export type DocumentOuvrierScalarWhereWithAggregatesInput = {
    AND?: DocumentOuvrierScalarWhereWithAggregatesInput | DocumentOuvrierScalarWhereWithAggregatesInput[]
    OR?: DocumentOuvrierScalarWhereWithAggregatesInput[]
    NOT?: DocumentOuvrierScalarWhereWithAggregatesInput | DocumentOuvrierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentOuvrier"> | string
    nom?: StringWithAggregatesFilter<"DocumentOuvrier"> | string
    type?: StringWithAggregatesFilter<"DocumentOuvrier"> | string
    url?: StringWithAggregatesFilter<"DocumentOuvrier"> | string
    dateExpiration?: DateTimeNullableWithAggregatesFilter<"DocumentOuvrier"> | Date | string | null
    ouvrierId?: StringWithAggregatesFilter<"DocumentOuvrier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentOuvrier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentOuvrier"> | Date | string
  }

  export type EtatWhereInput = {
    AND?: EtatWhereInput | EtatWhereInput[]
    OR?: EtatWhereInput[]
    NOT?: EtatWhereInput | EtatWhereInput[]
    id?: IntFilter<"Etat"> | number
    numero?: IntFilter<"Etat"> | number
    date?: DateTimeFilter<"Etat"> | Date | string
    chantierId?: StringFilter<"Etat"> | string
    createdAt?: DateTimeFilter<"Etat"> | Date | string
    updatedAt?: DateTimeFilter<"Etat"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    LigneEtat?: LigneEtatListRelationFilter
  }

  export type EtatOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    chantierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Chantier?: ChantierOrderByWithRelationInput
    LigneEtat?: LigneEtatOrderByRelationAggregateInput
    _relevance?: EtatOrderByRelevanceInput
  }

  export type EtatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chantierId_numero?: EtatChantierIdNumeroCompoundUniqueInput
    AND?: EtatWhereInput | EtatWhereInput[]
    OR?: EtatWhereInput[]
    NOT?: EtatWhereInput | EtatWhereInput[]
    numero?: IntFilter<"Etat"> | number
    date?: DateTimeFilter<"Etat"> | Date | string
    chantierId?: StringFilter<"Etat"> | string
    createdAt?: DateTimeFilter<"Etat"> | Date | string
    updatedAt?: DateTimeFilter<"Etat"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    LigneEtat?: LigneEtatListRelationFilter
  }, "id" | "chantierId_numero">

  export type EtatOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    chantierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EtatCountOrderByAggregateInput
    _avg?: EtatAvgOrderByAggregateInput
    _max?: EtatMaxOrderByAggregateInput
    _min?: EtatMinOrderByAggregateInput
    _sum?: EtatSumOrderByAggregateInput
  }

  export type EtatScalarWhereWithAggregatesInput = {
    AND?: EtatScalarWhereWithAggregatesInput | EtatScalarWhereWithAggregatesInput[]
    OR?: EtatScalarWhereWithAggregatesInput[]
    NOT?: EtatScalarWhereWithAggregatesInput | EtatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Etat"> | number
    numero?: IntWithAggregatesFilter<"Etat"> | number
    date?: DateTimeWithAggregatesFilter<"Etat"> | Date | string
    chantierId?: StringWithAggregatesFilter<"Etat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Etat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Etat"> | Date | string
  }

  export type LigneEtatWhereInput = {
    AND?: LigneEtatWhereInput | LigneEtatWhereInput[]
    OR?: LigneEtatWhereInput[]
    NOT?: LigneEtatWhereInput | LigneEtatWhereInput[]
    id?: IntFilter<"LigneEtat"> | number
    etatId?: IntFilter<"LigneEtat"> | number
    ligneMarcheId?: IntFilter<"LigneEtat"> | number
    quantite?: FloatFilter<"LigneEtat"> | number
    createdAt?: DateTimeFilter<"LigneEtat"> | Date | string
    updatedAt?: DateTimeFilter<"LigneEtat"> | Date | string
    Etat?: XOR<EtatScalarRelationFilter, EtatWhereInput>
    LigneMarche?: XOR<LigneMarcheScalarRelationFilter, LigneMarcheWhereInput>
  }

  export type LigneEtatOrderByWithRelationInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Etat?: EtatOrderByWithRelationInput
    LigneMarche?: LigneMarcheOrderByWithRelationInput
  }

  export type LigneEtatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LigneEtatWhereInput | LigneEtatWhereInput[]
    OR?: LigneEtatWhereInput[]
    NOT?: LigneEtatWhereInput | LigneEtatWhereInput[]
    etatId?: IntFilter<"LigneEtat"> | number
    ligneMarcheId?: IntFilter<"LigneEtat"> | number
    quantite?: FloatFilter<"LigneEtat"> | number
    createdAt?: DateTimeFilter<"LigneEtat"> | Date | string
    updatedAt?: DateTimeFilter<"LigneEtat"> | Date | string
    Etat?: XOR<EtatScalarRelationFilter, EtatWhereInput>
    LigneMarche?: XOR<LigneMarcheScalarRelationFilter, LigneMarcheWhereInput>
  }, "id">

  export type LigneEtatOrderByWithAggregationInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LigneEtatCountOrderByAggregateInput
    _avg?: LigneEtatAvgOrderByAggregateInput
    _max?: LigneEtatMaxOrderByAggregateInput
    _min?: LigneEtatMinOrderByAggregateInput
    _sum?: LigneEtatSumOrderByAggregateInput
  }

  export type LigneEtatScalarWhereWithAggregatesInput = {
    AND?: LigneEtatScalarWhereWithAggregatesInput | LigneEtatScalarWhereWithAggregatesInput[]
    OR?: LigneEtatScalarWhereWithAggregatesInput[]
    NOT?: LigneEtatScalarWhereWithAggregatesInput | LigneEtatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LigneEtat"> | number
    etatId?: IntWithAggregatesFilter<"LigneEtat"> | number
    ligneMarcheId?: IntWithAggregatesFilter<"LigneEtat"> | number
    quantite?: FloatWithAggregatesFilter<"LigneEtat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LigneEtat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LigneEtat"> | Date | string
  }

  export type LigneMarcheWhereInput = {
    AND?: LigneMarcheWhereInput | LigneMarcheWhereInput[]
    OR?: LigneMarcheWhereInput[]
    NOT?: LigneMarcheWhereInput | LigneMarcheWhereInput[]
    id?: IntFilter<"LigneMarche"> | number
    article?: IntFilter<"LigneMarche"> | number
    descriptif?: StringFilter<"LigneMarche"> | string
    unite?: StringFilter<"LigneMarche"> | string
    quantite?: FloatFilter<"LigneMarche"> | number
    prixUnitaire?: FloatFilter<"LigneMarche"> | number
    marcheId?: IntFilter<"LigneMarche"> | number
    LigneEtat?: LigneEtatListRelationFilter
    Marche?: XOR<MarcheScalarRelationFilter, MarcheWhereInput>
  }

  export type LigneMarcheOrderByWithRelationInput = {
    id?: SortOrder
    article?: SortOrder
    descriptif?: SortOrder
    unite?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
    LigneEtat?: LigneEtatOrderByRelationAggregateInput
    Marche?: MarcheOrderByWithRelationInput
    _relevance?: LigneMarcheOrderByRelevanceInput
  }

  export type LigneMarcheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LigneMarcheWhereInput | LigneMarcheWhereInput[]
    OR?: LigneMarcheWhereInput[]
    NOT?: LigneMarcheWhereInput | LigneMarcheWhereInput[]
    article?: IntFilter<"LigneMarche"> | number
    descriptif?: StringFilter<"LigneMarche"> | string
    unite?: StringFilter<"LigneMarche"> | string
    quantite?: FloatFilter<"LigneMarche"> | number
    prixUnitaire?: FloatFilter<"LigneMarche"> | number
    marcheId?: IntFilter<"LigneMarche"> | number
    LigneEtat?: LigneEtatListRelationFilter
    Marche?: XOR<MarcheScalarRelationFilter, MarcheWhereInput>
  }, "id">

  export type LigneMarcheOrderByWithAggregationInput = {
    id?: SortOrder
    article?: SortOrder
    descriptif?: SortOrder
    unite?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
    _count?: LigneMarcheCountOrderByAggregateInput
    _avg?: LigneMarcheAvgOrderByAggregateInput
    _max?: LigneMarcheMaxOrderByAggregateInput
    _min?: LigneMarcheMinOrderByAggregateInput
    _sum?: LigneMarcheSumOrderByAggregateInput
  }

  export type LigneMarcheScalarWhereWithAggregatesInput = {
    AND?: LigneMarcheScalarWhereWithAggregatesInput | LigneMarcheScalarWhereWithAggregatesInput[]
    OR?: LigneMarcheScalarWhereWithAggregatesInput[]
    NOT?: LigneMarcheScalarWhereWithAggregatesInput | LigneMarcheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LigneMarche"> | number
    article?: IntWithAggregatesFilter<"LigneMarche"> | number
    descriptif?: StringWithAggregatesFilter<"LigneMarche"> | string
    unite?: StringWithAggregatesFilter<"LigneMarche"> | string
    quantite?: FloatWithAggregatesFilter<"LigneMarche"> | number
    prixUnitaire?: FloatWithAggregatesFilter<"LigneMarche"> | number
    marcheId?: IntWithAggregatesFilter<"LigneMarche"> | number
  }

  export type MachineWhereInput = {
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    id?: StringFilter<"Machine"> | string
    nom?: StringFilter<"Machine"> | string
    modele?: StringFilter<"Machine"> | string
    numeroSerie?: StringNullableFilter<"Machine"> | string | null
    localisation?: StringFilter<"Machine"> | string
    statut?: EnumMachine_statutFilter<"Machine"> | $Enums.Machine_statut
    dateAchat?: DateTimeNullableFilter<"Machine"> | Date | string | null
    qrCode?: StringFilter<"Machine"> | string
    commentaire?: StringNullableFilter<"Machine"> | string | null
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
    pret?: PretListRelationFilter
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrderInput | SortOrder
    localisation?: SortOrder
    statut?: SortOrder
    dateAchat?: SortOrderInput | SortOrder
    qrCode?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pret?: pretOrderByRelationAggregateInput
    _relevance?: MachineOrderByRelevanceInput
  }

  export type MachineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrCode?: string
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    nom?: StringFilter<"Machine"> | string
    modele?: StringFilter<"Machine"> | string
    numeroSerie?: StringNullableFilter<"Machine"> | string | null
    localisation?: StringFilter<"Machine"> | string
    statut?: EnumMachine_statutFilter<"Machine"> | $Enums.Machine_statut
    dateAchat?: DateTimeNullableFilter<"Machine"> | Date | string | null
    commentaire?: StringNullableFilter<"Machine"> | string | null
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
    pret?: PretListRelationFilter
  }, "id" | "qrCode">

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrderInput | SortOrder
    localisation?: SortOrder
    statut?: SortOrder
    dateAchat?: SortOrderInput | SortOrder
    qrCode?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MachineCountOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    OR?: MachineScalarWhereWithAggregatesInput[]
    NOT?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Machine"> | string
    nom?: StringWithAggregatesFilter<"Machine"> | string
    modele?: StringWithAggregatesFilter<"Machine"> | string
    numeroSerie?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    localisation?: StringWithAggregatesFilter<"Machine"> | string
    statut?: EnumMachine_statutWithAggregatesFilter<"Machine"> | $Enums.Machine_statut
    dateAchat?: DateTimeNullableWithAggregatesFilter<"Machine"> | Date | string | null
    qrCode?: StringWithAggregatesFilter<"Machine"> | string
    commentaire?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Machine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Machine"> | Date | string
  }

  export type MarcheWhereInput = {
    AND?: MarcheWhereInput | MarcheWhereInput[]
    OR?: MarcheWhereInput[]
    NOT?: MarcheWhereInput | MarcheWhereInput[]
    id?: IntFilter<"Marche"> | number
    chantierId?: StringFilter<"Marche"> | string
    dateImport?: DateTimeFilter<"Marche"> | Date | string
    montantTotal?: FloatFilter<"Marche"> | number
    Avenant?: AvenantListRelationFilter
    LigneMarche?: LigneMarcheListRelationFilter
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
  }

  export type MarcheOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    dateImport?: SortOrder
    montantTotal?: SortOrder
    Avenant?: AvenantOrderByRelationAggregateInput
    LigneMarche?: LigneMarcheOrderByRelationAggregateInput
    Chantier?: ChantierOrderByWithRelationInput
    _relevance?: MarcheOrderByRelevanceInput
  }

  export type MarcheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chantierId?: string
    AND?: MarcheWhereInput | MarcheWhereInput[]
    OR?: MarcheWhereInput[]
    NOT?: MarcheWhereInput | MarcheWhereInput[]
    dateImport?: DateTimeFilter<"Marche"> | Date | string
    montantTotal?: FloatFilter<"Marche"> | number
    Avenant?: AvenantListRelationFilter
    LigneMarche?: LigneMarcheListRelationFilter
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
  }, "id" | "chantierId">

  export type MarcheOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    dateImport?: SortOrder
    montantTotal?: SortOrder
    _count?: MarcheCountOrderByAggregateInput
    _avg?: MarcheAvgOrderByAggregateInput
    _max?: MarcheMaxOrderByAggregateInput
    _min?: MarcheMinOrderByAggregateInput
    _sum?: MarcheSumOrderByAggregateInput
  }

  export type MarcheScalarWhereWithAggregatesInput = {
    AND?: MarcheScalarWhereWithAggregatesInput | MarcheScalarWhereWithAggregatesInput[]
    OR?: MarcheScalarWhereWithAggregatesInput[]
    NOT?: MarcheScalarWhereWithAggregatesInput | MarcheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Marche"> | number
    chantierId?: StringWithAggregatesFilter<"Marche"> | string
    dateImport?: DateTimeWithAggregatesFilter<"Marche"> | Date | string
    montantTotal?: FloatWithAggregatesFilter<"Marche"> | number
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: IntFilter<"Note"> | number
    chantierId?: StringFilter<"Note"> | string
    contenu?: StringFilter<"Note"> | string
    createdBy?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    contenu?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Chantier?: ChantierOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: NoteOrderByRelevanceInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    chantierId?: StringFilter<"Note"> | string
    contenu?: StringFilter<"Note"> | string
    createdBy?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    chantierId?: SortOrder
    contenu?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _avg?: NoteAvgOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
    _sum?: NoteSumOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Note"> | number
    chantierId?: StringWithAggregatesFilter<"Note"> | string
    contenu?: StringWithAggregatesFilter<"Note"> | string
    createdBy?: StringWithAggregatesFilter<"Note"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type OuvrierWhereInput = {
    AND?: OuvrierWhereInput | OuvrierWhereInput[]
    OR?: OuvrierWhereInput[]
    NOT?: OuvrierWhereInput | OuvrierWhereInput[]
    id?: StringFilter<"Ouvrier"> | string
    nom?: StringFilter<"Ouvrier"> | string
    prenom?: StringFilter<"Ouvrier"> | string
    email?: StringNullableFilter<"Ouvrier"> | string | null
    telephone?: StringNullableFilter<"Ouvrier"> | string | null
    dateEntree?: DateTimeFilter<"Ouvrier"> | Date | string
    poste?: StringFilter<"Ouvrier"> | string
    sousTraitantId?: StringFilter<"Ouvrier"> | string
    createdAt?: DateTimeFilter<"Ouvrier"> | Date | string
    updatedAt?: DateTimeFilter<"Ouvrier"> | Date | string
    DocumentOuvrier?: DocumentOuvrierListRelationFilter
  }

  export type OuvrierOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    dateEntree?: SortOrder
    poste?: SortOrder
    sousTraitantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DocumentOuvrier?: DocumentOuvrierOrderByRelationAggregateInput
    _relevance?: OuvrierOrderByRelevanceInput
  }

  export type OuvrierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OuvrierWhereInput | OuvrierWhereInput[]
    OR?: OuvrierWhereInput[]
    NOT?: OuvrierWhereInput | OuvrierWhereInput[]
    nom?: StringFilter<"Ouvrier"> | string
    prenom?: StringFilter<"Ouvrier"> | string
    email?: StringNullableFilter<"Ouvrier"> | string | null
    telephone?: StringNullableFilter<"Ouvrier"> | string | null
    dateEntree?: DateTimeFilter<"Ouvrier"> | Date | string
    poste?: StringFilter<"Ouvrier"> | string
    sousTraitantId?: StringFilter<"Ouvrier"> | string
    createdAt?: DateTimeFilter<"Ouvrier"> | Date | string
    updatedAt?: DateTimeFilter<"Ouvrier"> | Date | string
    DocumentOuvrier?: DocumentOuvrierListRelationFilter
  }, "id">

  export type OuvrierOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    dateEntree?: SortOrder
    poste?: SortOrder
    sousTraitantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OuvrierCountOrderByAggregateInput
    _max?: OuvrierMaxOrderByAggregateInput
    _min?: OuvrierMinOrderByAggregateInput
  }

  export type OuvrierScalarWhereWithAggregatesInput = {
    AND?: OuvrierScalarWhereWithAggregatesInput | OuvrierScalarWhereWithAggregatesInput[]
    OR?: OuvrierScalarWhereWithAggregatesInput[]
    NOT?: OuvrierScalarWhereWithAggregatesInput | OuvrierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ouvrier"> | string
    nom?: StringWithAggregatesFilter<"Ouvrier"> | string
    prenom?: StringWithAggregatesFilter<"Ouvrier"> | string
    email?: StringNullableWithAggregatesFilter<"Ouvrier"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"Ouvrier"> | string | null
    dateEntree?: DateTimeWithAggregatesFilter<"Ouvrier"> | Date | string
    poste?: StringWithAggregatesFilter<"Ouvrier"> | string
    sousTraitantId?: StringWithAggregatesFilter<"Ouvrier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ouvrier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ouvrier"> | Date | string
  }

  export type TacheWhereInput = {
    AND?: TacheWhereInput | TacheWhereInput[]
    OR?: TacheWhereInput[]
    NOT?: TacheWhereInput | TacheWhereInput[]
    id?: StringFilter<"Tache"> | string
    label?: StringFilter<"Tache"> | string
    completed?: BoolFilter<"Tache"> | boolean
    completedAt?: DateTimeNullableFilter<"Tache"> | Date | string | null
    chantierId?: StringFilter<"Tache"> | string
    category?: StringFilter<"Tache"> | string
    createdAt?: DateTimeFilter<"Tache"> | Date | string
    updatedAt?: DateTimeFilter<"Tache"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
  }

  export type TacheOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    chantierId?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Chantier?: ChantierOrderByWithRelationInput
    _relevance?: TacheOrderByRelevanceInput
  }

  export type TacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chantierId_id?: TacheChantierIdIdCompoundUniqueInput
    AND?: TacheWhereInput | TacheWhereInput[]
    OR?: TacheWhereInput[]
    NOT?: TacheWhereInput | TacheWhereInput[]
    label?: StringFilter<"Tache"> | string
    completed?: BoolFilter<"Tache"> | boolean
    completedAt?: DateTimeNullableFilter<"Tache"> | Date | string | null
    chantierId?: StringFilter<"Tache"> | string
    category?: StringFilter<"Tache"> | string
    createdAt?: DateTimeFilter<"Tache"> | Date | string
    updatedAt?: DateTimeFilter<"Tache"> | Date | string
    Chantier?: XOR<ChantierScalarRelationFilter, ChantierWhereInput>
  }, "id" | "chantierId_id">

  export type TacheOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    chantierId?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TacheCountOrderByAggregateInput
    _max?: TacheMaxOrderByAggregateInput
    _min?: TacheMinOrderByAggregateInput
  }

  export type TacheScalarWhereWithAggregatesInput = {
    AND?: TacheScalarWhereWithAggregatesInput | TacheScalarWhereWithAggregatesInput[]
    OR?: TacheScalarWhereWithAggregatesInput[]
    NOT?: TacheScalarWhereWithAggregatesInput | TacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tache"> | string
    label?: StringWithAggregatesFilter<"Tache"> | string
    completed?: BoolWithAggregatesFilter<"Tache"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Tache"> | Date | string | null
    chantierId?: StringWithAggregatesFilter<"Tache"> | string
    category?: StringWithAggregatesFilter<"Tache"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tache"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tache"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUser_roleFilter<"User"> | $Enums.User_role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringNullableFilter<"User"> | string | null
    Document?: DocumentListRelationFilter
    Note?: NoteListRelationFilter
    admintask?: AdmintaskListRelationFilter
    pret?: PretListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    Document?: DocumentOrderByRelationAggregateInput
    Note?: NoteOrderByRelationAggregateInput
    admintask?: admintaskOrderByRelationAggregateInput
    pret?: pretOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUser_roleFilter<"User"> | $Enums.User_role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringNullableFilter<"User"> | string | null
    Document?: DocumentListRelationFilter
    Note?: NoteListRelationFilter
    admintask?: AdmintaskListRelationFilter
    pret?: PretListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUser_roleWithAggregatesFilter<"User"> | $Enums.User_role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type BonRegieWhereInput = {
    AND?: BonRegieWhereInput | BonRegieWhereInput[]
    OR?: BonRegieWhereInput[]
    NOT?: BonRegieWhereInput | BonRegieWhereInput[]
    id?: IntFilter<"BonRegie"> | number
    dates?: StringFilter<"BonRegie"> | string
    client?: StringFilter<"BonRegie"> | string
    nomChantier?: StringFilter<"BonRegie"> | string
    description?: StringFilter<"BonRegie"> | string
    tempsPreparation?: FloatNullableFilter<"BonRegie"> | number | null
    tempsTrajets?: FloatNullableFilter<"BonRegie"> | number | null
    tempsChantier?: FloatNullableFilter<"BonRegie"> | number | null
    nombreTechniciens?: IntNullableFilter<"BonRegie"> | number | null
    materiaux?: StringFilter<"BonRegie"> | string
    nomSignataire?: StringFilter<"BonRegie"> | string
    signature?: StringFilter<"BonRegie"> | string
    dateSignature?: DateTimeFilter<"BonRegie"> | Date | string
    createdAt?: DateTimeFilter<"BonRegie"> | Date | string
    updatedAt?: DateTimeFilter<"BonRegie"> | Date | string
    chantierId?: StringNullableFilter<"BonRegie"> | string | null
    chantier?: XOR<ChantierNullableScalarRelationFilter, ChantierWhereInput> | null
  }

  export type BonRegieOrderByWithRelationInput = {
    id?: SortOrder
    dates?: SortOrder
    client?: SortOrder
    nomChantier?: SortOrder
    description?: SortOrder
    tempsPreparation?: SortOrderInput | SortOrder
    tempsTrajets?: SortOrderInput | SortOrder
    tempsChantier?: SortOrderInput | SortOrder
    nombreTechniciens?: SortOrderInput | SortOrder
    materiaux?: SortOrder
    nomSignataire?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chantierId?: SortOrderInput | SortOrder
    chantier?: ChantierOrderByWithRelationInput
    _relevance?: BonRegieOrderByRelevanceInput
  }

  export type BonRegieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BonRegieWhereInput | BonRegieWhereInput[]
    OR?: BonRegieWhereInput[]
    NOT?: BonRegieWhereInput | BonRegieWhereInput[]
    dates?: StringFilter<"BonRegie"> | string
    client?: StringFilter<"BonRegie"> | string
    nomChantier?: StringFilter<"BonRegie"> | string
    description?: StringFilter<"BonRegie"> | string
    tempsPreparation?: FloatNullableFilter<"BonRegie"> | number | null
    tempsTrajets?: FloatNullableFilter<"BonRegie"> | number | null
    tempsChantier?: FloatNullableFilter<"BonRegie"> | number | null
    nombreTechniciens?: IntNullableFilter<"BonRegie"> | number | null
    materiaux?: StringFilter<"BonRegie"> | string
    nomSignataire?: StringFilter<"BonRegie"> | string
    signature?: StringFilter<"BonRegie"> | string
    dateSignature?: DateTimeFilter<"BonRegie"> | Date | string
    createdAt?: DateTimeFilter<"BonRegie"> | Date | string
    updatedAt?: DateTimeFilter<"BonRegie"> | Date | string
    chantierId?: StringNullableFilter<"BonRegie"> | string | null
    chantier?: XOR<ChantierNullableScalarRelationFilter, ChantierWhereInput> | null
  }, "id">

  export type BonRegieOrderByWithAggregationInput = {
    id?: SortOrder
    dates?: SortOrder
    client?: SortOrder
    nomChantier?: SortOrder
    description?: SortOrder
    tempsPreparation?: SortOrderInput | SortOrder
    tempsTrajets?: SortOrderInput | SortOrder
    tempsChantier?: SortOrderInput | SortOrder
    nombreTechniciens?: SortOrderInput | SortOrder
    materiaux?: SortOrder
    nomSignataire?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chantierId?: SortOrderInput | SortOrder
    _count?: BonRegieCountOrderByAggregateInput
    _avg?: BonRegieAvgOrderByAggregateInput
    _max?: BonRegieMaxOrderByAggregateInput
    _min?: BonRegieMinOrderByAggregateInput
    _sum?: BonRegieSumOrderByAggregateInput
  }

  export type BonRegieScalarWhereWithAggregatesInput = {
    AND?: BonRegieScalarWhereWithAggregatesInput | BonRegieScalarWhereWithAggregatesInput[]
    OR?: BonRegieScalarWhereWithAggregatesInput[]
    NOT?: BonRegieScalarWhereWithAggregatesInput | BonRegieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BonRegie"> | number
    dates?: StringWithAggregatesFilter<"BonRegie"> | string
    client?: StringWithAggregatesFilter<"BonRegie"> | string
    nomChantier?: StringWithAggregatesFilter<"BonRegie"> | string
    description?: StringWithAggregatesFilter<"BonRegie"> | string
    tempsPreparation?: FloatNullableWithAggregatesFilter<"BonRegie"> | number | null
    tempsTrajets?: FloatNullableWithAggregatesFilter<"BonRegie"> | number | null
    tempsChantier?: FloatNullableWithAggregatesFilter<"BonRegie"> | number | null
    nombreTechniciens?: IntNullableWithAggregatesFilter<"BonRegie"> | number | null
    materiaux?: StringWithAggregatesFilter<"BonRegie"> | string
    nomSignataire?: StringWithAggregatesFilter<"BonRegie"> | string
    signature?: StringWithAggregatesFilter<"BonRegie"> | string
    dateSignature?: DateTimeWithAggregatesFilter<"BonRegie"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BonRegie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BonRegie"> | Date | string
    chantierId?: StringNullableWithAggregatesFilter<"BonRegie"> | string | null
  }

  export type SettingsCreateInput = {
    id?: number
    logo?: string | null
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    logo?: string | null
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: number
    logo?: string | null
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admintaskCreateInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
    chantier: ChantierCreateNestedOneWithoutAdmintasksInput
    user?: UserCreateNestedOneWithoutAdmintaskInput
  }

  export type admintaskUncheckedCreateInput = {
    id?: number
    chantierId: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
  }

  export type admintaskUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    chantier?: ChantierUpdateOneRequiredWithoutAdmintasksNestedInput
    user?: UserUpdateOneWithoutAdmintaskNestedInput
  }

  export type admintaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admintaskCreateManyInput = {
    id?: number
    chantierId: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
  }

  export type admintaskUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admintaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pretCreateInput = {
    id: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
    machine: MachineCreateNestedOneWithoutPretInput
    user: UserCreateNestedOneWithoutPretInput
  }

  export type pretUncheckedCreateInput = {
    id: string
    machineId: string
    userId: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
  }

  export type pretUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
    machine?: MachineUpdateOneRequiredWithoutPretNestedInput
    user?: UserUpdateOneRequiredWithoutPretNestedInput
  }

  export type pretUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }

  export type pretCreateManyInput = {
    id: string
    machineId: string
    userId: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
  }

  export type pretUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }

  export type pretUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }

  export type soustraitantCreateInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    commandes?: CommandeSousTraitantCreateNestedManyWithoutSoustraitantInput
    contrats?: contratCreateNestedManyWithoutSoustraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantUncheckedCreateInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    commandes?: CommandeSousTraitantUncheckedCreateNestedManyWithoutSoustraitantInput
    contrats?: contratUncheckedCreateNestedManyWithoutSoustraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    commandes?: CommandeSousTraitantUpdateManyWithoutSoustraitantNestedInput
    contrats?: contratUpdateManyWithoutSoustraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutSoustraitantNestedInput
  }

  export type soustraitantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    commandes?: CommandeSousTraitantUncheckedUpdateManyWithoutSoustraitantNestedInput
    contrats?: contratUncheckedUpdateManyWithoutSoustraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitantNestedInput
  }

  export type soustraitantCreateManyInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
  }

  export type soustraitantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type soustraitantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratCreateInput = {
    id?: string
    url: string
    dateGeneration?: Date | string
    dateSignature?: Date | string | null
    estSigne?: boolean
    token?: string | null
    soustraitant: soustraitantCreateNestedOneWithoutContratsInput
  }

  export type contratUncheckedCreateInput = {
    id?: string
    soustraitantId: string
    url: string
    dateGeneration?: Date | string
    dateSignature?: Date | string | null
    estSigne?: boolean
    token?: string | null
  }

  export type contratUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
    soustraitant?: soustraitantUpdateOneRequiredWithoutContratsNestedInput
  }

  export type contratUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    soustraitantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratCreateManyInput = {
    id?: string
    soustraitantId: string
    url: string
    dateGeneration?: Date | string
    dateSignature?: Date | string | null
    estSigne?: boolean
    token?: string | null
  }

  export type contratUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    soustraitantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FicheTechniqueCreateInput = {
    id?: string
    titre: string
    categorie: string
    sousCategorie?: string | null
    fichierUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceCSC?: string | null
  }

  export type FicheTechniqueUncheckedCreateInput = {
    id?: string
    titre: string
    categorie: string
    sousCategorie?: string | null
    fichierUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceCSC?: string | null
  }

  export type FicheTechniqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    sousCategorie?: NullableStringFieldUpdateOperationsInput | string | null
    fichierUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceCSC?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FicheTechniqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    sousCategorie?: NullableStringFieldUpdateOperationsInput | string | null
    fichierUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceCSC?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FicheTechniqueCreateManyInput = {
    id?: string
    titre: string
    categorie: string
    sousCategorie?: string | null
    fichierUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceCSC?: string | null
  }

  export type FicheTechniqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    sousCategorie?: NullableStringFieldUpdateOperationsInput | string | null
    fichierUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceCSC?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FicheTechniqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    sousCategorie?: NullableStringFieldUpdateOperationsInput | string | null
    fichierUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceCSC?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandeCreateInput = {
    chantierId: string
    clientId?: string | null
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    totalOptions?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandeCreateNestedManyWithoutCommandeInput
  }

  export type CommandeUncheckedCreateInput = {
    id?: number
    chantierId: string
    clientId?: string | null
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    totalOptions?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandeUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeUpdateInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    totalOptions?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandeUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    totalOptions?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandeUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeCreateManyInput = {
    id?: number
    chantierId: string
    clientId?: string | null
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    totalOptions?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeUpdateManyMutationInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    totalOptions?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    totalOptions?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeCreateInput = {
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commande: CommandeCreateNestedOneWithoutLignesInput
  }

  export type LigneCommandeUncheckedCreateInput = {
    id?: number
    commandeId: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeUpdateInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commande?: CommandeUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneCommandeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commandeId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeCreateManyInput = {
    id?: number
    commandeId: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeUpdateManyMutationInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commandeId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtatAvancementCreateInput = {
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    avenants?: AvenantEtatAvancementCreateNestedManyWithoutEtatAvancementInput
    lignes?: LigneEtatAvancementCreateNestedManyWithoutEtatAvancementInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutEtat_avancementInput
  }

  export type EtatAvancementUncheckedCreateInput = {
    id?: number
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    avenants?: AvenantEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput
    lignes?: LigneEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutEtat_avancementInput
  }

  export type EtatAvancementUpdateInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantEtatAvancementUpdateManyWithoutEtatAvancementNestedInput
    lignes?: LigneEtatAvancementUpdateManyWithoutEtatAvancementNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutEtat_avancementNestedInput
  }

  export type EtatAvancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput
    lignes?: LigneEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutEtat_avancementNestedInput
  }

  export type EtatAvancementCreateManyInput = {
    id?: number
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type EtatAvancementUpdateManyMutationInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type EtatAvancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type LigneEtatAvancementCreateInput = {
    ligneCommandeId: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
    etatAvancement: EtatAvancementCreateNestedOneWithoutLignesInput
  }

  export type LigneEtatAvancementUncheckedCreateInput = {
    id?: number
    etatAvancementId: number
    ligneCommandeId: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
  }

  export type LigneEtatAvancementUpdateInput = {
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    etatAvancement?: EtatAvancementUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneEtatAvancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
  }

  export type LigneEtatAvancementCreateManyInput = {
    id?: number
    etatAvancementId: number
    ligneCommandeId: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
  }

  export type LigneEtatAvancementUpdateManyMutationInput = {
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
  }

  export type LigneEtatAvancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
  }

  export type AvenantEtatAvancementCreateInput = {
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    etatAvancement: EtatAvancementCreateNestedOneWithoutAvenantsInput
  }

  export type AvenantEtatAvancementUncheckedCreateInput = {
    id?: number
    etatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvenantEtatAvancementUpdateInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etatAvancement?: EtatAvancementUpdateOneRequiredWithoutAvenantsNestedInput
  }

  export type AvenantEtatAvancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantEtatAvancementCreateManyInput = {
    id?: number
    etatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvenantEtatAvancementUpdateManyMutationInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantEtatAvancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companysettingsCreateInput = {
    id?: string
    name: string
    address: string
    zipCode: string
    city: string
    phone: string
    email: string
    tva: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emailFrom?: string | null
    emailFromName?: string | null
    emailHost?: string | null
    emailPassword?: string | null
    emailPort?: string | null
    emailSecure?: boolean | null
    emailUser?: string | null
    iban: string
  }

  export type companysettingsUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    zipCode: string
    city: string
    phone: string
    email: string
    tva: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emailFrom?: string | null
    emailFromName?: string | null
    emailHost?: string | null
    emailPassword?: string | null
    emailPort?: string | null
    emailSecure?: boolean | null
    emailUser?: string | null
    iban: string
  }

  export type companysettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tva?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailFrom?: NullableStringFieldUpdateOperationsInput | string | null
    emailFromName?: NullableStringFieldUpdateOperationsInput | string | null
    emailHost?: NullableStringFieldUpdateOperationsInput | string | null
    emailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    emailPort?: NullableStringFieldUpdateOperationsInput | string | null
    emailSecure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailUser?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: StringFieldUpdateOperationsInput | string
  }

  export type companysettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tva?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailFrom?: NullableStringFieldUpdateOperationsInput | string | null
    emailFromName?: NullableStringFieldUpdateOperationsInput | string | null
    emailHost?: NullableStringFieldUpdateOperationsInput | string | null
    emailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    emailPort?: NullableStringFieldUpdateOperationsInput | string | null
    emailSecure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailUser?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: StringFieldUpdateOperationsInput | string
  }

  export type companysettingsCreateManyInput = {
    id?: string
    name: string
    address: string
    zipCode: string
    city: string
    phone: string
    email: string
    tva: string
    logo?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emailFrom?: string | null
    emailFromName?: string | null
    emailHost?: string | null
    emailPassword?: string | null
    emailPort?: string | null
    emailSecure?: boolean | null
    emailUser?: string | null
    iban: string
  }

  export type companysettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tva?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailFrom?: NullableStringFieldUpdateOperationsInput | string | null
    emailFromName?: NullableStringFieldUpdateOperationsInput | string | null
    emailHost?: NullableStringFieldUpdateOperationsInput | string | null
    emailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    emailPort?: NullableStringFieldUpdateOperationsInput | string | null
    emailSecure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailUser?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: StringFieldUpdateOperationsInput | string
  }

  export type companysettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tva?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailFrom?: NullableStringFieldUpdateOperationsInput | string | null
    emailFromName?: NullableStringFieldUpdateOperationsInput | string | null
    emailHost?: NullableStringFieldUpdateOperationsInput | string | null
    emailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    emailPort?: NullableStringFieldUpdateOperationsInput | string | null
    emailSecure?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailUser?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: StringFieldUpdateOperationsInput | string
  }

  export type CommandeSousTraitantCreateInput = {
    chantierId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soustraitant: soustraitantCreateNestedOneWithoutCommandesInput
    lignes?: LigneCommandeSousTraitantCreateNestedManyWithoutCommandeSousTraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutCommande_soustraitantInput
  }

  export type CommandeSousTraitantUncheckedCreateInput = {
    id?: number
    chantierId: string
    soustraitantId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandeSousTraitantUncheckedCreateNestedManyWithoutCommandeSousTraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutCommande_soustraitantInput
  }

  export type CommandeSousTraitantUpdateInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant?: soustraitantUpdateOneRequiredWithoutCommandesNestedInput
    lignes?: LigneCommandeSousTraitantUpdateManyWithoutCommandeSousTraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutCommande_soustraitantNestedInput
  }

  export type CommandeSousTraitantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    soustraitantId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandeSousTraitantUncheckedUpdateManyWithoutCommandeSousTraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutCommande_soustraitantNestedInput
  }

  export type CommandeSousTraitantCreateManyInput = {
    id?: number
    chantierId: string
    soustraitantId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeSousTraitantUpdateManyMutationInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeSousTraitantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    soustraitantId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeSousTraitantCreateInput = {
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitant: CommandeSousTraitantCreateNestedOneWithoutLignesInput
  }

  export type LigneCommandeSousTraitantUncheckedCreateInput = {
    id?: number
    commandeSousTraitantId: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeSousTraitantUpdateInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitant?: CommandeSousTraitantUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneCommandeSousTraitantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commandeSousTraitantId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeSousTraitantCreateManyInput = {
    id?: number
    commandeSousTraitantId: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeSousTraitantUpdateManyMutationInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeSousTraitantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commandeSousTraitantId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avenant_soustraitant_etat_avancementCreateInput = {
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
    soustraitant_etat_avancement: soustraitant_etat_avancementCreateNestedOneWithoutAvenant_soustraitant_etat_avancementInput
  }

  export type avenant_soustraitant_etat_avancementUncheckedCreateInput = {
    id?: number
    soustraitantEtatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type avenant_soustraitant_etat_avancementUpdateInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateOneRequiredWithoutAvenant_soustraitant_etat_avancementNestedInput
  }

  export type avenant_soustraitant_etat_avancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantEtatAvancementId?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avenant_soustraitant_etat_avancementCreateManyInput = {
    id?: number
    soustraitantEtatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type avenant_soustraitant_etat_avancementUpdateManyMutationInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avenant_soustraitant_etat_avancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantEtatAvancementId?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ligne_soustraitant_etat_avancementCreateInput = {
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
    soustraitant_etat_avancement: soustraitant_etat_avancementCreateNestedOneWithoutLigne_soustraitant_etat_avancementInput
  }

  export type ligne_soustraitant_etat_avancementUncheckedCreateInput = {
    id?: number
    soustraitantEtatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ligne_soustraitant_etat_avancementUpdateInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateOneRequiredWithoutLigne_soustraitant_etat_avancementNestedInput
  }

  export type ligne_soustraitant_etat_avancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantEtatAvancementId?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ligne_soustraitant_etat_avancementCreateManyInput = {
    id?: number
    soustraitantEtatAvancementId: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ligne_soustraitant_etat_avancementUpdateManyMutationInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ligne_soustraitant_etat_avancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantEtatAvancementId?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soustraitant_etat_avancementCreateInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    commande_soustraitant?: CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
    etat_avancement: EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput
    soustraitant: soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    commande_soustraitant?: CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput
    etat_avancement?: EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
    soustraitant?: soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementCreateManyInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
  }

  export type soustraitant_etat_avancementUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
  }

  export type photo_soustraitant_etat_avancementCreateInput = {
    url: string
    description?: string | null
    dateAjout?: Date | string
    soustraitant_etat_avancement: soustraitant_etat_avancementCreateNestedOneWithoutPhotosInput
  }

  export type photo_soustraitant_etat_avancementUncheckedCreateInput = {
    id?: number
    soustraitantEtatAvancementId: number
    url: string
    description?: string | null
    dateAjout?: Date | string
  }

  export type photo_soustraitant_etat_avancementUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type photo_soustraitant_etat_avancementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantEtatAvancementId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photo_soustraitant_etat_avancementCreateManyInput = {
    id?: number
    soustraitantEtatAvancementId: number
    url: string
    description?: string | null
    dateAjout?: Date | string
  }

  export type photo_soustraitant_etat_avancementUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photo_soustraitant_etat_avancementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantEtatAvancementId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepenseCreateInput = {
    id?: string
    chantierId: string
    date?: Date | string
    montant: number
    description: string
    categorie: string
    fournisseur?: string | null
    reference?: string | null
    justificatif?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepenseUncheckedCreateInput = {
    id?: string
    chantierId: string
    date?: Date | string
    montant: number
    description: string
    categorie: string
    fournisseur?: string | null
    reference?: string | null
    justificatif?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    justificatif?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    justificatif?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepenseCreateManyInput = {
    id?: string
    chantierId: string
    date?: Date | string
    montant: number
    description: string
    categorie: string
    fournisseur?: string | null
    reference?: string | null
    justificatif?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    justificatif?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    justificatif?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotesCreateInput = {
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotesUncheckedCreateInput = {
    id?: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotesUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotesCreateManyInput = {
    id?: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotesUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RackCreateInput = {
    id?: string
    nom: string
    position: string
    lignes: number
    colonnes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emplacements?: EmplacementCreateNestedManyWithoutRackInput
  }

  export type RackUncheckedCreateInput = {
    id?: string
    nom: string
    position: string
    lignes: number
    colonnes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emplacements?: EmplacementUncheckedCreateNestedManyWithoutRackInput
  }

  export type RackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    lignes?: IntFieldUpdateOperationsInput | number
    colonnes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emplacements?: EmplacementUpdateManyWithoutRackNestedInput
  }

  export type RackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    lignes?: IntFieldUpdateOperationsInput | number
    colonnes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emplacements?: EmplacementUncheckedUpdateManyWithoutRackNestedInput
  }

  export type RackCreateManyInput = {
    id?: string
    nom: string
    position: string
    lignes: number
    colonnes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    lignes?: IntFieldUpdateOperationsInput | number
    colonnes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    lignes?: IntFieldUpdateOperationsInput | number
    colonnes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmplacementCreateInput = {
    id?: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rack: RackCreateNestedOneWithoutEmplacementsInput
    materiaux?: MateriauCreateNestedManyWithoutEmplacementInput
  }

  export type EmplacementUncheckedCreateInput = {
    id?: string
    rackId: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materiaux?: MateriauUncheckedCreateNestedManyWithoutEmplacementInput
  }

  export type EmplacementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rack?: RackUpdateOneRequiredWithoutEmplacementsNestedInput
    materiaux?: MateriauUpdateManyWithoutEmplacementNestedInput
  }

  export type EmplacementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rackId?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiaux?: MateriauUncheckedUpdateManyWithoutEmplacementNestedInput
  }

  export type EmplacementCreateManyInput = {
    id?: string
    rackId: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmplacementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmplacementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rackId?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauCreateInput = {
    id?: string
    nom: string
    description?: string | null
    quantite?: number
    codeQR?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emplacement?: EmplacementCreateNestedOneWithoutMateriauxInput
  }

  export type MateriauUncheckedCreateInput = {
    id?: string
    nom: string
    description?: string | null
    quantite?: number
    codeQR?: string | null
    emplacementId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriauUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emplacement?: EmplacementUpdateOneWithoutMateriauxNestedInput
  }

  export type MateriauUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    emplacementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauCreateManyInput = {
    id?: string
    nom: string
    description?: string | null
    quantite?: number
    codeQR?: string | null
    emplacementId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriauUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    emplacementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantCreateInput = {
    numero: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutAvenantsInput
    Marche: MarcheCreateNestedOneWithoutAvenantInput
  }

  export type AvenantUncheckedCreateInput = {
    id?: number
    numero: number
    date?: Date | string
    description?: string | null
    chantierId: string
    marcheId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AvenantUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutAvenantsNestedInput
    Marche?: MarcheUpdateOneRequiredWithoutAvenantNestedInput
  }

  export type AvenantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chantierId?: StringFieldUpdateOperationsInput | string
    marcheId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantCreateManyInput = {
    id?: number
    numero: number
    date?: Date | string
    description?: string | null
    chantierId: string
    marcheId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AvenantUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chantierId?: StringFieldUpdateOperationsInput | string
    marcheId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChantierCreateInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierUpdateInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type ChantierCreateManyInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
  }

  export type ChantierUpdateManyMutationInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
  }

  export type ChantierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    id: string
    nom: string
    email?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier?: ChantierCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id: string
    nom: string
    email?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier?: ChantierUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id: string
    nom: string
    email?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    chantier: ChantierCreateNestedOneWithoutDocumentsInput
    User: UserCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    chantierId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    chantier?: ChantierUpdateOneRequiredWithoutDocumentsNestedInput
    User?: UserUpdateOneRequiredWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentCreateManyInput = {
    id?: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    chantierId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentOuvrierCreateInput = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Ouvrier: OuvrierCreateNestedOneWithoutDocumentOuvrierInput
  }

  export type DocumentOuvrierUncheckedCreateInput = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration?: Date | string | null
    ouvrierId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentOuvrierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ouvrier?: OuvrierUpdateOneRequiredWithoutDocumentOuvrierNestedInput
  }

  export type DocumentOuvrierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ouvrierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentOuvrierCreateManyInput = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration?: Date | string | null
    ouvrierId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentOuvrierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentOuvrierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ouvrierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtatCreateInput = {
    numero: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutEtatsInput
    LigneEtat?: LigneEtatCreateNestedManyWithoutEtatInput
  }

  export type EtatUncheckedCreateInput = {
    id?: number
    numero: number
    date: Date | string
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
    LigneEtat?: LigneEtatUncheckedCreateNestedManyWithoutEtatInput
  }

  export type EtatUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutEtatsNestedInput
    LigneEtat?: LigneEtatUpdateManyWithoutEtatNestedInput
  }

  export type EtatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LigneEtat?: LigneEtatUncheckedUpdateManyWithoutEtatNestedInput
  }

  export type EtatCreateManyInput = {
    id?: number
    numero: number
    date: Date | string
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type EtatUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatCreateInput = {
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
    Etat: EtatCreateNestedOneWithoutLigneEtatInput
    LigneMarche: LigneMarcheCreateNestedOneWithoutLigneEtatInput
  }

  export type LigneEtatUncheckedCreateInput = {
    id?: number
    etatId: number
    ligneMarcheId: number
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneEtatUpdateInput = {
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etat?: EtatUpdateOneRequiredWithoutLigneEtatNestedInput
    LigneMarche?: LigneMarcheUpdateOneRequiredWithoutLigneEtatNestedInput
  }

  export type LigneEtatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatId?: IntFieldUpdateOperationsInput | number
    ligneMarcheId?: IntFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatCreateManyInput = {
    id?: number
    etatId: number
    ligneMarcheId: number
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneEtatUpdateManyMutationInput = {
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatId?: IntFieldUpdateOperationsInput | number
    ligneMarcheId?: IntFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneMarcheCreateInput = {
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    LigneEtat?: LigneEtatCreateNestedManyWithoutLigneMarcheInput
    Marche: MarcheCreateNestedOneWithoutLigneMarcheInput
  }

  export type LigneMarcheUncheckedCreateInput = {
    id?: number
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    marcheId: number
    LigneEtat?: LigneEtatUncheckedCreateNestedManyWithoutLigneMarcheInput
  }

  export type LigneMarcheUpdateInput = {
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    LigneEtat?: LigneEtatUpdateManyWithoutLigneMarcheNestedInput
    Marche?: MarcheUpdateOneRequiredWithoutLigneMarcheNestedInput
  }

  export type LigneMarcheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    marcheId?: IntFieldUpdateOperationsInput | number
    LigneEtat?: LigneEtatUncheckedUpdateManyWithoutLigneMarcheNestedInput
  }

  export type LigneMarcheCreateManyInput = {
    id?: number
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    marcheId: number
  }

  export type LigneMarcheUpdateManyMutationInput = {
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
  }

  export type LigneMarcheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    marcheId?: IntFieldUpdateOperationsInput | number
  }

  export type MachineCreateInput = {
    id: string
    nom: string
    modele: string
    numeroSerie?: string | null
    localisation: string
    statut?: $Enums.Machine_statut
    dateAchat?: Date | string | null
    qrCode: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    pret?: pretCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateInput = {
    id: string
    nom: string
    modele: string
    numeroSerie?: string | null
    localisation: string
    statut?: $Enums.Machine_statut
    dateAchat?: Date | string | null
    qrCode: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    pret?: pretUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: StringFieldUpdateOperationsInput | string
    statut?: EnumMachine_statutFieldUpdateOperationsInput | $Enums.Machine_statut
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pret?: pretUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: StringFieldUpdateOperationsInput | string
    statut?: EnumMachine_statutFieldUpdateOperationsInput | $Enums.Machine_statut
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pret?: pretUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineCreateManyInput = {
    id: string
    nom: string
    modele: string
    numeroSerie?: string | null
    localisation: string
    statut?: $Enums.Machine_statut
    dateAchat?: Date | string | null
    qrCode: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MachineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: StringFieldUpdateOperationsInput | string
    statut?: EnumMachine_statutFieldUpdateOperationsInput | $Enums.Machine_statut
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: StringFieldUpdateOperationsInput | string
    statut?: EnumMachine_statutFieldUpdateOperationsInput | $Enums.Machine_statut
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarcheCreateInput = {
    dateImport?: Date | string
    montantTotal: number
    Avenant?: AvenantCreateNestedManyWithoutMarcheInput
    LigneMarche?: LigneMarcheCreateNestedManyWithoutMarcheInput
    Chantier: ChantierCreateNestedOneWithoutMarchesInput
  }

  export type MarcheUncheckedCreateInput = {
    id?: number
    chantierId: string
    dateImport?: Date | string
    montantTotal: number
    Avenant?: AvenantUncheckedCreateNestedManyWithoutMarcheInput
    LigneMarche?: LigneMarcheUncheckedCreateNestedManyWithoutMarcheInput
  }

  export type MarcheUpdateInput = {
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    Avenant?: AvenantUpdateManyWithoutMarcheNestedInput
    LigneMarche?: LigneMarcheUpdateManyWithoutMarcheNestedInput
    Chantier?: ChantierUpdateOneRequiredWithoutMarchesNestedInput
  }

  export type MarcheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    Avenant?: AvenantUncheckedUpdateManyWithoutMarcheNestedInput
    LigneMarche?: LigneMarcheUncheckedUpdateManyWithoutMarcheNestedInput
  }

  export type MarcheCreateManyInput = {
    id?: number
    chantierId: string
    dateImport?: Date | string
    montantTotal: number
  }

  export type MarcheUpdateManyMutationInput = {
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
  }

  export type MarcheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
  }

  export type NoteCreateInput = {
    contenu: string
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutNotesInput
    User: UserCreateNestedOneWithoutNoteInput
  }

  export type NoteUncheckedCreateInput = {
    id?: number
    chantierId: string
    contenu: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NoteUpdateInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutNotesNestedInput
    User?: UserUpdateOneRequiredWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyInput = {
    id?: number
    chantierId: string
    contenu: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OuvrierCreateInput = {
    id: string
    nom: string
    prenom: string
    email?: string | null
    telephone?: string | null
    dateEntree: Date | string
    poste: string
    sousTraitantId: string
    createdAt?: Date | string
    updatedAt: Date | string
    DocumentOuvrier?: DocumentOuvrierCreateNestedManyWithoutOuvrierInput
  }

  export type OuvrierUncheckedCreateInput = {
    id: string
    nom: string
    prenom: string
    email?: string | null
    telephone?: string | null
    dateEntree: Date | string
    poste: string
    sousTraitantId: string
    createdAt?: Date | string
    updatedAt: Date | string
    DocumentOuvrier?: DocumentOuvrierUncheckedCreateNestedManyWithoutOuvrierInput
  }

  export type OuvrierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    poste?: StringFieldUpdateOperationsInput | string
    sousTraitantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentOuvrier?: DocumentOuvrierUpdateManyWithoutOuvrierNestedInput
  }

  export type OuvrierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    poste?: StringFieldUpdateOperationsInput | string
    sousTraitantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentOuvrier?: DocumentOuvrierUncheckedUpdateManyWithoutOuvrierNestedInput
  }

  export type OuvrierCreateManyInput = {
    id: string
    nom: string
    prenom: string
    email?: string | null
    telephone?: string | null
    dateEntree: Date | string
    poste: string
    sousTraitantId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type OuvrierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    poste?: StringFieldUpdateOperationsInput | string
    sousTraitantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OuvrierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    poste?: StringFieldUpdateOperationsInput | string
    sousTraitantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacheCreateInput = {
    id: string
    label: string
    completed?: boolean
    completedAt?: Date | string | null
    category: string
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutTachesInput
  }

  export type TacheUncheckedCreateInput = {
    id: string
    label: string
    completed?: boolean
    completedAt?: Date | string | null
    chantierId: string
    category: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutTachesNestedInput
  }

  export type TacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chantierId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacheCreateManyInput = {
    id: string
    label: string
    completed?: boolean
    completedAt?: Date | string | null
    chantierId: string
    category: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chantierId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
    admintask?: admintaskCreateNestedManyWithoutUserInput
    pret?: pretCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
    admintask?: admintaskUncheckedCreateNestedManyWithoutUserInput
    pret?: pretUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
    admintask?: admintaskUpdateManyWithoutUserNestedInput
    pret?: pretUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
    admintask?: admintaskUncheckedUpdateManyWithoutUserNestedInput
    pret?: pretUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BonRegieCreateInput = {
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation?: number | null
    tempsTrajets?: number | null
    tempsChantier?: number | null
    nombreTechniciens?: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chantier?: ChantierCreateNestedOneWithoutBonsRegieInput
  }

  export type BonRegieUncheckedCreateInput = {
    id?: number
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation?: number | null
    tempsTrajets?: number | null
    tempsChantier?: number | null
    nombreTechniciens?: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chantierId?: string | null
  }

  export type BonRegieUpdateInput = {
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chantier?: ChantierUpdateOneWithoutBonsRegieNestedInput
  }

  export type BonRegieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chantierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BonRegieCreateManyInput = {
    id?: number
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation?: number | null
    tempsTrajets?: number | null
    tempsChantier?: number | null
    nombreTechniciens?: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chantierId?: string | null
  }

  export type BonRegieUpdateManyMutationInput = {
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonRegieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chantierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SettingsOrderByRelevanceInput = {
    fields: SettingsOrderByRelevanceFieldEnum | SettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChantierScalarRelationFilter = {
    is?: ChantierWhereInput
    isNot?: ChantierWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type admintaskOrderByRelevanceInput = {
    fields: admintaskOrderByRelevanceFieldEnum | admintaskOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type admintaskChantierIdTaskTypeCompoundUniqueInput = {
    chantierId: string
    taskType: string
  }

  export type admintaskCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    completedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
  }

  export type admintaskAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type admintaskMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    completedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
  }

  export type admintaskMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    completedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    taskType?: SortOrder
    title?: SortOrder
  }

  export type admintaskSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumpret_statutFilter<$PrismaModel = never> = {
    equals?: $Enums.pret_statut | Enumpret_statutFieldRefInput<$PrismaModel>
    in?: $Enums.pret_statut[]
    notIn?: $Enums.pret_statut[]
    not?: NestedEnumpret_statutFilter<$PrismaModel> | $Enums.pret_statut
  }

  export type MachineScalarRelationFilter = {
    is?: MachineWhereInput
    isNot?: MachineWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type pretOrderByRelevanceInput = {
    fields: pretOrderByRelevanceFieldEnum | pretOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pretCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
    datePret?: SortOrder
    dateRetourPrevue?: SortOrder
    dateRetourEffective?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprunteur?: SortOrder
  }

  export type pretMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
    datePret?: SortOrder
    dateRetourPrevue?: SortOrder
    dateRetourEffective?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprunteur?: SortOrder
  }

  export type pretMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
    datePret?: SortOrder
    dateRetourPrevue?: SortOrder
    dateRetourEffective?: SortOrder
    statut?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprunteur?: SortOrder
  }

  export type Enumpret_statutWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pret_statut | Enumpret_statutFieldRefInput<$PrismaModel>
    in?: $Enums.pret_statut[]
    notIn?: $Enums.pret_statut[]
    not?: NestedEnumpret_statutWithAggregatesFilter<$PrismaModel> | $Enums.pret_statut
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpret_statutFilter<$PrismaModel>
    _max?: NestedEnumpret_statutFilter<$PrismaModel>
  }

  export type CommandeSousTraitantListRelationFilter = {
    every?: CommandeSousTraitantWhereInput
    some?: CommandeSousTraitantWhereInput
    none?: CommandeSousTraitantWhereInput
  }

  export type ContratListRelationFilter = {
    every?: contratWhereInput
    some?: contratWhereInput
    none?: contratWhereInput
  }

  export type Soustraitant_etat_avancementListRelationFilter = {
    every?: soustraitant_etat_avancementWhereInput
    some?: soustraitant_etat_avancementWhereInput
    none?: soustraitant_etat_avancementWhereInput
  }

  export type CommandeSousTraitantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contratOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type soustraitant_etat_avancementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type soustraitantOrderByRelevanceInput = {
    fields: soustraitantOrderByRelevanceFieldEnum | soustraitantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type soustraitantCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tva?: SortOrder
  }

  export type soustraitantMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tva?: SortOrder
  }

  export type soustraitantMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tva?: SortOrder
  }

  export type SoustraitantScalarRelationFilter = {
    is?: soustraitantWhereInput
    isNot?: soustraitantWhereInput
  }

  export type contratOrderByRelevanceInput = {
    fields: contratOrderByRelevanceFieldEnum | contratOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contratCountOrderByAggregateInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    url?: SortOrder
    dateGeneration?: SortOrder
    dateSignature?: SortOrder
    estSigne?: SortOrder
    token?: SortOrder
  }

  export type contratMaxOrderByAggregateInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    url?: SortOrder
    dateGeneration?: SortOrder
    dateSignature?: SortOrder
    estSigne?: SortOrder
    token?: SortOrder
  }

  export type contratMinOrderByAggregateInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    url?: SortOrder
    dateGeneration?: SortOrder
    dateSignature?: SortOrder
    estSigne?: SortOrder
    token?: SortOrder
  }

  export type FicheTechniqueOrderByRelevanceInput = {
    fields: FicheTechniqueOrderByRelevanceFieldEnum | FicheTechniqueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FicheTechniqueCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    categorie?: SortOrder
    sousCategorie?: SortOrder
    fichierUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceCSC?: SortOrder
  }

  export type FicheTechniqueMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    categorie?: SortOrder
    sousCategorie?: SortOrder
    fichierUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceCSC?: SortOrder
  }

  export type FicheTechniqueMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    categorie?: SortOrder
    sousCategorie?: SortOrder
    fichierUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceCSC?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LigneCommandeListRelationFilter = {
    every?: LigneCommandeWhereInput
    some?: LigneCommandeWhereInput
    none?: LigneCommandeWhereInput
  }

  export type LigneCommandeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandeOrderByRelevanceInput = {
    fields: CommandeOrderByRelevanceFieldEnum | CommandeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommandeCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    clientId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeAvgOrderByAggregateInput = {
    id?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
  }

  export type CommandeMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    clientId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    clientId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeSumOrderByAggregateInput = {
    id?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    totalOptions?: SortOrder
    tva?: SortOrder
    total?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CommandeScalarRelationFilter = {
    is?: CommandeWhereInput
    isNot?: CommandeWhereInput
  }

  export type LigneCommandeOrderByRelevanceInput = {
    fields: LigneCommandeOrderByRelevanceFieldEnum | LigneCommandeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LigneCommandeCountOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    estOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCommandeAvgOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
  }

  export type LigneCommandeMaxOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    estOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCommandeMinOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    estOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCommandeSumOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    ordre?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
  }

  export type AvenantEtatAvancementListRelationFilter = {
    every?: AvenantEtatAvancementWhereInput
    some?: AvenantEtatAvancementWhereInput
    none?: AvenantEtatAvancementWhereInput
  }

  export type LigneEtatAvancementListRelationFilter = {
    every?: LigneEtatAvancementWhereInput
    some?: LigneEtatAvancementWhereInput
    none?: LigneEtatAvancementWhereInput
  }

  export type AvenantEtatAvancementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LigneEtatAvancementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtatAvancementOrderByRelevanceInput = {
    fields: EtatAvancementOrderByRelevanceFieldEnum | EtatAvancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EtatAvancementChantierIdNumeroCompoundUniqueInput = {
    chantierId: string
    numero: number
  }

  export type EtatAvancementCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EtatAvancementAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type EtatAvancementMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EtatAvancementMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EtatAvancementSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type EtatAvancementScalarRelationFilter = {
    is?: EtatAvancementWhereInput
    isNot?: EtatAvancementWhereInput
  }

  export type LigneEtatAvancementOrderByRelevanceInput = {
    fields: LigneEtatAvancementOrderByRelevanceFieldEnum | LigneEtatAvancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LigneEtatAvancementCountOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    description?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    type?: SortOrder
    unite?: SortOrder
  }

  export type LigneEtatAvancementAvgOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
  }

  export type LigneEtatAvancementMaxOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    description?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    type?: SortOrder
    unite?: SortOrder
  }

  export type LigneEtatAvancementMinOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    description?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    type?: SortOrder
    unite?: SortOrder
  }

  export type LigneEtatAvancementSumOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    ligneCommandeId?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
  }

  export type AvenantEtatAvancementOrderByRelevanceInput = {
    fields: AvenantEtatAvancementOrderByRelevanceFieldEnum | AvenantEtatAvancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AvenantEtatAvancementCountOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvenantEtatAvancementAvgOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
  }

  export type AvenantEtatAvancementMaxOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvenantEtatAvancementMinOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvenantEtatAvancementSumOrderByAggregateInput = {
    id?: SortOrder
    etatAvancementId?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type companysettingsOrderByRelevanceInput = {
    fields: companysettingsOrderByRelevanceFieldEnum | companysettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type companysettingsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    tva?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailFrom?: SortOrder
    emailFromName?: SortOrder
    emailHost?: SortOrder
    emailPassword?: SortOrder
    emailPort?: SortOrder
    emailSecure?: SortOrder
    emailUser?: SortOrder
    iban?: SortOrder
  }

  export type companysettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    tva?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailFrom?: SortOrder
    emailFromName?: SortOrder
    emailHost?: SortOrder
    emailPassword?: SortOrder
    emailPort?: SortOrder
    emailSecure?: SortOrder
    emailUser?: SortOrder
    iban?: SortOrder
  }

  export type companysettingsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    tva?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailFrom?: SortOrder
    emailFromName?: SortOrder
    emailHost?: SortOrder
    emailPassword?: SortOrder
    emailPort?: SortOrder
    emailSecure?: SortOrder
    emailUser?: SortOrder
    iban?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type LigneCommandeSousTraitantListRelationFilter = {
    every?: LigneCommandeSousTraitantWhereInput
    some?: LigneCommandeSousTraitantWhereInput
    none?: LigneCommandeSousTraitantWhereInput
  }

  export type LigneCommandeSousTraitantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandeSousTraitantOrderByRelevanceInput = {
    fields: CommandeSousTraitantOrderByRelevanceFieldEnum | CommandeSousTraitantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommandeSousTraitantCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    soustraitantId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeSousTraitantAvgOrderByAggregateInput = {
    id?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
  }

  export type CommandeSousTraitantMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    soustraitantId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeSousTraitantMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    soustraitantId?: SortOrder
    dateCommande?: SortOrder
    reference?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
    statut?: SortOrder
    estVerrouillee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeSousTraitantSumOrderByAggregateInput = {
    id?: SortOrder
    tauxTVA?: SortOrder
    sousTotal?: SortOrder
    tva?: SortOrder
    total?: SortOrder
  }

  export type CommandeSousTraitantScalarRelationFilter = {
    is?: CommandeSousTraitantWhereInput
    isNot?: CommandeSousTraitantWhereInput
  }

  export type LigneCommandeSousTraitantOrderByRelevanceInput = {
    fields: LigneCommandeSousTraitantOrderByRelevanceFieldEnum | LigneCommandeSousTraitantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LigneCommandeSousTraitantCountOrderByAggregateInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCommandeSousTraitantAvgOrderByAggregateInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
  }

  export type LigneCommandeSousTraitantMaxOrderByAggregateInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCommandeSousTraitantMinOrderByAggregateInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneCommandeSousTraitantSumOrderByAggregateInput = {
    id?: SortOrder
    commandeSousTraitantId?: SortOrder
    ordre?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    total?: SortOrder
  }

  export type Soustraitant_etat_avancementScalarRelationFilter = {
    is?: soustraitant_etat_avancementWhereInput
    isNot?: soustraitant_etat_avancementWhereInput
  }

  export type avenant_soustraitant_etat_avancementOrderByRelevanceInput = {
    fields: avenant_soustraitant_etat_avancementOrderByRelevanceFieldEnum | avenant_soustraitant_etat_avancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type avenant_soustraitant_etat_avancementCountOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avenant_soustraitant_etat_avancementAvgOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
  }

  export type avenant_soustraitant_etat_avancementMaxOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avenant_soustraitant_etat_avancementMinOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type avenant_soustraitant_etat_avancementSumOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
  }

  export type ligne_soustraitant_etat_avancementOrderByRelevanceInput = {
    fields: ligne_soustraitant_etat_avancementOrderByRelevanceFieldEnum | ligne_soustraitant_etat_avancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ligne_soustraitant_etat_avancementCountOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ligne_soustraitant_etat_avancementAvgOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
  }

  export type ligne_soustraitant_etat_avancementMaxOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ligne_soustraitant_etat_avancementMinOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    article?: SortOrder
    description?: SortOrder
    type?: SortOrder
    unite?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ligne_soustraitant_etat_avancementSumOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    prixUnitaire?: SortOrder
    quantite?: SortOrder
    quantitePrecedente?: SortOrder
    quantiteActuelle?: SortOrder
    quantiteTotale?: SortOrder
    montantPrecedent?: SortOrder
    montantActuel?: SortOrder
    montantTotal?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Avenant_soustraitant_etat_avancementListRelationFilter = {
    every?: avenant_soustraitant_etat_avancementWhereInput
    some?: avenant_soustraitant_etat_avancementWhereInput
    none?: avenant_soustraitant_etat_avancementWhereInput
  }

  export type Ligne_soustraitant_etat_avancementListRelationFilter = {
    every?: ligne_soustraitant_etat_avancementWhereInput
    some?: ligne_soustraitant_etat_avancementWhereInput
    none?: ligne_soustraitant_etat_avancementWhereInput
  }

  export type Photo_soustraitant_etat_avancementListRelationFilter = {
    every?: photo_soustraitant_etat_avancementWhereInput
    some?: photo_soustraitant_etat_avancementWhereInput
    none?: photo_soustraitant_etat_avancementWhereInput
  }

  export type CommandeSousTraitantNullableScalarRelationFilter = {
    is?: CommandeSousTraitantWhereInput | null
    isNot?: CommandeSousTraitantWhereInput | null
  }

  export type avenant_soustraitant_etat_avancementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ligne_soustraitant_etat_avancementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type photo_soustraitant_etat_avancementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type soustraitant_etat_avancementOrderByRelevanceInput = {
    fields: soustraitant_etat_avancementOrderByRelevanceFieldEnum | soustraitant_etat_avancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type soustraitant_etat_avancementEtatAvancementIdSoustraitantIdNumeroCompoundUniqueInput = {
    etatAvancementId: number
    soustraitantId: string
    numero: number
  }

  export type soustraitant_etat_avancementCountOrderByAggregateInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandeSousTraitantId?: SortOrder
    etatAvancementId?: SortOrder
  }

  export type soustraitant_etat_avancementAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    commandeSousTraitantId?: SortOrder
    etatAvancementId?: SortOrder
  }

  export type soustraitant_etat_avancementMaxOrderByAggregateInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandeSousTraitantId?: SortOrder
    etatAvancementId?: SortOrder
  }

  export type soustraitant_etat_avancementMinOrderByAggregateInput = {
    id?: SortOrder
    soustraitantId?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    commentaires?: SortOrder
    estFinalise?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandeSousTraitantId?: SortOrder
    etatAvancementId?: SortOrder
  }

  export type soustraitant_etat_avancementSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    commandeSousTraitantId?: SortOrder
    etatAvancementId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type photo_soustraitant_etat_avancementOrderByRelevanceInput = {
    fields: photo_soustraitant_etat_avancementOrderByRelevanceFieldEnum | photo_soustraitant_etat_avancementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type photo_soustraitant_etat_avancementCountOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    dateAjout?: SortOrder
  }

  export type photo_soustraitant_etat_avancementAvgOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
  }

  export type photo_soustraitant_etat_avancementMaxOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    dateAjout?: SortOrder
  }

  export type photo_soustraitant_etat_avancementMinOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    dateAjout?: SortOrder
  }

  export type photo_soustraitant_etat_avancementSumOrderByAggregateInput = {
    id?: SortOrder
    soustraitantEtatAvancementId?: SortOrder
  }

  export type DepenseOrderByRelevanceInput = {
    fields: DepenseOrderByRelevanceFieldEnum | DepenseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DepenseCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    date?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    fournisseur?: SortOrder
    reference?: SortOrder
    justificatif?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepenseAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type DepenseMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    date?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    fournisseur?: SortOrder
    reference?: SortOrder
    justificatif?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepenseMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    date?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    fournisseur?: SortOrder
    reference?: SortOrder
    justificatif?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepenseSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type UserNotesOrderByRelevanceInput = {
    fields: UserNotesOrderByRelevanceFieldEnum | UserNotesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserNotesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNotesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmplacementListRelationFilter = {
    every?: EmplacementWhereInput
    some?: EmplacementWhereInput
    none?: EmplacementWhereInput
  }

  export type EmplacementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RackOrderByRelevanceInput = {
    fields: RackOrderByRelevanceFieldEnum | RackOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RackCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    position?: SortOrder
    lignes?: SortOrder
    colonnes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RackAvgOrderByAggregateInput = {
    lignes?: SortOrder
    colonnes?: SortOrder
  }

  export type RackMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    position?: SortOrder
    lignes?: SortOrder
    colonnes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RackMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    position?: SortOrder
    lignes?: SortOrder
    colonnes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RackSumOrderByAggregateInput = {
    lignes?: SortOrder
    colonnes?: SortOrder
  }

  export type RackScalarRelationFilter = {
    is?: RackWhereInput
    isNot?: RackWhereInput
  }

  export type MateriauListRelationFilter = {
    every?: MateriauWhereInput
    some?: MateriauWhereInput
    none?: MateriauWhereInput
  }

  export type MateriauOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmplacementOrderByRelevanceInput = {
    fields: EmplacementOrderByRelevanceFieldEnum | EmplacementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmplacementRackIdLigneColonneCompoundUniqueInput = {
    rackId: string
    ligne: number
    colonne: number
  }

  export type EmplacementCountOrderByAggregateInput = {
    id?: SortOrder
    rackId?: SortOrder
    ligne?: SortOrder
    colonne?: SortOrder
    codeQR?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmplacementAvgOrderByAggregateInput = {
    ligne?: SortOrder
    colonne?: SortOrder
  }

  export type EmplacementMaxOrderByAggregateInput = {
    id?: SortOrder
    rackId?: SortOrder
    ligne?: SortOrder
    colonne?: SortOrder
    codeQR?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmplacementMinOrderByAggregateInput = {
    id?: SortOrder
    rackId?: SortOrder
    ligne?: SortOrder
    colonne?: SortOrder
    codeQR?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmplacementSumOrderByAggregateInput = {
    ligne?: SortOrder
    colonne?: SortOrder
  }

  export type EmplacementNullableScalarRelationFilter = {
    is?: EmplacementWhereInput | null
    isNot?: EmplacementWhereInput | null
  }

  export type MateriauOrderByRelevanceInput = {
    fields: MateriauOrderByRelevanceFieldEnum | MateriauOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MateriauCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    codeQR?: SortOrder
    emplacementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MateriauAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type MateriauMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    codeQR?: SortOrder
    emplacementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MateriauMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    codeQR?: SortOrder
    emplacementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MateriauSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type MarcheScalarRelationFilter = {
    is?: MarcheWhereInput
    isNot?: MarcheWhereInput
  }

  export type AvenantOrderByRelevanceInput = {
    fields: AvenantOrderByRelevanceFieldEnum | AvenantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AvenantChantierIdNumeroCompoundUniqueInput = {
    chantierId: string
    numero: number
  }

  export type AvenantCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    description?: SortOrder
    chantierId?: SortOrder
    marcheId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvenantAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    marcheId?: SortOrder
  }

  export type AvenantMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    description?: SortOrder
    chantierId?: SortOrder
    marcheId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvenantMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    description?: SortOrder
    chantierId?: SortOrder
    marcheId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvenantSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    marcheId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AvenantListRelationFilter = {
    every?: AvenantWhereInput
    some?: AvenantWhereInput
    none?: AvenantWhereInput
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type EtatListRelationFilter = {
    every?: EtatWhereInput
    some?: EtatWhereInput
    none?: EtatWhereInput
  }

  export type MarcheNullableScalarRelationFilter = {
    is?: MarcheWhereInput | null
    isNot?: MarcheWhereInput | null
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type TacheListRelationFilter = {
    every?: TacheWhereInput
    some?: TacheWhereInput
    none?: TacheWhereInput
  }

  export type AdmintaskListRelationFilter = {
    every?: admintaskWhereInput
    some?: admintaskWhereInput
    none?: admintaskWhereInput
  }

  export type BonRegieListRelationFilter = {
    every?: BonRegieWhereInput
    some?: BonRegieWhereInput
    none?: BonRegieWhereInput
  }

  export type AvenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TacheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type admintaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BonRegieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChantierOrderByRelevanceInput = {
    fields: ChantierOrderByRelevanceFieldEnum | ChantierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChantierCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    nomChantier?: SortOrder
    adresseChantier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    budget?: SortOrder
    dateDebut?: SortOrder
    dateFinPrevue?: SortOrder
    dateFinReelle?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    villeChantier?: SortOrder
    dureeEnJours?: SortOrder
    typeDuree?: SortOrder
  }

  export type ChantierAvgOrderByAggregateInput = {
    id?: SortOrder
    budget?: SortOrder
    dureeEnJours?: SortOrder
  }

  export type ChantierMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    nomChantier?: SortOrder
    adresseChantier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    budget?: SortOrder
    dateDebut?: SortOrder
    dateFinPrevue?: SortOrder
    dateFinReelle?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    villeChantier?: SortOrder
    dureeEnJours?: SortOrder
    typeDuree?: SortOrder
  }

  export type ChantierMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    nomChantier?: SortOrder
    adresseChantier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    budget?: SortOrder
    dateDebut?: SortOrder
    dateFinPrevue?: SortOrder
    dateFinReelle?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    villeChantier?: SortOrder
    dureeEnJours?: SortOrder
    typeDuree?: SortOrder
  }

  export type ChantierSumOrderByAggregateInput = {
    id?: SortOrder
    budget?: SortOrder
    dureeEnJours?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ChantierListRelationFilter = {
    every?: ChantierWhereInput
    some?: ChantierWhereInput
    none?: ChantierWhereInput
  }

  export type ChantierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    taille?: SortOrder
    mimeType?: SortOrder
    chantierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    taille?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    taille?: SortOrder
    mimeType?: SortOrder
    chantierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    taille?: SortOrder
    mimeType?: SortOrder
    chantierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    taille?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type OuvrierScalarRelationFilter = {
    is?: OuvrierWhereInput
    isNot?: OuvrierWhereInput
  }

  export type DocumentOuvrierOrderByRelevanceInput = {
    fields: DocumentOuvrierOrderByRelevanceFieldEnum | DocumentOuvrierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentOuvrierCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    dateExpiration?: SortOrder
    ouvrierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentOuvrierMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    dateExpiration?: SortOrder
    ouvrierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentOuvrierMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    url?: SortOrder
    dateExpiration?: SortOrder
    ouvrierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneEtatListRelationFilter = {
    every?: LigneEtatWhereInput
    some?: LigneEtatWhereInput
    none?: LigneEtatWhereInput
  }

  export type LigneEtatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtatOrderByRelevanceInput = {
    fields: EtatOrderByRelevanceFieldEnum | EtatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EtatChantierIdNumeroCompoundUniqueInput = {
    chantierId: string
    numero: number
  }

  export type EtatCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    chantierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EtatAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type EtatMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    chantierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EtatMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    date?: SortOrder
    chantierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EtatSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type EtatScalarRelationFilter = {
    is?: EtatWhereInput
    isNot?: EtatWhereInput
  }

  export type LigneMarcheScalarRelationFilter = {
    is?: LigneMarcheWhereInput
    isNot?: LigneMarcheWhereInput
  }

  export type LigneEtatCountOrderByAggregateInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneEtatAvgOrderByAggregateInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
  }

  export type LigneEtatMaxOrderByAggregateInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneEtatMinOrderByAggregateInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneEtatSumOrderByAggregateInput = {
    id?: SortOrder
    etatId?: SortOrder
    ligneMarcheId?: SortOrder
    quantite?: SortOrder
  }

  export type LigneMarcheOrderByRelevanceInput = {
    fields: LigneMarcheOrderByRelevanceFieldEnum | LigneMarcheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LigneMarcheCountOrderByAggregateInput = {
    id?: SortOrder
    article?: SortOrder
    descriptif?: SortOrder
    unite?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
  }

  export type LigneMarcheAvgOrderByAggregateInput = {
    id?: SortOrder
    article?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
  }

  export type LigneMarcheMaxOrderByAggregateInput = {
    id?: SortOrder
    article?: SortOrder
    descriptif?: SortOrder
    unite?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
  }

  export type LigneMarcheMinOrderByAggregateInput = {
    id?: SortOrder
    article?: SortOrder
    descriptif?: SortOrder
    unite?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
  }

  export type LigneMarcheSumOrderByAggregateInput = {
    id?: SortOrder
    article?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    marcheId?: SortOrder
  }

  export type EnumMachine_statutFilter<$PrismaModel = never> = {
    equals?: $Enums.Machine_statut | EnumMachine_statutFieldRefInput<$PrismaModel>
    in?: $Enums.Machine_statut[]
    notIn?: $Enums.Machine_statut[]
    not?: NestedEnumMachine_statutFilter<$PrismaModel> | $Enums.Machine_statut
  }

  export type PretListRelationFilter = {
    every?: pretWhereInput
    some?: pretWhereInput
    none?: pretWhereInput
  }

  export type pretOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineOrderByRelevanceInput = {
    fields: MachineOrderByRelevanceFieldEnum | MachineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrder
    localisation?: SortOrder
    statut?: SortOrder
    dateAchat?: SortOrder
    qrCode?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrder
    localisation?: SortOrder
    statut?: SortOrder
    dateAchat?: SortOrder
    qrCode?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrder
    localisation?: SortOrder
    statut?: SortOrder
    dateAchat?: SortOrder
    qrCode?: SortOrder
    commentaire?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMachine_statutWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Machine_statut | EnumMachine_statutFieldRefInput<$PrismaModel>
    in?: $Enums.Machine_statut[]
    notIn?: $Enums.Machine_statut[]
    not?: NestedEnumMachine_statutWithAggregatesFilter<$PrismaModel> | $Enums.Machine_statut
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMachine_statutFilter<$PrismaModel>
    _max?: NestedEnumMachine_statutFilter<$PrismaModel>
  }

  export type LigneMarcheListRelationFilter = {
    every?: LigneMarcheWhereInput
    some?: LigneMarcheWhereInput
    none?: LigneMarcheWhereInput
  }

  export type LigneMarcheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarcheOrderByRelevanceInput = {
    fields: MarcheOrderByRelevanceFieldEnum | MarcheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MarcheCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    dateImport?: SortOrder
    montantTotal?: SortOrder
  }

  export type MarcheAvgOrderByAggregateInput = {
    id?: SortOrder
    montantTotal?: SortOrder
  }

  export type MarcheMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    dateImport?: SortOrder
    montantTotal?: SortOrder
  }

  export type MarcheMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    dateImport?: SortOrder
    montantTotal?: SortOrder
  }

  export type MarcheSumOrderByAggregateInput = {
    id?: SortOrder
    montantTotal?: SortOrder
  }

  export type NoteOrderByRelevanceInput = {
    fields: NoteOrderByRelevanceFieldEnum | NoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    contenu?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    contenu?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    chantierId?: SortOrder
    contenu?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocumentOuvrierListRelationFilter = {
    every?: DocumentOuvrierWhereInput
    some?: DocumentOuvrierWhereInput
    none?: DocumentOuvrierWhereInput
  }

  export type DocumentOuvrierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OuvrierOrderByRelevanceInput = {
    fields: OuvrierOrderByRelevanceFieldEnum | OuvrierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OuvrierCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    dateEntree?: SortOrder
    poste?: SortOrder
    sousTraitantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OuvrierMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    dateEntree?: SortOrder
    poste?: SortOrder
    sousTraitantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OuvrierMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    dateEntree?: SortOrder
    poste?: SortOrder
    sousTraitantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacheOrderByRelevanceInput = {
    fields: TacheOrderByRelevanceFieldEnum | TacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TacheChantierIdIdCompoundUniqueInput = {
    chantierId: string
    id: string
  }

  export type TacheCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    chantierId?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacheMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    chantierId?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacheMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    chantierId?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleFilter<$PrismaModel> | $Enums.User_role
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type EnumUser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleWithAggregatesFilter<$PrismaModel> | $Enums.User_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUser_roleFilter<$PrismaModel>
    _max?: NestedEnumUser_roleFilter<$PrismaModel>
  }

  export type ChantierNullableScalarRelationFilter = {
    is?: ChantierWhereInput | null
    isNot?: ChantierWhereInput | null
  }

  export type BonRegieOrderByRelevanceInput = {
    fields: BonRegieOrderByRelevanceFieldEnum | BonRegieOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BonRegieCountOrderByAggregateInput = {
    id?: SortOrder
    dates?: SortOrder
    client?: SortOrder
    nomChantier?: SortOrder
    description?: SortOrder
    tempsPreparation?: SortOrder
    tempsTrajets?: SortOrder
    tempsChantier?: SortOrder
    nombreTechniciens?: SortOrder
    materiaux?: SortOrder
    nomSignataire?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chantierId?: SortOrder
  }

  export type BonRegieAvgOrderByAggregateInput = {
    id?: SortOrder
    tempsPreparation?: SortOrder
    tempsTrajets?: SortOrder
    tempsChantier?: SortOrder
    nombreTechniciens?: SortOrder
  }

  export type BonRegieMaxOrderByAggregateInput = {
    id?: SortOrder
    dates?: SortOrder
    client?: SortOrder
    nomChantier?: SortOrder
    description?: SortOrder
    tempsPreparation?: SortOrder
    tempsTrajets?: SortOrder
    tempsChantier?: SortOrder
    nombreTechniciens?: SortOrder
    materiaux?: SortOrder
    nomSignataire?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chantierId?: SortOrder
  }

  export type BonRegieMinOrderByAggregateInput = {
    id?: SortOrder
    dates?: SortOrder
    client?: SortOrder
    nomChantier?: SortOrder
    description?: SortOrder
    tempsPreparation?: SortOrder
    tempsTrajets?: SortOrder
    tempsChantier?: SortOrder
    nombreTechniciens?: SortOrder
    materiaux?: SortOrder
    nomSignataire?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chantierId?: SortOrder
  }

  export type BonRegieSumOrderByAggregateInput = {
    id?: SortOrder
    tempsPreparation?: SortOrder
    tempsTrajets?: SortOrder
    tempsChantier?: SortOrder
    nombreTechniciens?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ChantierCreateNestedOneWithoutAdmintasksInput = {
    create?: XOR<ChantierCreateWithoutAdmintasksInput, ChantierUncheckedCreateWithoutAdmintasksInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutAdmintasksInput
    connect?: ChantierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdmintaskInput = {
    create?: XOR<UserCreateWithoutAdmintaskInput, UserUncheckedCreateWithoutAdmintaskInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmintaskInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ChantierUpdateOneRequiredWithoutAdmintasksNestedInput = {
    create?: XOR<ChantierCreateWithoutAdmintasksInput, ChantierUncheckedCreateWithoutAdmintasksInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutAdmintasksInput
    upsert?: ChantierUpsertWithoutAdmintasksInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutAdmintasksInput, ChantierUpdateWithoutAdmintasksInput>, ChantierUncheckedUpdateWithoutAdmintasksInput>
  }

  export type UserUpdateOneWithoutAdmintaskNestedInput = {
    create?: XOR<UserCreateWithoutAdmintaskInput, UserUncheckedCreateWithoutAdmintaskInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmintaskInput
    upsert?: UserUpsertWithoutAdmintaskInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmintaskInput, UserUpdateWithoutAdmintaskInput>, UserUncheckedUpdateWithoutAdmintaskInput>
  }

  export type MachineCreateNestedOneWithoutPretInput = {
    create?: XOR<MachineCreateWithoutPretInput, MachineUncheckedCreateWithoutPretInput>
    connectOrCreate?: MachineCreateOrConnectWithoutPretInput
    connect?: MachineWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPretInput = {
    create?: XOR<UserCreateWithoutPretInput, UserUncheckedCreateWithoutPretInput>
    connectOrCreate?: UserCreateOrConnectWithoutPretInput
    connect?: UserWhereUniqueInput
  }

  export type Enumpret_statutFieldUpdateOperationsInput = {
    set?: $Enums.pret_statut
  }

  export type MachineUpdateOneRequiredWithoutPretNestedInput = {
    create?: XOR<MachineCreateWithoutPretInput, MachineUncheckedCreateWithoutPretInput>
    connectOrCreate?: MachineCreateOrConnectWithoutPretInput
    upsert?: MachineUpsertWithoutPretInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutPretInput, MachineUpdateWithoutPretInput>, MachineUncheckedUpdateWithoutPretInput>
  }

  export type UserUpdateOneRequiredWithoutPretNestedInput = {
    create?: XOR<UserCreateWithoutPretInput, UserUncheckedCreateWithoutPretInput>
    connectOrCreate?: UserCreateOrConnectWithoutPretInput
    upsert?: UserUpsertWithoutPretInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPretInput, UserUpdateWithoutPretInput>, UserUncheckedUpdateWithoutPretInput>
  }

  export type CommandeSousTraitantCreateNestedManyWithoutSoustraitantInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutSoustraitantInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput> | CommandeSousTraitantCreateWithoutSoustraitantInput[] | CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput | CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput[]
    createMany?: CommandeSousTraitantCreateManySoustraitantInputEnvelope
    connect?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
  }

  export type contratCreateNestedManyWithoutSoustraitantInput = {
    create?: XOR<contratCreateWithoutSoustraitantInput, contratUncheckedCreateWithoutSoustraitantInput> | contratCreateWithoutSoustraitantInput[] | contratUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: contratCreateOrConnectWithoutSoustraitantInput | contratCreateOrConnectWithoutSoustraitantInput[]
    createMany?: contratCreateManySoustraitantInputEnvelope
    connect?: contratWhereUniqueInput | contratWhereUniqueInput[]
  }

  export type soustraitant_etat_avancementCreateNestedManyWithoutSoustraitantInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput> | soustraitant_etat_avancementCreateWithoutSoustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManySoustraitantInputEnvelope
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type CommandeSousTraitantUncheckedCreateNestedManyWithoutSoustraitantInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutSoustraitantInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput> | CommandeSousTraitantCreateWithoutSoustraitantInput[] | CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput | CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput[]
    createMany?: CommandeSousTraitantCreateManySoustraitantInputEnvelope
    connect?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
  }

  export type contratUncheckedCreateNestedManyWithoutSoustraitantInput = {
    create?: XOR<contratCreateWithoutSoustraitantInput, contratUncheckedCreateWithoutSoustraitantInput> | contratCreateWithoutSoustraitantInput[] | contratUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: contratCreateOrConnectWithoutSoustraitantInput | contratCreateOrConnectWithoutSoustraitantInput[]
    createMany?: contratCreateManySoustraitantInputEnvelope
    connect?: contratWhereUniqueInput | contratWhereUniqueInput[]
  }

  export type soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitantInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput> | soustraitant_etat_avancementCreateWithoutSoustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManySoustraitantInputEnvelope
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type CommandeSousTraitantUpdateManyWithoutSoustraitantNestedInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutSoustraitantInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput> | CommandeSousTraitantCreateWithoutSoustraitantInput[] | CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput | CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput[]
    upsert?: CommandeSousTraitantUpsertWithWhereUniqueWithoutSoustraitantInput | CommandeSousTraitantUpsertWithWhereUniqueWithoutSoustraitantInput[]
    createMany?: CommandeSousTraitantCreateManySoustraitantInputEnvelope
    set?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    disconnect?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    delete?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    connect?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    update?: CommandeSousTraitantUpdateWithWhereUniqueWithoutSoustraitantInput | CommandeSousTraitantUpdateWithWhereUniqueWithoutSoustraitantInput[]
    updateMany?: CommandeSousTraitantUpdateManyWithWhereWithoutSoustraitantInput | CommandeSousTraitantUpdateManyWithWhereWithoutSoustraitantInput[]
    deleteMany?: CommandeSousTraitantScalarWhereInput | CommandeSousTraitantScalarWhereInput[]
  }

  export type contratUpdateManyWithoutSoustraitantNestedInput = {
    create?: XOR<contratCreateWithoutSoustraitantInput, contratUncheckedCreateWithoutSoustraitantInput> | contratCreateWithoutSoustraitantInput[] | contratUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: contratCreateOrConnectWithoutSoustraitantInput | contratCreateOrConnectWithoutSoustraitantInput[]
    upsert?: contratUpsertWithWhereUniqueWithoutSoustraitantInput | contratUpsertWithWhereUniqueWithoutSoustraitantInput[]
    createMany?: contratCreateManySoustraitantInputEnvelope
    set?: contratWhereUniqueInput | contratWhereUniqueInput[]
    disconnect?: contratWhereUniqueInput | contratWhereUniqueInput[]
    delete?: contratWhereUniqueInput | contratWhereUniqueInput[]
    connect?: contratWhereUniqueInput | contratWhereUniqueInput[]
    update?: contratUpdateWithWhereUniqueWithoutSoustraitantInput | contratUpdateWithWhereUniqueWithoutSoustraitantInput[]
    updateMany?: contratUpdateManyWithWhereWithoutSoustraitantInput | contratUpdateManyWithWhereWithoutSoustraitantInput[]
    deleteMany?: contratScalarWhereInput | contratScalarWhereInput[]
  }

  export type soustraitant_etat_avancementUpdateManyWithoutSoustraitantNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput> | soustraitant_etat_avancementCreateWithoutSoustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput[]
    upsert?: soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitantInput | soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManySoustraitantInputEnvelope
    set?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    delete?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    update?: soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitantInput | soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitantInput[]
    updateMany?: soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitantInput | soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitantInput[]
    deleteMany?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
  }

  export type CommandeSousTraitantUncheckedUpdateManyWithoutSoustraitantNestedInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutSoustraitantInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput> | CommandeSousTraitantCreateWithoutSoustraitantInput[] | CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput | CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput[]
    upsert?: CommandeSousTraitantUpsertWithWhereUniqueWithoutSoustraitantInput | CommandeSousTraitantUpsertWithWhereUniqueWithoutSoustraitantInput[]
    createMany?: CommandeSousTraitantCreateManySoustraitantInputEnvelope
    set?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    disconnect?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    delete?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    connect?: CommandeSousTraitantWhereUniqueInput | CommandeSousTraitantWhereUniqueInput[]
    update?: CommandeSousTraitantUpdateWithWhereUniqueWithoutSoustraitantInput | CommandeSousTraitantUpdateWithWhereUniqueWithoutSoustraitantInput[]
    updateMany?: CommandeSousTraitantUpdateManyWithWhereWithoutSoustraitantInput | CommandeSousTraitantUpdateManyWithWhereWithoutSoustraitantInput[]
    deleteMany?: CommandeSousTraitantScalarWhereInput | CommandeSousTraitantScalarWhereInput[]
  }

  export type contratUncheckedUpdateManyWithoutSoustraitantNestedInput = {
    create?: XOR<contratCreateWithoutSoustraitantInput, contratUncheckedCreateWithoutSoustraitantInput> | contratCreateWithoutSoustraitantInput[] | contratUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: contratCreateOrConnectWithoutSoustraitantInput | contratCreateOrConnectWithoutSoustraitantInput[]
    upsert?: contratUpsertWithWhereUniqueWithoutSoustraitantInput | contratUpsertWithWhereUniqueWithoutSoustraitantInput[]
    createMany?: contratCreateManySoustraitantInputEnvelope
    set?: contratWhereUniqueInput | contratWhereUniqueInput[]
    disconnect?: contratWhereUniqueInput | contratWhereUniqueInput[]
    delete?: contratWhereUniqueInput | contratWhereUniqueInput[]
    connect?: contratWhereUniqueInput | contratWhereUniqueInput[]
    update?: contratUpdateWithWhereUniqueWithoutSoustraitantInput | contratUpdateWithWhereUniqueWithoutSoustraitantInput[]
    updateMany?: contratUpdateManyWithWhereWithoutSoustraitantInput | contratUpdateManyWithWhereWithoutSoustraitantInput[]
    deleteMany?: contratScalarWhereInput | contratScalarWhereInput[]
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitantNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput> | soustraitant_etat_avancementCreateWithoutSoustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput[]
    upsert?: soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitantInput | soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManySoustraitantInputEnvelope
    set?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    delete?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    update?: soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitantInput | soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitantInput[]
    updateMany?: soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitantInput | soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitantInput[]
    deleteMany?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
  }

  export type soustraitantCreateNestedOneWithoutContratsInput = {
    create?: XOR<soustraitantCreateWithoutContratsInput, soustraitantUncheckedCreateWithoutContratsInput>
    connectOrCreate?: soustraitantCreateOrConnectWithoutContratsInput
    connect?: soustraitantWhereUniqueInput
  }

  export type soustraitantUpdateOneRequiredWithoutContratsNestedInput = {
    create?: XOR<soustraitantCreateWithoutContratsInput, soustraitantUncheckedCreateWithoutContratsInput>
    connectOrCreate?: soustraitantCreateOrConnectWithoutContratsInput
    upsert?: soustraitantUpsertWithoutContratsInput
    connect?: soustraitantWhereUniqueInput
    update?: XOR<XOR<soustraitantUpdateToOneWithWhereWithoutContratsInput, soustraitantUpdateWithoutContratsInput>, soustraitantUncheckedUpdateWithoutContratsInput>
  }

  export type LigneCommandeCreateNestedManyWithoutCommandeInput = {
    create?: XOR<LigneCommandeCreateWithoutCommandeInput, LigneCommandeUncheckedCreateWithoutCommandeInput> | LigneCommandeCreateWithoutCommandeInput[] | LigneCommandeUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandeCreateOrConnectWithoutCommandeInput | LigneCommandeCreateOrConnectWithoutCommandeInput[]
    createMany?: LigneCommandeCreateManyCommandeInputEnvelope
    connect?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
  }

  export type LigneCommandeUncheckedCreateNestedManyWithoutCommandeInput = {
    create?: XOR<LigneCommandeCreateWithoutCommandeInput, LigneCommandeUncheckedCreateWithoutCommandeInput> | LigneCommandeCreateWithoutCommandeInput[] | LigneCommandeUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandeCreateOrConnectWithoutCommandeInput | LigneCommandeCreateOrConnectWithoutCommandeInput[]
    createMany?: LigneCommandeCreateManyCommandeInputEnvelope
    connect?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LigneCommandeUpdateManyWithoutCommandeNestedInput = {
    create?: XOR<LigneCommandeCreateWithoutCommandeInput, LigneCommandeUncheckedCreateWithoutCommandeInput> | LigneCommandeCreateWithoutCommandeInput[] | LigneCommandeUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandeCreateOrConnectWithoutCommandeInput | LigneCommandeCreateOrConnectWithoutCommandeInput[]
    upsert?: LigneCommandeUpsertWithWhereUniqueWithoutCommandeInput | LigneCommandeUpsertWithWhereUniqueWithoutCommandeInput[]
    createMany?: LigneCommandeCreateManyCommandeInputEnvelope
    set?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    disconnect?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    delete?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    connect?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    update?: LigneCommandeUpdateWithWhereUniqueWithoutCommandeInput | LigneCommandeUpdateWithWhereUniqueWithoutCommandeInput[]
    updateMany?: LigneCommandeUpdateManyWithWhereWithoutCommandeInput | LigneCommandeUpdateManyWithWhereWithoutCommandeInput[]
    deleteMany?: LigneCommandeScalarWhereInput | LigneCommandeScalarWhereInput[]
  }

  export type LigneCommandeUncheckedUpdateManyWithoutCommandeNestedInput = {
    create?: XOR<LigneCommandeCreateWithoutCommandeInput, LigneCommandeUncheckedCreateWithoutCommandeInput> | LigneCommandeCreateWithoutCommandeInput[] | LigneCommandeUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandeCreateOrConnectWithoutCommandeInput | LigneCommandeCreateOrConnectWithoutCommandeInput[]
    upsert?: LigneCommandeUpsertWithWhereUniqueWithoutCommandeInput | LigneCommandeUpsertWithWhereUniqueWithoutCommandeInput[]
    createMany?: LigneCommandeCreateManyCommandeInputEnvelope
    set?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    disconnect?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    delete?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    connect?: LigneCommandeWhereUniqueInput | LigneCommandeWhereUniqueInput[]
    update?: LigneCommandeUpdateWithWhereUniqueWithoutCommandeInput | LigneCommandeUpdateWithWhereUniqueWithoutCommandeInput[]
    updateMany?: LigneCommandeUpdateManyWithWhereWithoutCommandeInput | LigneCommandeUpdateManyWithWhereWithoutCommandeInput[]
    deleteMany?: LigneCommandeScalarWhereInput | LigneCommandeScalarWhereInput[]
  }

  export type CommandeCreateNestedOneWithoutLignesInput = {
    create?: XOR<CommandeCreateWithoutLignesInput, CommandeUncheckedCreateWithoutLignesInput>
    connectOrCreate?: CommandeCreateOrConnectWithoutLignesInput
    connect?: CommandeWhereUniqueInput
  }

  export type CommandeUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<CommandeCreateWithoutLignesInput, CommandeUncheckedCreateWithoutLignesInput>
    connectOrCreate?: CommandeCreateOrConnectWithoutLignesInput
    upsert?: CommandeUpsertWithoutLignesInput
    connect?: CommandeWhereUniqueInput
    update?: XOR<XOR<CommandeUpdateToOneWithWhereWithoutLignesInput, CommandeUpdateWithoutLignesInput>, CommandeUncheckedUpdateWithoutLignesInput>
  }

  export type AvenantEtatAvancementCreateNestedManyWithoutEtatAvancementInput = {
    create?: XOR<AvenantEtatAvancementCreateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | AvenantEtatAvancementCreateWithoutEtatAvancementInput[] | AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput | AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    createMany?: AvenantEtatAvancementCreateManyEtatAvancementInputEnvelope
    connect?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
  }

  export type LigneEtatAvancementCreateNestedManyWithoutEtatAvancementInput = {
    create?: XOR<LigneEtatAvancementCreateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | LigneEtatAvancementCreateWithoutEtatAvancementInput[] | LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput | LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    createMany?: LigneEtatAvancementCreateManyEtatAvancementInputEnvelope
    connect?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
  }

  export type soustraitant_etat_avancementCreateNestedManyWithoutEtat_avancementInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput> | soustraitant_etat_avancementCreateWithoutEtat_avancementInput[] | soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput | soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput[]
    createMany?: soustraitant_etat_avancementCreateManyEtat_avancementInputEnvelope
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type AvenantEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput = {
    create?: XOR<AvenantEtatAvancementCreateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | AvenantEtatAvancementCreateWithoutEtatAvancementInput[] | AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput | AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    createMany?: AvenantEtatAvancementCreateManyEtatAvancementInputEnvelope
    connect?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
  }

  export type LigneEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput = {
    create?: XOR<LigneEtatAvancementCreateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | LigneEtatAvancementCreateWithoutEtatAvancementInput[] | LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput | LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    createMany?: LigneEtatAvancementCreateManyEtatAvancementInputEnvelope
    connect?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
  }

  export type soustraitant_etat_avancementUncheckedCreateNestedManyWithoutEtat_avancementInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput> | soustraitant_etat_avancementCreateWithoutEtat_avancementInput[] | soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput | soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput[]
    createMany?: soustraitant_etat_avancementCreateManyEtat_avancementInputEnvelope
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type AvenantEtatAvancementUpdateManyWithoutEtatAvancementNestedInput = {
    create?: XOR<AvenantEtatAvancementCreateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | AvenantEtatAvancementCreateWithoutEtatAvancementInput[] | AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput | AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    upsert?: AvenantEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput | AvenantEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput[]
    createMany?: AvenantEtatAvancementCreateManyEtatAvancementInputEnvelope
    set?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    disconnect?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    delete?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    connect?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    update?: AvenantEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput | AvenantEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput[]
    updateMany?: AvenantEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput | AvenantEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput[]
    deleteMany?: AvenantEtatAvancementScalarWhereInput | AvenantEtatAvancementScalarWhereInput[]
  }

  export type LigneEtatAvancementUpdateManyWithoutEtatAvancementNestedInput = {
    create?: XOR<LigneEtatAvancementCreateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | LigneEtatAvancementCreateWithoutEtatAvancementInput[] | LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput | LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    upsert?: LigneEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput | LigneEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput[]
    createMany?: LigneEtatAvancementCreateManyEtatAvancementInputEnvelope
    set?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    disconnect?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    delete?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    connect?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    update?: LigneEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput | LigneEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput[]
    updateMany?: LigneEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput | LigneEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput[]
    deleteMany?: LigneEtatAvancementScalarWhereInput | LigneEtatAvancementScalarWhereInput[]
  }

  export type soustraitant_etat_avancementUpdateManyWithoutEtat_avancementNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput> | soustraitant_etat_avancementCreateWithoutEtat_avancementInput[] | soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput | soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput[]
    upsert?: soustraitant_etat_avancementUpsertWithWhereUniqueWithoutEtat_avancementInput | soustraitant_etat_avancementUpsertWithWhereUniqueWithoutEtat_avancementInput[]
    createMany?: soustraitant_etat_avancementCreateManyEtat_avancementInputEnvelope
    set?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    delete?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    update?: soustraitant_etat_avancementUpdateWithWhereUniqueWithoutEtat_avancementInput | soustraitant_etat_avancementUpdateWithWhereUniqueWithoutEtat_avancementInput[]
    updateMany?: soustraitant_etat_avancementUpdateManyWithWhereWithoutEtat_avancementInput | soustraitant_etat_avancementUpdateManyWithWhereWithoutEtat_avancementInput[]
    deleteMany?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
  }

  export type AvenantEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput = {
    create?: XOR<AvenantEtatAvancementCreateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | AvenantEtatAvancementCreateWithoutEtatAvancementInput[] | AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput | AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    upsert?: AvenantEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput | AvenantEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput[]
    createMany?: AvenantEtatAvancementCreateManyEtatAvancementInputEnvelope
    set?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    disconnect?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    delete?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    connect?: AvenantEtatAvancementWhereUniqueInput | AvenantEtatAvancementWhereUniqueInput[]
    update?: AvenantEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput | AvenantEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput[]
    updateMany?: AvenantEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput | AvenantEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput[]
    deleteMany?: AvenantEtatAvancementScalarWhereInput | AvenantEtatAvancementScalarWhereInput[]
  }

  export type LigneEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput = {
    create?: XOR<LigneEtatAvancementCreateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput> | LigneEtatAvancementCreateWithoutEtatAvancementInput[] | LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput[]
    connectOrCreate?: LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput | LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput[]
    upsert?: LigneEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput | LigneEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput[]
    createMany?: LigneEtatAvancementCreateManyEtatAvancementInputEnvelope
    set?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    disconnect?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    delete?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    connect?: LigneEtatAvancementWhereUniqueInput | LigneEtatAvancementWhereUniqueInput[]
    update?: LigneEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput | LigneEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput[]
    updateMany?: LigneEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput | LigneEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput[]
    deleteMany?: LigneEtatAvancementScalarWhereInput | LigneEtatAvancementScalarWhereInput[]
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyWithoutEtat_avancementNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput> | soustraitant_etat_avancementCreateWithoutEtat_avancementInput[] | soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput | soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput[]
    upsert?: soustraitant_etat_avancementUpsertWithWhereUniqueWithoutEtat_avancementInput | soustraitant_etat_avancementUpsertWithWhereUniqueWithoutEtat_avancementInput[]
    createMany?: soustraitant_etat_avancementCreateManyEtat_avancementInputEnvelope
    set?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    delete?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    update?: soustraitant_etat_avancementUpdateWithWhereUniqueWithoutEtat_avancementInput | soustraitant_etat_avancementUpdateWithWhereUniqueWithoutEtat_avancementInput[]
    updateMany?: soustraitant_etat_avancementUpdateManyWithWhereWithoutEtat_avancementInput | soustraitant_etat_avancementUpdateManyWithWhereWithoutEtat_avancementInput[]
    deleteMany?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
  }

  export type EtatAvancementCreateNestedOneWithoutLignesInput = {
    create?: XOR<EtatAvancementCreateWithoutLignesInput, EtatAvancementUncheckedCreateWithoutLignesInput>
    connectOrCreate?: EtatAvancementCreateOrConnectWithoutLignesInput
    connect?: EtatAvancementWhereUniqueInput
  }

  export type EtatAvancementUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<EtatAvancementCreateWithoutLignesInput, EtatAvancementUncheckedCreateWithoutLignesInput>
    connectOrCreate?: EtatAvancementCreateOrConnectWithoutLignesInput
    upsert?: EtatAvancementUpsertWithoutLignesInput
    connect?: EtatAvancementWhereUniqueInput
    update?: XOR<XOR<EtatAvancementUpdateToOneWithWhereWithoutLignesInput, EtatAvancementUpdateWithoutLignesInput>, EtatAvancementUncheckedUpdateWithoutLignesInput>
  }

  export type EtatAvancementCreateNestedOneWithoutAvenantsInput = {
    create?: XOR<EtatAvancementCreateWithoutAvenantsInput, EtatAvancementUncheckedCreateWithoutAvenantsInput>
    connectOrCreate?: EtatAvancementCreateOrConnectWithoutAvenantsInput
    connect?: EtatAvancementWhereUniqueInput
  }

  export type EtatAvancementUpdateOneRequiredWithoutAvenantsNestedInput = {
    create?: XOR<EtatAvancementCreateWithoutAvenantsInput, EtatAvancementUncheckedCreateWithoutAvenantsInput>
    connectOrCreate?: EtatAvancementCreateOrConnectWithoutAvenantsInput
    upsert?: EtatAvancementUpsertWithoutAvenantsInput
    connect?: EtatAvancementWhereUniqueInput
    update?: XOR<XOR<EtatAvancementUpdateToOneWithWhereWithoutAvenantsInput, EtatAvancementUpdateWithoutAvenantsInput>, EtatAvancementUncheckedUpdateWithoutAvenantsInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type soustraitantCreateNestedOneWithoutCommandesInput = {
    create?: XOR<soustraitantCreateWithoutCommandesInput, soustraitantUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: soustraitantCreateOrConnectWithoutCommandesInput
    connect?: soustraitantWhereUniqueInput
  }

  export type LigneCommandeSousTraitantCreateNestedManyWithoutCommandeSousTraitantInput = {
    create?: XOR<LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput> | LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput[] | LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput[]
    connectOrCreate?: LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput[]
    createMany?: LigneCommandeSousTraitantCreateManyCommandeSousTraitantInputEnvelope
    connect?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
  }

  export type soustraitant_etat_avancementCreateNestedManyWithoutCommande_soustraitantInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput> | soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManyCommande_soustraitantInputEnvelope
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type LigneCommandeSousTraitantUncheckedCreateNestedManyWithoutCommandeSousTraitantInput = {
    create?: XOR<LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput> | LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput[] | LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput[]
    connectOrCreate?: LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput[]
    createMany?: LigneCommandeSousTraitantCreateManyCommandeSousTraitantInputEnvelope
    connect?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
  }

  export type soustraitant_etat_avancementUncheckedCreateNestedManyWithoutCommande_soustraitantInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput> | soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManyCommande_soustraitantInputEnvelope
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type soustraitantUpdateOneRequiredWithoutCommandesNestedInput = {
    create?: XOR<soustraitantCreateWithoutCommandesInput, soustraitantUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: soustraitantCreateOrConnectWithoutCommandesInput
    upsert?: soustraitantUpsertWithoutCommandesInput
    connect?: soustraitantWhereUniqueInput
    update?: XOR<XOR<soustraitantUpdateToOneWithWhereWithoutCommandesInput, soustraitantUpdateWithoutCommandesInput>, soustraitantUncheckedUpdateWithoutCommandesInput>
  }

  export type LigneCommandeSousTraitantUpdateManyWithoutCommandeSousTraitantNestedInput = {
    create?: XOR<LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput> | LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput[] | LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput[]
    connectOrCreate?: LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput[]
    upsert?: LigneCommandeSousTraitantUpsertWithWhereUniqueWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantUpsertWithWhereUniqueWithoutCommandeSousTraitantInput[]
    createMany?: LigneCommandeSousTraitantCreateManyCommandeSousTraitantInputEnvelope
    set?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    disconnect?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    delete?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    connect?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    update?: LigneCommandeSousTraitantUpdateWithWhereUniqueWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantUpdateWithWhereUniqueWithoutCommandeSousTraitantInput[]
    updateMany?: LigneCommandeSousTraitantUpdateManyWithWhereWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantUpdateManyWithWhereWithoutCommandeSousTraitantInput[]
    deleteMany?: LigneCommandeSousTraitantScalarWhereInput | LigneCommandeSousTraitantScalarWhereInput[]
  }

  export type soustraitant_etat_avancementUpdateManyWithoutCommande_soustraitantNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput> | soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput[]
    upsert?: soustraitant_etat_avancementUpsertWithWhereUniqueWithoutCommande_soustraitantInput | soustraitant_etat_avancementUpsertWithWhereUniqueWithoutCommande_soustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManyCommande_soustraitantInputEnvelope
    set?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    delete?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    update?: soustraitant_etat_avancementUpdateWithWhereUniqueWithoutCommande_soustraitantInput | soustraitant_etat_avancementUpdateWithWhereUniqueWithoutCommande_soustraitantInput[]
    updateMany?: soustraitant_etat_avancementUpdateManyWithWhereWithoutCommande_soustraitantInput | soustraitant_etat_avancementUpdateManyWithWhereWithoutCommande_soustraitantInput[]
    deleteMany?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
  }

  export type LigneCommandeSousTraitantUncheckedUpdateManyWithoutCommandeSousTraitantNestedInput = {
    create?: XOR<LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput> | LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput[] | LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput[]
    connectOrCreate?: LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput[]
    upsert?: LigneCommandeSousTraitantUpsertWithWhereUniqueWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantUpsertWithWhereUniqueWithoutCommandeSousTraitantInput[]
    createMany?: LigneCommandeSousTraitantCreateManyCommandeSousTraitantInputEnvelope
    set?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    disconnect?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    delete?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    connect?: LigneCommandeSousTraitantWhereUniqueInput | LigneCommandeSousTraitantWhereUniqueInput[]
    update?: LigneCommandeSousTraitantUpdateWithWhereUniqueWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantUpdateWithWhereUniqueWithoutCommandeSousTraitantInput[]
    updateMany?: LigneCommandeSousTraitantUpdateManyWithWhereWithoutCommandeSousTraitantInput | LigneCommandeSousTraitantUpdateManyWithWhereWithoutCommandeSousTraitantInput[]
    deleteMany?: LigneCommandeSousTraitantScalarWhereInput | LigneCommandeSousTraitantScalarWhereInput[]
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyWithoutCommande_soustraitantNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput> | soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput[] | soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput[]
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput | soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput[]
    upsert?: soustraitant_etat_avancementUpsertWithWhereUniqueWithoutCommande_soustraitantInput | soustraitant_etat_avancementUpsertWithWhereUniqueWithoutCommande_soustraitantInput[]
    createMany?: soustraitant_etat_avancementCreateManyCommande_soustraitantInputEnvelope
    set?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    delete?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    connect?: soustraitant_etat_avancementWhereUniqueInput | soustraitant_etat_avancementWhereUniqueInput[]
    update?: soustraitant_etat_avancementUpdateWithWhereUniqueWithoutCommande_soustraitantInput | soustraitant_etat_avancementUpdateWithWhereUniqueWithoutCommande_soustraitantInput[]
    updateMany?: soustraitant_etat_avancementUpdateManyWithWhereWithoutCommande_soustraitantInput | soustraitant_etat_avancementUpdateManyWithWhereWithoutCommande_soustraitantInput[]
    deleteMany?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
  }

  export type CommandeSousTraitantCreateNestedOneWithoutLignesInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutLignesInput, CommandeSousTraitantUncheckedCreateWithoutLignesInput>
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutLignesInput
    connect?: CommandeSousTraitantWhereUniqueInput
  }

  export type CommandeSousTraitantUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutLignesInput, CommandeSousTraitantUncheckedCreateWithoutLignesInput>
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutLignesInput
    upsert?: CommandeSousTraitantUpsertWithoutLignesInput
    connect?: CommandeSousTraitantWhereUniqueInput
    update?: XOR<XOR<CommandeSousTraitantUpdateToOneWithWhereWithoutLignesInput, CommandeSousTraitantUpdateWithoutLignesInput>, CommandeSousTraitantUncheckedUpdateWithoutLignesInput>
  }

  export type soustraitant_etat_avancementCreateNestedOneWithoutAvenant_soustraitant_etat_avancementInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutAvenant_soustraitant_etat_avancementInput>
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutAvenant_soustraitant_etat_avancementInput
    connect?: soustraitant_etat_avancementWhereUniqueInput
  }

  export type soustraitant_etat_avancementUpdateOneRequiredWithoutAvenant_soustraitant_etat_avancementNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutAvenant_soustraitant_etat_avancementInput>
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutAvenant_soustraitant_etat_avancementInput
    upsert?: soustraitant_etat_avancementUpsertWithoutAvenant_soustraitant_etat_avancementInput
    connect?: soustraitant_etat_avancementWhereUniqueInput
    update?: XOR<XOR<soustraitant_etat_avancementUpdateToOneWithWhereWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUpdateWithoutAvenant_soustraitant_etat_avancementInput>, soustraitant_etat_avancementUncheckedUpdateWithoutAvenant_soustraitant_etat_avancementInput>
  }

  export type soustraitant_etat_avancementCreateNestedOneWithoutLigne_soustraitant_etat_avancementInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutLigne_soustraitant_etat_avancementInput>
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutLigne_soustraitant_etat_avancementInput
    connect?: soustraitant_etat_avancementWhereUniqueInput
  }

  export type soustraitant_etat_avancementUpdateOneRequiredWithoutLigne_soustraitant_etat_avancementNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutLigne_soustraitant_etat_avancementInput>
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutLigne_soustraitant_etat_avancementInput
    upsert?: soustraitant_etat_avancementUpsertWithoutLigne_soustraitant_etat_avancementInput
    connect?: soustraitant_etat_avancementWhereUniqueInput
    update?: XOR<XOR<soustraitant_etat_avancementUpdateToOneWithWhereWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUpdateWithoutLigne_soustraitant_etat_avancementInput>, soustraitant_etat_avancementUncheckedUpdateWithoutLigne_soustraitant_etat_avancementInput>
  }

  export type avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    createMany?: avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    connect?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    createMany?: ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    connect?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    createMany?: photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    connect?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutSoustraitant_etat_avancementInput
    connect?: CommandeSousTraitantWhereUniqueInput
  }

  export type EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<EtatAvancementCreateWithoutSoustraitant_etat_avancementInput, EtatAvancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    connectOrCreate?: EtatAvancementCreateOrConnectWithoutSoustraitant_etat_avancementInput
    connect?: EtatAvancementWhereUniqueInput
  }

  export type soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<soustraitantCreateWithoutSoustraitant_etat_avancementInput, soustraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    connectOrCreate?: soustraitantCreateOrConnectWithoutSoustraitant_etat_avancementInput
    connect?: soustraitantWhereUniqueInput
  }

  export type avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    createMany?: avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    connect?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    createMany?: ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    connect?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput = {
    create?: XOR<photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    createMany?: photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    connect?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
  }

  export type avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    upsert?: avenant_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    createMany?: avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    set?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    delete?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    connect?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    update?: avenant_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    updateMany?: avenant_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput[]
    deleteMany?: avenant_soustraitant_etat_avancementScalarWhereInput | avenant_soustraitant_etat_avancementScalarWhereInput[]
  }

  export type ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    upsert?: ligne_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    createMany?: ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    set?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    delete?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    connect?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    update?: ligne_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    updateMany?: ligne_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput[]
    deleteMany?: ligne_soustraitant_etat_avancementScalarWhereInput | ligne_soustraitant_etat_avancementScalarWhereInput[]
  }

  export type photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    upsert?: photo_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    createMany?: photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    set?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    delete?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    connect?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    update?: photo_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    updateMany?: photo_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput[]
    deleteMany?: photo_soustraitant_etat_avancementScalarWhereInput | photo_soustraitant_etat_avancementScalarWhereInput[]
  }

  export type CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<CommandeSousTraitantCreateWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    connectOrCreate?: CommandeSousTraitantCreateOrConnectWithoutSoustraitant_etat_avancementInput
    upsert?: CommandeSousTraitantUpsertWithoutSoustraitant_etat_avancementInput
    disconnect?: CommandeSousTraitantWhereInput | boolean
    delete?: CommandeSousTraitantWhereInput | boolean
    connect?: CommandeSousTraitantWhereUniqueInput
    update?: XOR<XOR<CommandeSousTraitantUpdateToOneWithWhereWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUpdateWithoutSoustraitant_etat_avancementInput>, CommandeSousTraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<EtatAvancementCreateWithoutSoustraitant_etat_avancementInput, EtatAvancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    connectOrCreate?: EtatAvancementCreateOrConnectWithoutSoustraitant_etat_avancementInput
    upsert?: EtatAvancementUpsertWithoutSoustraitant_etat_avancementInput
    connect?: EtatAvancementWhereUniqueInput
    update?: XOR<XOR<EtatAvancementUpdateToOneWithWhereWithoutSoustraitant_etat_avancementInput, EtatAvancementUpdateWithoutSoustraitant_etat_avancementInput>, EtatAvancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<soustraitantCreateWithoutSoustraitant_etat_avancementInput, soustraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    connectOrCreate?: soustraitantCreateOrConnectWithoutSoustraitant_etat_avancementInput
    upsert?: soustraitantUpsertWithoutSoustraitant_etat_avancementInput
    connect?: soustraitantWhereUniqueInput
    update?: XOR<XOR<soustraitantUpdateToOneWithWhereWithoutSoustraitant_etat_avancementInput, soustraitantUpdateWithoutSoustraitant_etat_avancementInput>, soustraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    upsert?: avenant_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    createMany?: avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    set?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    delete?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    connect?: avenant_soustraitant_etat_avancementWhereUniqueInput | avenant_soustraitant_etat_avancementWhereUniqueInput[]
    update?: avenant_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    updateMany?: avenant_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput[]
    deleteMany?: avenant_soustraitant_etat_avancementScalarWhereInput | avenant_soustraitant_etat_avancementScalarWhereInput[]
  }

  export type ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    upsert?: ligne_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    createMany?: ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    set?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    delete?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    connect?: ligne_soustraitant_etat_avancementWhereUniqueInput | ligne_soustraitant_etat_avancementWhereUniqueInput[]
    update?: ligne_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    updateMany?: ligne_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput[]
    deleteMany?: ligne_soustraitant_etat_avancementScalarWhereInput | ligne_soustraitant_etat_avancementScalarWhereInput[]
  }

  export type photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput = {
    create?: XOR<photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput> | photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput[] | photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput[]
    connectOrCreate?: photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput[]
    upsert?: photo_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    createMany?: photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope
    set?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    disconnect?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    delete?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    connect?: photo_soustraitant_etat_avancementWhereUniqueInput | photo_soustraitant_etat_avancementWhereUniqueInput[]
    update?: photo_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput[]
    updateMany?: photo_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput[]
    deleteMany?: photo_soustraitant_etat_avancementScalarWhereInput | photo_soustraitant_etat_avancementScalarWhereInput[]
  }

  export type soustraitant_etat_avancementCreateNestedOneWithoutPhotosInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutPhotosInput, soustraitant_etat_avancementUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutPhotosInput
    connect?: soustraitant_etat_avancementWhereUniqueInput
  }

  export type soustraitant_etat_avancementUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<soustraitant_etat_avancementCreateWithoutPhotosInput, soustraitant_etat_avancementUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: soustraitant_etat_avancementCreateOrConnectWithoutPhotosInput
    upsert?: soustraitant_etat_avancementUpsertWithoutPhotosInput
    connect?: soustraitant_etat_avancementWhereUniqueInput
    update?: XOR<XOR<soustraitant_etat_avancementUpdateToOneWithWhereWithoutPhotosInput, soustraitant_etat_avancementUpdateWithoutPhotosInput>, soustraitant_etat_avancementUncheckedUpdateWithoutPhotosInput>
  }

  export type EmplacementCreateNestedManyWithoutRackInput = {
    create?: XOR<EmplacementCreateWithoutRackInput, EmplacementUncheckedCreateWithoutRackInput> | EmplacementCreateWithoutRackInput[] | EmplacementUncheckedCreateWithoutRackInput[]
    connectOrCreate?: EmplacementCreateOrConnectWithoutRackInput | EmplacementCreateOrConnectWithoutRackInput[]
    createMany?: EmplacementCreateManyRackInputEnvelope
    connect?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
  }

  export type EmplacementUncheckedCreateNestedManyWithoutRackInput = {
    create?: XOR<EmplacementCreateWithoutRackInput, EmplacementUncheckedCreateWithoutRackInput> | EmplacementCreateWithoutRackInput[] | EmplacementUncheckedCreateWithoutRackInput[]
    connectOrCreate?: EmplacementCreateOrConnectWithoutRackInput | EmplacementCreateOrConnectWithoutRackInput[]
    createMany?: EmplacementCreateManyRackInputEnvelope
    connect?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
  }

  export type EmplacementUpdateManyWithoutRackNestedInput = {
    create?: XOR<EmplacementCreateWithoutRackInput, EmplacementUncheckedCreateWithoutRackInput> | EmplacementCreateWithoutRackInput[] | EmplacementUncheckedCreateWithoutRackInput[]
    connectOrCreate?: EmplacementCreateOrConnectWithoutRackInput | EmplacementCreateOrConnectWithoutRackInput[]
    upsert?: EmplacementUpsertWithWhereUniqueWithoutRackInput | EmplacementUpsertWithWhereUniqueWithoutRackInput[]
    createMany?: EmplacementCreateManyRackInputEnvelope
    set?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    disconnect?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    delete?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    connect?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    update?: EmplacementUpdateWithWhereUniqueWithoutRackInput | EmplacementUpdateWithWhereUniqueWithoutRackInput[]
    updateMany?: EmplacementUpdateManyWithWhereWithoutRackInput | EmplacementUpdateManyWithWhereWithoutRackInput[]
    deleteMany?: EmplacementScalarWhereInput | EmplacementScalarWhereInput[]
  }

  export type EmplacementUncheckedUpdateManyWithoutRackNestedInput = {
    create?: XOR<EmplacementCreateWithoutRackInput, EmplacementUncheckedCreateWithoutRackInput> | EmplacementCreateWithoutRackInput[] | EmplacementUncheckedCreateWithoutRackInput[]
    connectOrCreate?: EmplacementCreateOrConnectWithoutRackInput | EmplacementCreateOrConnectWithoutRackInput[]
    upsert?: EmplacementUpsertWithWhereUniqueWithoutRackInput | EmplacementUpsertWithWhereUniqueWithoutRackInput[]
    createMany?: EmplacementCreateManyRackInputEnvelope
    set?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    disconnect?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    delete?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    connect?: EmplacementWhereUniqueInput | EmplacementWhereUniqueInput[]
    update?: EmplacementUpdateWithWhereUniqueWithoutRackInput | EmplacementUpdateWithWhereUniqueWithoutRackInput[]
    updateMany?: EmplacementUpdateManyWithWhereWithoutRackInput | EmplacementUpdateManyWithWhereWithoutRackInput[]
    deleteMany?: EmplacementScalarWhereInput | EmplacementScalarWhereInput[]
  }

  export type RackCreateNestedOneWithoutEmplacementsInput = {
    create?: XOR<RackCreateWithoutEmplacementsInput, RackUncheckedCreateWithoutEmplacementsInput>
    connectOrCreate?: RackCreateOrConnectWithoutEmplacementsInput
    connect?: RackWhereUniqueInput
  }

  export type MateriauCreateNestedManyWithoutEmplacementInput = {
    create?: XOR<MateriauCreateWithoutEmplacementInput, MateriauUncheckedCreateWithoutEmplacementInput> | MateriauCreateWithoutEmplacementInput[] | MateriauUncheckedCreateWithoutEmplacementInput[]
    connectOrCreate?: MateriauCreateOrConnectWithoutEmplacementInput | MateriauCreateOrConnectWithoutEmplacementInput[]
    createMany?: MateriauCreateManyEmplacementInputEnvelope
    connect?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
  }

  export type MateriauUncheckedCreateNestedManyWithoutEmplacementInput = {
    create?: XOR<MateriauCreateWithoutEmplacementInput, MateriauUncheckedCreateWithoutEmplacementInput> | MateriauCreateWithoutEmplacementInput[] | MateriauUncheckedCreateWithoutEmplacementInput[]
    connectOrCreate?: MateriauCreateOrConnectWithoutEmplacementInput | MateriauCreateOrConnectWithoutEmplacementInput[]
    createMany?: MateriauCreateManyEmplacementInputEnvelope
    connect?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
  }

  export type RackUpdateOneRequiredWithoutEmplacementsNestedInput = {
    create?: XOR<RackCreateWithoutEmplacementsInput, RackUncheckedCreateWithoutEmplacementsInput>
    connectOrCreate?: RackCreateOrConnectWithoutEmplacementsInput
    upsert?: RackUpsertWithoutEmplacementsInput
    connect?: RackWhereUniqueInput
    update?: XOR<XOR<RackUpdateToOneWithWhereWithoutEmplacementsInput, RackUpdateWithoutEmplacementsInput>, RackUncheckedUpdateWithoutEmplacementsInput>
  }

  export type MateriauUpdateManyWithoutEmplacementNestedInput = {
    create?: XOR<MateriauCreateWithoutEmplacementInput, MateriauUncheckedCreateWithoutEmplacementInput> | MateriauCreateWithoutEmplacementInput[] | MateriauUncheckedCreateWithoutEmplacementInput[]
    connectOrCreate?: MateriauCreateOrConnectWithoutEmplacementInput | MateriauCreateOrConnectWithoutEmplacementInput[]
    upsert?: MateriauUpsertWithWhereUniqueWithoutEmplacementInput | MateriauUpsertWithWhereUniqueWithoutEmplacementInput[]
    createMany?: MateriauCreateManyEmplacementInputEnvelope
    set?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    disconnect?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    delete?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    connect?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    update?: MateriauUpdateWithWhereUniqueWithoutEmplacementInput | MateriauUpdateWithWhereUniqueWithoutEmplacementInput[]
    updateMany?: MateriauUpdateManyWithWhereWithoutEmplacementInput | MateriauUpdateManyWithWhereWithoutEmplacementInput[]
    deleteMany?: MateriauScalarWhereInput | MateriauScalarWhereInput[]
  }

  export type MateriauUncheckedUpdateManyWithoutEmplacementNestedInput = {
    create?: XOR<MateriauCreateWithoutEmplacementInput, MateriauUncheckedCreateWithoutEmplacementInput> | MateriauCreateWithoutEmplacementInput[] | MateriauUncheckedCreateWithoutEmplacementInput[]
    connectOrCreate?: MateriauCreateOrConnectWithoutEmplacementInput | MateriauCreateOrConnectWithoutEmplacementInput[]
    upsert?: MateriauUpsertWithWhereUniqueWithoutEmplacementInput | MateriauUpsertWithWhereUniqueWithoutEmplacementInput[]
    createMany?: MateriauCreateManyEmplacementInputEnvelope
    set?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    disconnect?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    delete?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    connect?: MateriauWhereUniqueInput | MateriauWhereUniqueInput[]
    update?: MateriauUpdateWithWhereUniqueWithoutEmplacementInput | MateriauUpdateWithWhereUniqueWithoutEmplacementInput[]
    updateMany?: MateriauUpdateManyWithWhereWithoutEmplacementInput | MateriauUpdateManyWithWhereWithoutEmplacementInput[]
    deleteMany?: MateriauScalarWhereInput | MateriauScalarWhereInput[]
  }

  export type EmplacementCreateNestedOneWithoutMateriauxInput = {
    create?: XOR<EmplacementCreateWithoutMateriauxInput, EmplacementUncheckedCreateWithoutMateriauxInput>
    connectOrCreate?: EmplacementCreateOrConnectWithoutMateriauxInput
    connect?: EmplacementWhereUniqueInput
  }

  export type EmplacementUpdateOneWithoutMateriauxNestedInput = {
    create?: XOR<EmplacementCreateWithoutMateriauxInput, EmplacementUncheckedCreateWithoutMateriauxInput>
    connectOrCreate?: EmplacementCreateOrConnectWithoutMateriauxInput
    upsert?: EmplacementUpsertWithoutMateriauxInput
    disconnect?: EmplacementWhereInput | boolean
    delete?: EmplacementWhereInput | boolean
    connect?: EmplacementWhereUniqueInput
    update?: XOR<XOR<EmplacementUpdateToOneWithWhereWithoutMateriauxInput, EmplacementUpdateWithoutMateriauxInput>, EmplacementUncheckedUpdateWithoutMateriauxInput>
  }

  export type ChantierCreateNestedOneWithoutAvenantsInput = {
    create?: XOR<ChantierCreateWithoutAvenantsInput, ChantierUncheckedCreateWithoutAvenantsInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutAvenantsInput
    connect?: ChantierWhereUniqueInput
  }

  export type MarcheCreateNestedOneWithoutAvenantInput = {
    create?: XOR<MarcheCreateWithoutAvenantInput, MarcheUncheckedCreateWithoutAvenantInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutAvenantInput
    connect?: MarcheWhereUniqueInput
  }

  export type ChantierUpdateOneRequiredWithoutAvenantsNestedInput = {
    create?: XOR<ChantierCreateWithoutAvenantsInput, ChantierUncheckedCreateWithoutAvenantsInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutAvenantsInput
    upsert?: ChantierUpsertWithoutAvenantsInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutAvenantsInput, ChantierUpdateWithoutAvenantsInput>, ChantierUncheckedUpdateWithoutAvenantsInput>
  }

  export type MarcheUpdateOneRequiredWithoutAvenantNestedInput = {
    create?: XOR<MarcheCreateWithoutAvenantInput, MarcheUncheckedCreateWithoutAvenantInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutAvenantInput
    upsert?: MarcheUpsertWithoutAvenantInput
    connect?: MarcheWhereUniqueInput
    update?: XOR<XOR<MarcheUpdateToOneWithWhereWithoutAvenantInput, MarcheUpdateWithoutAvenantInput>, MarcheUncheckedUpdateWithoutAvenantInput>
  }

  export type AvenantCreateNestedManyWithoutChantierInput = {
    create?: XOR<AvenantCreateWithoutChantierInput, AvenantUncheckedCreateWithoutChantierInput> | AvenantCreateWithoutChantierInput[] | AvenantUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutChantierInput | AvenantCreateOrConnectWithoutChantierInput[]
    createMany?: AvenantCreateManyChantierInputEnvelope
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutChantierInput = {
    create?: XOR<ClientCreateWithoutChantierInput, ClientUncheckedCreateWithoutChantierInput>
    connectOrCreate?: ClientCreateOrConnectWithoutChantierInput
    connect?: ClientWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutChantierInput = {
    create?: XOR<DocumentCreateWithoutChantierInput, DocumentUncheckedCreateWithoutChantierInput> | DocumentCreateWithoutChantierInput[] | DocumentUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutChantierInput | DocumentCreateOrConnectWithoutChantierInput[]
    createMany?: DocumentCreateManyChantierInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EtatCreateNestedManyWithoutChantierInput = {
    create?: XOR<EtatCreateWithoutChantierInput, EtatUncheckedCreateWithoutChantierInput> | EtatCreateWithoutChantierInput[] | EtatUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: EtatCreateOrConnectWithoutChantierInput | EtatCreateOrConnectWithoutChantierInput[]
    createMany?: EtatCreateManyChantierInputEnvelope
    connect?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
  }

  export type MarcheCreateNestedOneWithoutChantierInput = {
    create?: XOR<MarcheCreateWithoutChantierInput, MarcheUncheckedCreateWithoutChantierInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutChantierInput
    connect?: MarcheWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutChantierInput = {
    create?: XOR<NoteCreateWithoutChantierInput, NoteUncheckedCreateWithoutChantierInput> | NoteCreateWithoutChantierInput[] | NoteUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutChantierInput | NoteCreateOrConnectWithoutChantierInput[]
    createMany?: NoteCreateManyChantierInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TacheCreateNestedManyWithoutChantierInput = {
    create?: XOR<TacheCreateWithoutChantierInput, TacheUncheckedCreateWithoutChantierInput> | TacheCreateWithoutChantierInput[] | TacheUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: TacheCreateOrConnectWithoutChantierInput | TacheCreateOrConnectWithoutChantierInput[]
    createMany?: TacheCreateManyChantierInputEnvelope
    connect?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
  }

  export type admintaskCreateNestedManyWithoutChantierInput = {
    create?: XOR<admintaskCreateWithoutChantierInput, admintaskUncheckedCreateWithoutChantierInput> | admintaskCreateWithoutChantierInput[] | admintaskUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutChantierInput | admintaskCreateOrConnectWithoutChantierInput[]
    createMany?: admintaskCreateManyChantierInputEnvelope
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
  }

  export type BonRegieCreateNestedManyWithoutChantierInput = {
    create?: XOR<BonRegieCreateWithoutChantierInput, BonRegieUncheckedCreateWithoutChantierInput> | BonRegieCreateWithoutChantierInput[] | BonRegieUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: BonRegieCreateOrConnectWithoutChantierInput | BonRegieCreateOrConnectWithoutChantierInput[]
    createMany?: BonRegieCreateManyChantierInputEnvelope
    connect?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
  }

  export type AvenantUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<AvenantCreateWithoutChantierInput, AvenantUncheckedCreateWithoutChantierInput> | AvenantCreateWithoutChantierInput[] | AvenantUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutChantierInput | AvenantCreateOrConnectWithoutChantierInput[]
    createMany?: AvenantCreateManyChantierInputEnvelope
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<DocumentCreateWithoutChantierInput, DocumentUncheckedCreateWithoutChantierInput> | DocumentCreateWithoutChantierInput[] | DocumentUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutChantierInput | DocumentCreateOrConnectWithoutChantierInput[]
    createMany?: DocumentCreateManyChantierInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EtatUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<EtatCreateWithoutChantierInput, EtatUncheckedCreateWithoutChantierInput> | EtatCreateWithoutChantierInput[] | EtatUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: EtatCreateOrConnectWithoutChantierInput | EtatCreateOrConnectWithoutChantierInput[]
    createMany?: EtatCreateManyChantierInputEnvelope
    connect?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
  }

  export type MarcheUncheckedCreateNestedOneWithoutChantierInput = {
    create?: XOR<MarcheCreateWithoutChantierInput, MarcheUncheckedCreateWithoutChantierInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutChantierInput
    connect?: MarcheWhereUniqueInput
  }

  export type NoteUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<NoteCreateWithoutChantierInput, NoteUncheckedCreateWithoutChantierInput> | NoteCreateWithoutChantierInput[] | NoteUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutChantierInput | NoteCreateOrConnectWithoutChantierInput[]
    createMany?: NoteCreateManyChantierInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TacheUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<TacheCreateWithoutChantierInput, TacheUncheckedCreateWithoutChantierInput> | TacheCreateWithoutChantierInput[] | TacheUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: TacheCreateOrConnectWithoutChantierInput | TacheCreateOrConnectWithoutChantierInput[]
    createMany?: TacheCreateManyChantierInputEnvelope
    connect?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
  }

  export type admintaskUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<admintaskCreateWithoutChantierInput, admintaskUncheckedCreateWithoutChantierInput> | admintaskCreateWithoutChantierInput[] | admintaskUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutChantierInput | admintaskCreateOrConnectWithoutChantierInput[]
    createMany?: admintaskCreateManyChantierInputEnvelope
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
  }

  export type BonRegieUncheckedCreateNestedManyWithoutChantierInput = {
    create?: XOR<BonRegieCreateWithoutChantierInput, BonRegieUncheckedCreateWithoutChantierInput> | BonRegieCreateWithoutChantierInput[] | BonRegieUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: BonRegieCreateOrConnectWithoutChantierInput | BonRegieCreateOrConnectWithoutChantierInput[]
    createMany?: BonRegieCreateManyChantierInputEnvelope
    connect?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AvenantUpdateManyWithoutChantierNestedInput = {
    create?: XOR<AvenantCreateWithoutChantierInput, AvenantUncheckedCreateWithoutChantierInput> | AvenantCreateWithoutChantierInput[] | AvenantUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutChantierInput | AvenantCreateOrConnectWithoutChantierInput[]
    upsert?: AvenantUpsertWithWhereUniqueWithoutChantierInput | AvenantUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: AvenantCreateManyChantierInputEnvelope
    set?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    disconnect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    delete?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    update?: AvenantUpdateWithWhereUniqueWithoutChantierInput | AvenantUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: AvenantUpdateManyWithWhereWithoutChantierInput | AvenantUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: AvenantScalarWhereInput | AvenantScalarWhereInput[]
  }

  export type ClientUpdateOneWithoutChantierNestedInput = {
    create?: XOR<ClientCreateWithoutChantierInput, ClientUncheckedCreateWithoutChantierInput>
    connectOrCreate?: ClientCreateOrConnectWithoutChantierInput
    upsert?: ClientUpsertWithoutChantierInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutChantierInput, ClientUpdateWithoutChantierInput>, ClientUncheckedUpdateWithoutChantierInput>
  }

  export type DocumentUpdateManyWithoutChantierNestedInput = {
    create?: XOR<DocumentCreateWithoutChantierInput, DocumentUncheckedCreateWithoutChantierInput> | DocumentCreateWithoutChantierInput[] | DocumentUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutChantierInput | DocumentCreateOrConnectWithoutChantierInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutChantierInput | DocumentUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: DocumentCreateManyChantierInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutChantierInput | DocumentUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutChantierInput | DocumentUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EtatUpdateManyWithoutChantierNestedInput = {
    create?: XOR<EtatCreateWithoutChantierInput, EtatUncheckedCreateWithoutChantierInput> | EtatCreateWithoutChantierInput[] | EtatUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: EtatCreateOrConnectWithoutChantierInput | EtatCreateOrConnectWithoutChantierInput[]
    upsert?: EtatUpsertWithWhereUniqueWithoutChantierInput | EtatUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: EtatCreateManyChantierInputEnvelope
    set?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    disconnect?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    delete?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    connect?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    update?: EtatUpdateWithWhereUniqueWithoutChantierInput | EtatUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: EtatUpdateManyWithWhereWithoutChantierInput | EtatUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: EtatScalarWhereInput | EtatScalarWhereInput[]
  }

  export type MarcheUpdateOneWithoutChantierNestedInput = {
    create?: XOR<MarcheCreateWithoutChantierInput, MarcheUncheckedCreateWithoutChantierInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutChantierInput
    upsert?: MarcheUpsertWithoutChantierInput
    disconnect?: MarcheWhereInput | boolean
    delete?: MarcheWhereInput | boolean
    connect?: MarcheWhereUniqueInput
    update?: XOR<XOR<MarcheUpdateToOneWithWhereWithoutChantierInput, MarcheUpdateWithoutChantierInput>, MarcheUncheckedUpdateWithoutChantierInput>
  }

  export type NoteUpdateManyWithoutChantierNestedInput = {
    create?: XOR<NoteCreateWithoutChantierInput, NoteUncheckedCreateWithoutChantierInput> | NoteCreateWithoutChantierInput[] | NoteUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutChantierInput | NoteCreateOrConnectWithoutChantierInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutChantierInput | NoteUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: NoteCreateManyChantierInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutChantierInput | NoteUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutChantierInput | NoteUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TacheUpdateManyWithoutChantierNestedInput = {
    create?: XOR<TacheCreateWithoutChantierInput, TacheUncheckedCreateWithoutChantierInput> | TacheCreateWithoutChantierInput[] | TacheUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: TacheCreateOrConnectWithoutChantierInput | TacheCreateOrConnectWithoutChantierInput[]
    upsert?: TacheUpsertWithWhereUniqueWithoutChantierInput | TacheUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: TacheCreateManyChantierInputEnvelope
    set?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    disconnect?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    delete?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    connect?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    update?: TacheUpdateWithWhereUniqueWithoutChantierInput | TacheUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: TacheUpdateManyWithWhereWithoutChantierInput | TacheUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: TacheScalarWhereInput | TacheScalarWhereInput[]
  }

  export type admintaskUpdateManyWithoutChantierNestedInput = {
    create?: XOR<admintaskCreateWithoutChantierInput, admintaskUncheckedCreateWithoutChantierInput> | admintaskCreateWithoutChantierInput[] | admintaskUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutChantierInput | admintaskCreateOrConnectWithoutChantierInput[]
    upsert?: admintaskUpsertWithWhereUniqueWithoutChantierInput | admintaskUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: admintaskCreateManyChantierInputEnvelope
    set?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    disconnect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    delete?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    update?: admintaskUpdateWithWhereUniqueWithoutChantierInput | admintaskUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: admintaskUpdateManyWithWhereWithoutChantierInput | admintaskUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: admintaskScalarWhereInput | admintaskScalarWhereInput[]
  }

  export type BonRegieUpdateManyWithoutChantierNestedInput = {
    create?: XOR<BonRegieCreateWithoutChantierInput, BonRegieUncheckedCreateWithoutChantierInput> | BonRegieCreateWithoutChantierInput[] | BonRegieUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: BonRegieCreateOrConnectWithoutChantierInput | BonRegieCreateOrConnectWithoutChantierInput[]
    upsert?: BonRegieUpsertWithWhereUniqueWithoutChantierInput | BonRegieUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: BonRegieCreateManyChantierInputEnvelope
    set?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    disconnect?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    delete?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    connect?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    update?: BonRegieUpdateWithWhereUniqueWithoutChantierInput | BonRegieUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: BonRegieUpdateManyWithWhereWithoutChantierInput | BonRegieUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: BonRegieScalarWhereInput | BonRegieScalarWhereInput[]
  }

  export type AvenantUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<AvenantCreateWithoutChantierInput, AvenantUncheckedCreateWithoutChantierInput> | AvenantCreateWithoutChantierInput[] | AvenantUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutChantierInput | AvenantCreateOrConnectWithoutChantierInput[]
    upsert?: AvenantUpsertWithWhereUniqueWithoutChantierInput | AvenantUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: AvenantCreateManyChantierInputEnvelope
    set?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    disconnect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    delete?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    update?: AvenantUpdateWithWhereUniqueWithoutChantierInput | AvenantUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: AvenantUpdateManyWithWhereWithoutChantierInput | AvenantUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: AvenantScalarWhereInput | AvenantScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<DocumentCreateWithoutChantierInput, DocumentUncheckedCreateWithoutChantierInput> | DocumentCreateWithoutChantierInput[] | DocumentUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutChantierInput | DocumentCreateOrConnectWithoutChantierInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutChantierInput | DocumentUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: DocumentCreateManyChantierInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutChantierInput | DocumentUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutChantierInput | DocumentUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EtatUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<EtatCreateWithoutChantierInput, EtatUncheckedCreateWithoutChantierInput> | EtatCreateWithoutChantierInput[] | EtatUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: EtatCreateOrConnectWithoutChantierInput | EtatCreateOrConnectWithoutChantierInput[]
    upsert?: EtatUpsertWithWhereUniqueWithoutChantierInput | EtatUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: EtatCreateManyChantierInputEnvelope
    set?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    disconnect?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    delete?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    connect?: EtatWhereUniqueInput | EtatWhereUniqueInput[]
    update?: EtatUpdateWithWhereUniqueWithoutChantierInput | EtatUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: EtatUpdateManyWithWhereWithoutChantierInput | EtatUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: EtatScalarWhereInput | EtatScalarWhereInput[]
  }

  export type MarcheUncheckedUpdateOneWithoutChantierNestedInput = {
    create?: XOR<MarcheCreateWithoutChantierInput, MarcheUncheckedCreateWithoutChantierInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutChantierInput
    upsert?: MarcheUpsertWithoutChantierInput
    disconnect?: MarcheWhereInput | boolean
    delete?: MarcheWhereInput | boolean
    connect?: MarcheWhereUniqueInput
    update?: XOR<XOR<MarcheUpdateToOneWithWhereWithoutChantierInput, MarcheUpdateWithoutChantierInput>, MarcheUncheckedUpdateWithoutChantierInput>
  }

  export type NoteUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<NoteCreateWithoutChantierInput, NoteUncheckedCreateWithoutChantierInput> | NoteCreateWithoutChantierInput[] | NoteUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutChantierInput | NoteCreateOrConnectWithoutChantierInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutChantierInput | NoteUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: NoteCreateManyChantierInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutChantierInput | NoteUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutChantierInput | NoteUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TacheUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<TacheCreateWithoutChantierInput, TacheUncheckedCreateWithoutChantierInput> | TacheCreateWithoutChantierInput[] | TacheUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: TacheCreateOrConnectWithoutChantierInput | TacheCreateOrConnectWithoutChantierInput[]
    upsert?: TacheUpsertWithWhereUniqueWithoutChantierInput | TacheUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: TacheCreateManyChantierInputEnvelope
    set?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    disconnect?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    delete?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    connect?: TacheWhereUniqueInput | TacheWhereUniqueInput[]
    update?: TacheUpdateWithWhereUniqueWithoutChantierInput | TacheUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: TacheUpdateManyWithWhereWithoutChantierInput | TacheUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: TacheScalarWhereInput | TacheScalarWhereInput[]
  }

  export type admintaskUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<admintaskCreateWithoutChantierInput, admintaskUncheckedCreateWithoutChantierInput> | admintaskCreateWithoutChantierInput[] | admintaskUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutChantierInput | admintaskCreateOrConnectWithoutChantierInput[]
    upsert?: admintaskUpsertWithWhereUniqueWithoutChantierInput | admintaskUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: admintaskCreateManyChantierInputEnvelope
    set?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    disconnect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    delete?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    update?: admintaskUpdateWithWhereUniqueWithoutChantierInput | admintaskUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: admintaskUpdateManyWithWhereWithoutChantierInput | admintaskUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: admintaskScalarWhereInput | admintaskScalarWhereInput[]
  }

  export type BonRegieUncheckedUpdateManyWithoutChantierNestedInput = {
    create?: XOR<BonRegieCreateWithoutChantierInput, BonRegieUncheckedCreateWithoutChantierInput> | BonRegieCreateWithoutChantierInput[] | BonRegieUncheckedCreateWithoutChantierInput[]
    connectOrCreate?: BonRegieCreateOrConnectWithoutChantierInput | BonRegieCreateOrConnectWithoutChantierInput[]
    upsert?: BonRegieUpsertWithWhereUniqueWithoutChantierInput | BonRegieUpsertWithWhereUniqueWithoutChantierInput[]
    createMany?: BonRegieCreateManyChantierInputEnvelope
    set?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    disconnect?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    delete?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    connect?: BonRegieWhereUniqueInput | BonRegieWhereUniqueInput[]
    update?: BonRegieUpdateWithWhereUniqueWithoutChantierInput | BonRegieUpdateWithWhereUniqueWithoutChantierInput[]
    updateMany?: BonRegieUpdateManyWithWhereWithoutChantierInput | BonRegieUpdateManyWithWhereWithoutChantierInput[]
    deleteMany?: BonRegieScalarWhereInput | BonRegieScalarWhereInput[]
  }

  export type ChantierCreateNestedManyWithoutClientInput = {
    create?: XOR<ChantierCreateWithoutClientInput, ChantierUncheckedCreateWithoutClientInput> | ChantierCreateWithoutClientInput[] | ChantierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChantierCreateOrConnectWithoutClientInput | ChantierCreateOrConnectWithoutClientInput[]
    createMany?: ChantierCreateManyClientInputEnvelope
    connect?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
  }

  export type ChantierUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ChantierCreateWithoutClientInput, ChantierUncheckedCreateWithoutClientInput> | ChantierCreateWithoutClientInput[] | ChantierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChantierCreateOrConnectWithoutClientInput | ChantierCreateOrConnectWithoutClientInput[]
    createMany?: ChantierCreateManyClientInputEnvelope
    connect?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
  }

  export type ChantierUpdateManyWithoutClientNestedInput = {
    create?: XOR<ChantierCreateWithoutClientInput, ChantierUncheckedCreateWithoutClientInput> | ChantierCreateWithoutClientInput[] | ChantierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChantierCreateOrConnectWithoutClientInput | ChantierCreateOrConnectWithoutClientInput[]
    upsert?: ChantierUpsertWithWhereUniqueWithoutClientInput | ChantierUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ChantierCreateManyClientInputEnvelope
    set?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    disconnect?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    delete?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    connect?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    update?: ChantierUpdateWithWhereUniqueWithoutClientInput | ChantierUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ChantierUpdateManyWithWhereWithoutClientInput | ChantierUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ChantierScalarWhereInput | ChantierScalarWhereInput[]
  }

  export type ChantierUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ChantierCreateWithoutClientInput, ChantierUncheckedCreateWithoutClientInput> | ChantierCreateWithoutClientInput[] | ChantierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChantierCreateOrConnectWithoutClientInput | ChantierCreateOrConnectWithoutClientInput[]
    upsert?: ChantierUpsertWithWhereUniqueWithoutClientInput | ChantierUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ChantierCreateManyClientInputEnvelope
    set?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    disconnect?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    delete?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    connect?: ChantierWhereUniqueInput | ChantierWhereUniqueInput[]
    update?: ChantierUpdateWithWhereUniqueWithoutClientInput | ChantierUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ChantierUpdateManyWithWhereWithoutClientInput | ChantierUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ChantierScalarWhereInput | ChantierScalarWhereInput[]
  }

  export type ChantierCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ChantierCreateWithoutDocumentsInput, ChantierUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutDocumentsInput
    connect?: ChantierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type ChantierUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ChantierCreateWithoutDocumentsInput, ChantierUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutDocumentsInput
    upsert?: ChantierUpsertWithoutDocumentsInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutDocumentsInput, ChantierUpdateWithoutDocumentsInput>, ChantierUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentNestedInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    upsert?: UserUpsertWithoutDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentInput, UserUpdateWithoutDocumentInput>, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type OuvrierCreateNestedOneWithoutDocumentOuvrierInput = {
    create?: XOR<OuvrierCreateWithoutDocumentOuvrierInput, OuvrierUncheckedCreateWithoutDocumentOuvrierInput>
    connectOrCreate?: OuvrierCreateOrConnectWithoutDocumentOuvrierInput
    connect?: OuvrierWhereUniqueInput
  }

  export type OuvrierUpdateOneRequiredWithoutDocumentOuvrierNestedInput = {
    create?: XOR<OuvrierCreateWithoutDocumentOuvrierInput, OuvrierUncheckedCreateWithoutDocumentOuvrierInput>
    connectOrCreate?: OuvrierCreateOrConnectWithoutDocumentOuvrierInput
    upsert?: OuvrierUpsertWithoutDocumentOuvrierInput
    connect?: OuvrierWhereUniqueInput
    update?: XOR<XOR<OuvrierUpdateToOneWithWhereWithoutDocumentOuvrierInput, OuvrierUpdateWithoutDocumentOuvrierInput>, OuvrierUncheckedUpdateWithoutDocumentOuvrierInput>
  }

  export type ChantierCreateNestedOneWithoutEtatsInput = {
    create?: XOR<ChantierCreateWithoutEtatsInput, ChantierUncheckedCreateWithoutEtatsInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutEtatsInput
    connect?: ChantierWhereUniqueInput
  }

  export type LigneEtatCreateNestedManyWithoutEtatInput = {
    create?: XOR<LigneEtatCreateWithoutEtatInput, LigneEtatUncheckedCreateWithoutEtatInput> | LigneEtatCreateWithoutEtatInput[] | LigneEtatUncheckedCreateWithoutEtatInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutEtatInput | LigneEtatCreateOrConnectWithoutEtatInput[]
    createMany?: LigneEtatCreateManyEtatInputEnvelope
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
  }

  export type LigneEtatUncheckedCreateNestedManyWithoutEtatInput = {
    create?: XOR<LigneEtatCreateWithoutEtatInput, LigneEtatUncheckedCreateWithoutEtatInput> | LigneEtatCreateWithoutEtatInput[] | LigneEtatUncheckedCreateWithoutEtatInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutEtatInput | LigneEtatCreateOrConnectWithoutEtatInput[]
    createMany?: LigneEtatCreateManyEtatInputEnvelope
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
  }

  export type ChantierUpdateOneRequiredWithoutEtatsNestedInput = {
    create?: XOR<ChantierCreateWithoutEtatsInput, ChantierUncheckedCreateWithoutEtatsInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutEtatsInput
    upsert?: ChantierUpsertWithoutEtatsInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutEtatsInput, ChantierUpdateWithoutEtatsInput>, ChantierUncheckedUpdateWithoutEtatsInput>
  }

  export type LigneEtatUpdateManyWithoutEtatNestedInput = {
    create?: XOR<LigneEtatCreateWithoutEtatInput, LigneEtatUncheckedCreateWithoutEtatInput> | LigneEtatCreateWithoutEtatInput[] | LigneEtatUncheckedCreateWithoutEtatInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutEtatInput | LigneEtatCreateOrConnectWithoutEtatInput[]
    upsert?: LigneEtatUpsertWithWhereUniqueWithoutEtatInput | LigneEtatUpsertWithWhereUniqueWithoutEtatInput[]
    createMany?: LigneEtatCreateManyEtatInputEnvelope
    set?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    disconnect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    delete?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    update?: LigneEtatUpdateWithWhereUniqueWithoutEtatInput | LigneEtatUpdateWithWhereUniqueWithoutEtatInput[]
    updateMany?: LigneEtatUpdateManyWithWhereWithoutEtatInput | LigneEtatUpdateManyWithWhereWithoutEtatInput[]
    deleteMany?: LigneEtatScalarWhereInput | LigneEtatScalarWhereInput[]
  }

  export type LigneEtatUncheckedUpdateManyWithoutEtatNestedInput = {
    create?: XOR<LigneEtatCreateWithoutEtatInput, LigneEtatUncheckedCreateWithoutEtatInput> | LigneEtatCreateWithoutEtatInput[] | LigneEtatUncheckedCreateWithoutEtatInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutEtatInput | LigneEtatCreateOrConnectWithoutEtatInput[]
    upsert?: LigneEtatUpsertWithWhereUniqueWithoutEtatInput | LigneEtatUpsertWithWhereUniqueWithoutEtatInput[]
    createMany?: LigneEtatCreateManyEtatInputEnvelope
    set?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    disconnect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    delete?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    update?: LigneEtatUpdateWithWhereUniqueWithoutEtatInput | LigneEtatUpdateWithWhereUniqueWithoutEtatInput[]
    updateMany?: LigneEtatUpdateManyWithWhereWithoutEtatInput | LigneEtatUpdateManyWithWhereWithoutEtatInput[]
    deleteMany?: LigneEtatScalarWhereInput | LigneEtatScalarWhereInput[]
  }

  export type EtatCreateNestedOneWithoutLigneEtatInput = {
    create?: XOR<EtatCreateWithoutLigneEtatInput, EtatUncheckedCreateWithoutLigneEtatInput>
    connectOrCreate?: EtatCreateOrConnectWithoutLigneEtatInput
    connect?: EtatWhereUniqueInput
  }

  export type LigneMarcheCreateNestedOneWithoutLigneEtatInput = {
    create?: XOR<LigneMarcheCreateWithoutLigneEtatInput, LigneMarcheUncheckedCreateWithoutLigneEtatInput>
    connectOrCreate?: LigneMarcheCreateOrConnectWithoutLigneEtatInput
    connect?: LigneMarcheWhereUniqueInput
  }

  export type EtatUpdateOneRequiredWithoutLigneEtatNestedInput = {
    create?: XOR<EtatCreateWithoutLigneEtatInput, EtatUncheckedCreateWithoutLigneEtatInput>
    connectOrCreate?: EtatCreateOrConnectWithoutLigneEtatInput
    upsert?: EtatUpsertWithoutLigneEtatInput
    connect?: EtatWhereUniqueInput
    update?: XOR<XOR<EtatUpdateToOneWithWhereWithoutLigneEtatInput, EtatUpdateWithoutLigneEtatInput>, EtatUncheckedUpdateWithoutLigneEtatInput>
  }

  export type LigneMarcheUpdateOneRequiredWithoutLigneEtatNestedInput = {
    create?: XOR<LigneMarcheCreateWithoutLigneEtatInput, LigneMarcheUncheckedCreateWithoutLigneEtatInput>
    connectOrCreate?: LigneMarcheCreateOrConnectWithoutLigneEtatInput
    upsert?: LigneMarcheUpsertWithoutLigneEtatInput
    connect?: LigneMarcheWhereUniqueInput
    update?: XOR<XOR<LigneMarcheUpdateToOneWithWhereWithoutLigneEtatInput, LigneMarcheUpdateWithoutLigneEtatInput>, LigneMarcheUncheckedUpdateWithoutLigneEtatInput>
  }

  export type LigneEtatCreateNestedManyWithoutLigneMarcheInput = {
    create?: XOR<LigneEtatCreateWithoutLigneMarcheInput, LigneEtatUncheckedCreateWithoutLigneMarcheInput> | LigneEtatCreateWithoutLigneMarcheInput[] | LigneEtatUncheckedCreateWithoutLigneMarcheInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutLigneMarcheInput | LigneEtatCreateOrConnectWithoutLigneMarcheInput[]
    createMany?: LigneEtatCreateManyLigneMarcheInputEnvelope
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
  }

  export type MarcheCreateNestedOneWithoutLigneMarcheInput = {
    create?: XOR<MarcheCreateWithoutLigneMarcheInput, MarcheUncheckedCreateWithoutLigneMarcheInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutLigneMarcheInput
    connect?: MarcheWhereUniqueInput
  }

  export type LigneEtatUncheckedCreateNestedManyWithoutLigneMarcheInput = {
    create?: XOR<LigneEtatCreateWithoutLigneMarcheInput, LigneEtatUncheckedCreateWithoutLigneMarcheInput> | LigneEtatCreateWithoutLigneMarcheInput[] | LigneEtatUncheckedCreateWithoutLigneMarcheInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutLigneMarcheInput | LigneEtatCreateOrConnectWithoutLigneMarcheInput[]
    createMany?: LigneEtatCreateManyLigneMarcheInputEnvelope
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
  }

  export type LigneEtatUpdateManyWithoutLigneMarcheNestedInput = {
    create?: XOR<LigneEtatCreateWithoutLigneMarcheInput, LigneEtatUncheckedCreateWithoutLigneMarcheInput> | LigneEtatCreateWithoutLigneMarcheInput[] | LigneEtatUncheckedCreateWithoutLigneMarcheInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutLigneMarcheInput | LigneEtatCreateOrConnectWithoutLigneMarcheInput[]
    upsert?: LigneEtatUpsertWithWhereUniqueWithoutLigneMarcheInput | LigneEtatUpsertWithWhereUniqueWithoutLigneMarcheInput[]
    createMany?: LigneEtatCreateManyLigneMarcheInputEnvelope
    set?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    disconnect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    delete?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    update?: LigneEtatUpdateWithWhereUniqueWithoutLigneMarcheInput | LigneEtatUpdateWithWhereUniqueWithoutLigneMarcheInput[]
    updateMany?: LigneEtatUpdateManyWithWhereWithoutLigneMarcheInput | LigneEtatUpdateManyWithWhereWithoutLigneMarcheInput[]
    deleteMany?: LigneEtatScalarWhereInput | LigneEtatScalarWhereInput[]
  }

  export type MarcheUpdateOneRequiredWithoutLigneMarcheNestedInput = {
    create?: XOR<MarcheCreateWithoutLigneMarcheInput, MarcheUncheckedCreateWithoutLigneMarcheInput>
    connectOrCreate?: MarcheCreateOrConnectWithoutLigneMarcheInput
    upsert?: MarcheUpsertWithoutLigneMarcheInput
    connect?: MarcheWhereUniqueInput
    update?: XOR<XOR<MarcheUpdateToOneWithWhereWithoutLigneMarcheInput, MarcheUpdateWithoutLigneMarcheInput>, MarcheUncheckedUpdateWithoutLigneMarcheInput>
  }

  export type LigneEtatUncheckedUpdateManyWithoutLigneMarcheNestedInput = {
    create?: XOR<LigneEtatCreateWithoutLigneMarcheInput, LigneEtatUncheckedCreateWithoutLigneMarcheInput> | LigneEtatCreateWithoutLigneMarcheInput[] | LigneEtatUncheckedCreateWithoutLigneMarcheInput[]
    connectOrCreate?: LigneEtatCreateOrConnectWithoutLigneMarcheInput | LigneEtatCreateOrConnectWithoutLigneMarcheInput[]
    upsert?: LigneEtatUpsertWithWhereUniqueWithoutLigneMarcheInput | LigneEtatUpsertWithWhereUniqueWithoutLigneMarcheInput[]
    createMany?: LigneEtatCreateManyLigneMarcheInputEnvelope
    set?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    disconnect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    delete?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    connect?: LigneEtatWhereUniqueInput | LigneEtatWhereUniqueInput[]
    update?: LigneEtatUpdateWithWhereUniqueWithoutLigneMarcheInput | LigneEtatUpdateWithWhereUniqueWithoutLigneMarcheInput[]
    updateMany?: LigneEtatUpdateManyWithWhereWithoutLigneMarcheInput | LigneEtatUpdateManyWithWhereWithoutLigneMarcheInput[]
    deleteMany?: LigneEtatScalarWhereInput | LigneEtatScalarWhereInput[]
  }

  export type pretCreateNestedManyWithoutMachineInput = {
    create?: XOR<pretCreateWithoutMachineInput, pretUncheckedCreateWithoutMachineInput> | pretCreateWithoutMachineInput[] | pretUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: pretCreateOrConnectWithoutMachineInput | pretCreateOrConnectWithoutMachineInput[]
    createMany?: pretCreateManyMachineInputEnvelope
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
  }

  export type pretUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<pretCreateWithoutMachineInput, pretUncheckedCreateWithoutMachineInput> | pretCreateWithoutMachineInput[] | pretUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: pretCreateOrConnectWithoutMachineInput | pretCreateOrConnectWithoutMachineInput[]
    createMany?: pretCreateManyMachineInputEnvelope
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
  }

  export type EnumMachine_statutFieldUpdateOperationsInput = {
    set?: $Enums.Machine_statut
  }

  export type pretUpdateManyWithoutMachineNestedInput = {
    create?: XOR<pretCreateWithoutMachineInput, pretUncheckedCreateWithoutMachineInput> | pretCreateWithoutMachineInput[] | pretUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: pretCreateOrConnectWithoutMachineInput | pretCreateOrConnectWithoutMachineInput[]
    upsert?: pretUpsertWithWhereUniqueWithoutMachineInput | pretUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: pretCreateManyMachineInputEnvelope
    set?: pretWhereUniqueInput | pretWhereUniqueInput[]
    disconnect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    delete?: pretWhereUniqueInput | pretWhereUniqueInput[]
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    update?: pretUpdateWithWhereUniqueWithoutMachineInput | pretUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: pretUpdateManyWithWhereWithoutMachineInput | pretUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: pretScalarWhereInput | pretScalarWhereInput[]
  }

  export type pretUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<pretCreateWithoutMachineInput, pretUncheckedCreateWithoutMachineInput> | pretCreateWithoutMachineInput[] | pretUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: pretCreateOrConnectWithoutMachineInput | pretCreateOrConnectWithoutMachineInput[]
    upsert?: pretUpsertWithWhereUniqueWithoutMachineInput | pretUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: pretCreateManyMachineInputEnvelope
    set?: pretWhereUniqueInput | pretWhereUniqueInput[]
    disconnect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    delete?: pretWhereUniqueInput | pretWhereUniqueInput[]
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    update?: pretUpdateWithWhereUniqueWithoutMachineInput | pretUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: pretUpdateManyWithWhereWithoutMachineInput | pretUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: pretScalarWhereInput | pretScalarWhereInput[]
  }

  export type AvenantCreateNestedManyWithoutMarcheInput = {
    create?: XOR<AvenantCreateWithoutMarcheInput, AvenantUncheckedCreateWithoutMarcheInput> | AvenantCreateWithoutMarcheInput[] | AvenantUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutMarcheInput | AvenantCreateOrConnectWithoutMarcheInput[]
    createMany?: AvenantCreateManyMarcheInputEnvelope
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
  }

  export type LigneMarcheCreateNestedManyWithoutMarcheInput = {
    create?: XOR<LigneMarcheCreateWithoutMarcheInput, LigneMarcheUncheckedCreateWithoutMarcheInput> | LigneMarcheCreateWithoutMarcheInput[] | LigneMarcheUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: LigneMarcheCreateOrConnectWithoutMarcheInput | LigneMarcheCreateOrConnectWithoutMarcheInput[]
    createMany?: LigneMarcheCreateManyMarcheInputEnvelope
    connect?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
  }

  export type ChantierCreateNestedOneWithoutMarchesInput = {
    create?: XOR<ChantierCreateWithoutMarchesInput, ChantierUncheckedCreateWithoutMarchesInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutMarchesInput
    connect?: ChantierWhereUniqueInput
  }

  export type AvenantUncheckedCreateNestedManyWithoutMarcheInput = {
    create?: XOR<AvenantCreateWithoutMarcheInput, AvenantUncheckedCreateWithoutMarcheInput> | AvenantCreateWithoutMarcheInput[] | AvenantUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutMarcheInput | AvenantCreateOrConnectWithoutMarcheInput[]
    createMany?: AvenantCreateManyMarcheInputEnvelope
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
  }

  export type LigneMarcheUncheckedCreateNestedManyWithoutMarcheInput = {
    create?: XOR<LigneMarcheCreateWithoutMarcheInput, LigneMarcheUncheckedCreateWithoutMarcheInput> | LigneMarcheCreateWithoutMarcheInput[] | LigneMarcheUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: LigneMarcheCreateOrConnectWithoutMarcheInput | LigneMarcheCreateOrConnectWithoutMarcheInput[]
    createMany?: LigneMarcheCreateManyMarcheInputEnvelope
    connect?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
  }

  export type AvenantUpdateManyWithoutMarcheNestedInput = {
    create?: XOR<AvenantCreateWithoutMarcheInput, AvenantUncheckedCreateWithoutMarcheInput> | AvenantCreateWithoutMarcheInput[] | AvenantUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutMarcheInput | AvenantCreateOrConnectWithoutMarcheInput[]
    upsert?: AvenantUpsertWithWhereUniqueWithoutMarcheInput | AvenantUpsertWithWhereUniqueWithoutMarcheInput[]
    createMany?: AvenantCreateManyMarcheInputEnvelope
    set?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    disconnect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    delete?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    update?: AvenantUpdateWithWhereUniqueWithoutMarcheInput | AvenantUpdateWithWhereUniqueWithoutMarcheInput[]
    updateMany?: AvenantUpdateManyWithWhereWithoutMarcheInput | AvenantUpdateManyWithWhereWithoutMarcheInput[]
    deleteMany?: AvenantScalarWhereInput | AvenantScalarWhereInput[]
  }

  export type LigneMarcheUpdateManyWithoutMarcheNestedInput = {
    create?: XOR<LigneMarcheCreateWithoutMarcheInput, LigneMarcheUncheckedCreateWithoutMarcheInput> | LigneMarcheCreateWithoutMarcheInput[] | LigneMarcheUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: LigneMarcheCreateOrConnectWithoutMarcheInput | LigneMarcheCreateOrConnectWithoutMarcheInput[]
    upsert?: LigneMarcheUpsertWithWhereUniqueWithoutMarcheInput | LigneMarcheUpsertWithWhereUniqueWithoutMarcheInput[]
    createMany?: LigneMarcheCreateManyMarcheInputEnvelope
    set?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    disconnect?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    delete?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    connect?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    update?: LigneMarcheUpdateWithWhereUniqueWithoutMarcheInput | LigneMarcheUpdateWithWhereUniqueWithoutMarcheInput[]
    updateMany?: LigneMarcheUpdateManyWithWhereWithoutMarcheInput | LigneMarcheUpdateManyWithWhereWithoutMarcheInput[]
    deleteMany?: LigneMarcheScalarWhereInput | LigneMarcheScalarWhereInput[]
  }

  export type ChantierUpdateOneRequiredWithoutMarchesNestedInput = {
    create?: XOR<ChantierCreateWithoutMarchesInput, ChantierUncheckedCreateWithoutMarchesInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutMarchesInput
    upsert?: ChantierUpsertWithoutMarchesInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutMarchesInput, ChantierUpdateWithoutMarchesInput>, ChantierUncheckedUpdateWithoutMarchesInput>
  }

  export type AvenantUncheckedUpdateManyWithoutMarcheNestedInput = {
    create?: XOR<AvenantCreateWithoutMarcheInput, AvenantUncheckedCreateWithoutMarcheInput> | AvenantCreateWithoutMarcheInput[] | AvenantUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: AvenantCreateOrConnectWithoutMarcheInput | AvenantCreateOrConnectWithoutMarcheInput[]
    upsert?: AvenantUpsertWithWhereUniqueWithoutMarcheInput | AvenantUpsertWithWhereUniqueWithoutMarcheInput[]
    createMany?: AvenantCreateManyMarcheInputEnvelope
    set?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    disconnect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    delete?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    connect?: AvenantWhereUniqueInput | AvenantWhereUniqueInput[]
    update?: AvenantUpdateWithWhereUniqueWithoutMarcheInput | AvenantUpdateWithWhereUniqueWithoutMarcheInput[]
    updateMany?: AvenantUpdateManyWithWhereWithoutMarcheInput | AvenantUpdateManyWithWhereWithoutMarcheInput[]
    deleteMany?: AvenantScalarWhereInput | AvenantScalarWhereInput[]
  }

  export type LigneMarcheUncheckedUpdateManyWithoutMarcheNestedInput = {
    create?: XOR<LigneMarcheCreateWithoutMarcheInput, LigneMarcheUncheckedCreateWithoutMarcheInput> | LigneMarcheCreateWithoutMarcheInput[] | LigneMarcheUncheckedCreateWithoutMarcheInput[]
    connectOrCreate?: LigneMarcheCreateOrConnectWithoutMarcheInput | LigneMarcheCreateOrConnectWithoutMarcheInput[]
    upsert?: LigneMarcheUpsertWithWhereUniqueWithoutMarcheInput | LigneMarcheUpsertWithWhereUniqueWithoutMarcheInput[]
    createMany?: LigneMarcheCreateManyMarcheInputEnvelope
    set?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    disconnect?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    delete?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    connect?: LigneMarcheWhereUniqueInput | LigneMarcheWhereUniqueInput[]
    update?: LigneMarcheUpdateWithWhereUniqueWithoutMarcheInput | LigneMarcheUpdateWithWhereUniqueWithoutMarcheInput[]
    updateMany?: LigneMarcheUpdateManyWithWhereWithoutMarcheInput | LigneMarcheUpdateManyWithWhereWithoutMarcheInput[]
    deleteMany?: LigneMarcheScalarWhereInput | LigneMarcheScalarWhereInput[]
  }

  export type ChantierCreateNestedOneWithoutNotesInput = {
    create?: XOR<ChantierCreateWithoutNotesInput, ChantierUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutNotesInput
    connect?: ChantierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNoteInput = {
    create?: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteInput
    connect?: UserWhereUniqueInput
  }

  export type ChantierUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<ChantierCreateWithoutNotesInput, ChantierUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutNotesInput
    upsert?: ChantierUpsertWithoutNotesInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutNotesInput, ChantierUpdateWithoutNotesInput>, ChantierUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteInput
    upsert?: UserUpsertWithoutNoteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteInput, UserUpdateWithoutNoteInput>, UserUncheckedUpdateWithoutNoteInput>
  }

  export type DocumentOuvrierCreateNestedManyWithoutOuvrierInput = {
    create?: XOR<DocumentOuvrierCreateWithoutOuvrierInput, DocumentOuvrierUncheckedCreateWithoutOuvrierInput> | DocumentOuvrierCreateWithoutOuvrierInput[] | DocumentOuvrierUncheckedCreateWithoutOuvrierInput[]
    connectOrCreate?: DocumentOuvrierCreateOrConnectWithoutOuvrierInput | DocumentOuvrierCreateOrConnectWithoutOuvrierInput[]
    createMany?: DocumentOuvrierCreateManyOuvrierInputEnvelope
    connect?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
  }

  export type DocumentOuvrierUncheckedCreateNestedManyWithoutOuvrierInput = {
    create?: XOR<DocumentOuvrierCreateWithoutOuvrierInput, DocumentOuvrierUncheckedCreateWithoutOuvrierInput> | DocumentOuvrierCreateWithoutOuvrierInput[] | DocumentOuvrierUncheckedCreateWithoutOuvrierInput[]
    connectOrCreate?: DocumentOuvrierCreateOrConnectWithoutOuvrierInput | DocumentOuvrierCreateOrConnectWithoutOuvrierInput[]
    createMany?: DocumentOuvrierCreateManyOuvrierInputEnvelope
    connect?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
  }

  export type DocumentOuvrierUpdateManyWithoutOuvrierNestedInput = {
    create?: XOR<DocumentOuvrierCreateWithoutOuvrierInput, DocumentOuvrierUncheckedCreateWithoutOuvrierInput> | DocumentOuvrierCreateWithoutOuvrierInput[] | DocumentOuvrierUncheckedCreateWithoutOuvrierInput[]
    connectOrCreate?: DocumentOuvrierCreateOrConnectWithoutOuvrierInput | DocumentOuvrierCreateOrConnectWithoutOuvrierInput[]
    upsert?: DocumentOuvrierUpsertWithWhereUniqueWithoutOuvrierInput | DocumentOuvrierUpsertWithWhereUniqueWithoutOuvrierInput[]
    createMany?: DocumentOuvrierCreateManyOuvrierInputEnvelope
    set?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    disconnect?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    delete?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    connect?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    update?: DocumentOuvrierUpdateWithWhereUniqueWithoutOuvrierInput | DocumentOuvrierUpdateWithWhereUniqueWithoutOuvrierInput[]
    updateMany?: DocumentOuvrierUpdateManyWithWhereWithoutOuvrierInput | DocumentOuvrierUpdateManyWithWhereWithoutOuvrierInput[]
    deleteMany?: DocumentOuvrierScalarWhereInput | DocumentOuvrierScalarWhereInput[]
  }

  export type DocumentOuvrierUncheckedUpdateManyWithoutOuvrierNestedInput = {
    create?: XOR<DocumentOuvrierCreateWithoutOuvrierInput, DocumentOuvrierUncheckedCreateWithoutOuvrierInput> | DocumentOuvrierCreateWithoutOuvrierInput[] | DocumentOuvrierUncheckedCreateWithoutOuvrierInput[]
    connectOrCreate?: DocumentOuvrierCreateOrConnectWithoutOuvrierInput | DocumentOuvrierCreateOrConnectWithoutOuvrierInput[]
    upsert?: DocumentOuvrierUpsertWithWhereUniqueWithoutOuvrierInput | DocumentOuvrierUpsertWithWhereUniqueWithoutOuvrierInput[]
    createMany?: DocumentOuvrierCreateManyOuvrierInputEnvelope
    set?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    disconnect?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    delete?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    connect?: DocumentOuvrierWhereUniqueInput | DocumentOuvrierWhereUniqueInput[]
    update?: DocumentOuvrierUpdateWithWhereUniqueWithoutOuvrierInput | DocumentOuvrierUpdateWithWhereUniqueWithoutOuvrierInput[]
    updateMany?: DocumentOuvrierUpdateManyWithWhereWithoutOuvrierInput | DocumentOuvrierUpdateManyWithWhereWithoutOuvrierInput[]
    deleteMany?: DocumentOuvrierScalarWhereInput | DocumentOuvrierScalarWhereInput[]
  }

  export type ChantierCreateNestedOneWithoutTachesInput = {
    create?: XOR<ChantierCreateWithoutTachesInput, ChantierUncheckedCreateWithoutTachesInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutTachesInput
    connect?: ChantierWhereUniqueInput
  }

  export type ChantierUpdateOneRequiredWithoutTachesNestedInput = {
    create?: XOR<ChantierCreateWithoutTachesInput, ChantierUncheckedCreateWithoutTachesInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutTachesInput
    upsert?: ChantierUpsertWithoutTachesInput
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutTachesInput, ChantierUpdateWithoutTachesInput>, ChantierUncheckedUpdateWithoutTachesInput>
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type admintaskCreateNestedManyWithoutUserInput = {
    create?: XOR<admintaskCreateWithoutUserInput, admintaskUncheckedCreateWithoutUserInput> | admintaskCreateWithoutUserInput[] | admintaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutUserInput | admintaskCreateOrConnectWithoutUserInput[]
    createMany?: admintaskCreateManyUserInputEnvelope
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
  }

  export type pretCreateNestedManyWithoutUserInput = {
    create?: XOR<pretCreateWithoutUserInput, pretUncheckedCreateWithoutUserInput> | pretCreateWithoutUserInput[] | pretUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pretCreateOrConnectWithoutUserInput | pretCreateOrConnectWithoutUserInput[]
    createMany?: pretCreateManyUserInputEnvelope
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type admintaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<admintaskCreateWithoutUserInput, admintaskUncheckedCreateWithoutUserInput> | admintaskCreateWithoutUserInput[] | admintaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutUserInput | admintaskCreateOrConnectWithoutUserInput[]
    createMany?: admintaskCreateManyUserInputEnvelope
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
  }

  export type pretUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<pretCreateWithoutUserInput, pretUncheckedCreateWithoutUserInput> | pretCreateWithoutUserInput[] | pretUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pretCreateOrConnectWithoutUserInput | pretCreateOrConnectWithoutUserInput[]
    createMany?: pretCreateManyUserInputEnvelope
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
  }

  export type EnumUser_roleFieldUpdateOperationsInput = {
    set?: $Enums.User_role
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type admintaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<admintaskCreateWithoutUserInput, admintaskUncheckedCreateWithoutUserInput> | admintaskCreateWithoutUserInput[] | admintaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutUserInput | admintaskCreateOrConnectWithoutUserInput[]
    upsert?: admintaskUpsertWithWhereUniqueWithoutUserInput | admintaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: admintaskCreateManyUserInputEnvelope
    set?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    disconnect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    delete?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    update?: admintaskUpdateWithWhereUniqueWithoutUserInput | admintaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: admintaskUpdateManyWithWhereWithoutUserInput | admintaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: admintaskScalarWhereInput | admintaskScalarWhereInput[]
  }

  export type pretUpdateManyWithoutUserNestedInput = {
    create?: XOR<pretCreateWithoutUserInput, pretUncheckedCreateWithoutUserInput> | pretCreateWithoutUserInput[] | pretUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pretCreateOrConnectWithoutUserInput | pretCreateOrConnectWithoutUserInput[]
    upsert?: pretUpsertWithWhereUniqueWithoutUserInput | pretUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pretCreateManyUserInputEnvelope
    set?: pretWhereUniqueInput | pretWhereUniqueInput[]
    disconnect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    delete?: pretWhereUniqueInput | pretWhereUniqueInput[]
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    update?: pretUpdateWithWhereUniqueWithoutUserInput | pretUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pretUpdateManyWithWhereWithoutUserInput | pretUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pretScalarWhereInput | pretScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type admintaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<admintaskCreateWithoutUserInput, admintaskUncheckedCreateWithoutUserInput> | admintaskCreateWithoutUserInput[] | admintaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: admintaskCreateOrConnectWithoutUserInput | admintaskCreateOrConnectWithoutUserInput[]
    upsert?: admintaskUpsertWithWhereUniqueWithoutUserInput | admintaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: admintaskCreateManyUserInputEnvelope
    set?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    disconnect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    delete?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    connect?: admintaskWhereUniqueInput | admintaskWhereUniqueInput[]
    update?: admintaskUpdateWithWhereUniqueWithoutUserInput | admintaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: admintaskUpdateManyWithWhereWithoutUserInput | admintaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: admintaskScalarWhereInput | admintaskScalarWhereInput[]
  }

  export type pretUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<pretCreateWithoutUserInput, pretUncheckedCreateWithoutUserInput> | pretCreateWithoutUserInput[] | pretUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pretCreateOrConnectWithoutUserInput | pretCreateOrConnectWithoutUserInput[]
    upsert?: pretUpsertWithWhereUniqueWithoutUserInput | pretUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pretCreateManyUserInputEnvelope
    set?: pretWhereUniqueInput | pretWhereUniqueInput[]
    disconnect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    delete?: pretWhereUniqueInput | pretWhereUniqueInput[]
    connect?: pretWhereUniqueInput | pretWhereUniqueInput[]
    update?: pretUpdateWithWhereUniqueWithoutUserInput | pretUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pretUpdateManyWithWhereWithoutUserInput | pretUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pretScalarWhereInput | pretScalarWhereInput[]
  }

  export type ChantierCreateNestedOneWithoutBonsRegieInput = {
    create?: XOR<ChantierCreateWithoutBonsRegieInput, ChantierUncheckedCreateWithoutBonsRegieInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutBonsRegieInput
    connect?: ChantierWhereUniqueInput
  }

  export type ChantierUpdateOneWithoutBonsRegieNestedInput = {
    create?: XOR<ChantierCreateWithoutBonsRegieInput, ChantierUncheckedCreateWithoutBonsRegieInput>
    connectOrCreate?: ChantierCreateOrConnectWithoutBonsRegieInput
    upsert?: ChantierUpsertWithoutBonsRegieInput
    disconnect?: ChantierWhereInput | boolean
    delete?: ChantierWhereInput | boolean
    connect?: ChantierWhereUniqueInput
    update?: XOR<XOR<ChantierUpdateToOneWithWhereWithoutBonsRegieInput, ChantierUpdateWithoutBonsRegieInput>, ChantierUncheckedUpdateWithoutBonsRegieInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumpret_statutFilter<$PrismaModel = never> = {
    equals?: $Enums.pret_statut | Enumpret_statutFieldRefInput<$PrismaModel>
    in?: $Enums.pret_statut[]
    notIn?: $Enums.pret_statut[]
    not?: NestedEnumpret_statutFilter<$PrismaModel> | $Enums.pret_statut
  }

  export type NestedEnumpret_statutWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pret_statut | Enumpret_statutFieldRefInput<$PrismaModel>
    in?: $Enums.pret_statut[]
    notIn?: $Enums.pret_statut[]
    not?: NestedEnumpret_statutWithAggregatesFilter<$PrismaModel> | $Enums.pret_statut
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpret_statutFilter<$PrismaModel>
    _max?: NestedEnumpret_statutFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMachine_statutFilter<$PrismaModel = never> = {
    equals?: $Enums.Machine_statut | EnumMachine_statutFieldRefInput<$PrismaModel>
    in?: $Enums.Machine_statut[]
    notIn?: $Enums.Machine_statut[]
    not?: NestedEnumMachine_statutFilter<$PrismaModel> | $Enums.Machine_statut
  }

  export type NestedEnumMachine_statutWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Machine_statut | EnumMachine_statutFieldRefInput<$PrismaModel>
    in?: $Enums.Machine_statut[]
    notIn?: $Enums.Machine_statut[]
    not?: NestedEnumMachine_statutWithAggregatesFilter<$PrismaModel> | $Enums.Machine_statut
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMachine_statutFilter<$PrismaModel>
    _max?: NestedEnumMachine_statutFilter<$PrismaModel>
  }

  export type NestedEnumUser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleFilter<$PrismaModel> | $Enums.User_role
  }

  export type NestedEnumUser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleWithAggregatesFilter<$PrismaModel> | $Enums.User_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUser_roleFilter<$PrismaModel>
    _max?: NestedEnumUser_roleFilter<$PrismaModel>
  }

  export type ChantierCreateWithoutAdmintasksInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutAdmintasksInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutAdmintasksInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutAdmintasksInput, ChantierUncheckedCreateWithoutAdmintasksInput>
  }

  export type UserCreateWithoutAdmintaskInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
    pret?: pretCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdmintaskInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
    pret?: pretUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdmintaskInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmintaskInput, UserUncheckedCreateWithoutAdmintaskInput>
  }

  export type ChantierUpsertWithoutAdmintasksInput = {
    update: XOR<ChantierUpdateWithoutAdmintasksInput, ChantierUncheckedUpdateWithoutAdmintasksInput>
    create: XOR<ChantierCreateWithoutAdmintasksInput, ChantierUncheckedCreateWithoutAdmintasksInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutAdmintasksInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutAdmintasksInput, ChantierUncheckedUpdateWithoutAdmintasksInput>
  }

  export type ChantierUpdateWithoutAdmintasksInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutAdmintasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type UserUpsertWithoutAdmintaskInput = {
    update: XOR<UserUpdateWithoutAdmintaskInput, UserUncheckedUpdateWithoutAdmintaskInput>
    create: XOR<UserCreateWithoutAdmintaskInput, UserUncheckedCreateWithoutAdmintaskInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmintaskInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmintaskInput, UserUncheckedUpdateWithoutAdmintaskInput>
  }

  export type UserUpdateWithoutAdmintaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
    pret?: pretUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmintaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
    pret?: pretUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MachineCreateWithoutPretInput = {
    id: string
    nom: string
    modele: string
    numeroSerie?: string | null
    localisation: string
    statut?: $Enums.Machine_statut
    dateAchat?: Date | string | null
    qrCode: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MachineUncheckedCreateWithoutPretInput = {
    id: string
    nom: string
    modele: string
    numeroSerie?: string | null
    localisation: string
    statut?: $Enums.Machine_statut
    dateAchat?: Date | string | null
    qrCode: string
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MachineCreateOrConnectWithoutPretInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutPretInput, MachineUncheckedCreateWithoutPretInput>
  }

  export type UserCreateWithoutPretInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
    admintask?: admintaskCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPretInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
    admintask?: admintaskUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPretInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPretInput, UserUncheckedCreateWithoutPretInput>
  }

  export type MachineUpsertWithoutPretInput = {
    update: XOR<MachineUpdateWithoutPretInput, MachineUncheckedUpdateWithoutPretInput>
    create: XOR<MachineCreateWithoutPretInput, MachineUncheckedCreateWithoutPretInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutPretInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutPretInput, MachineUncheckedUpdateWithoutPretInput>
  }

  export type MachineUpdateWithoutPretInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: StringFieldUpdateOperationsInput | string
    statut?: EnumMachine_statutFieldUpdateOperationsInput | $Enums.Machine_statut
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutPretInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: StringFieldUpdateOperationsInput | string
    statut?: EnumMachine_statutFieldUpdateOperationsInput | $Enums.Machine_statut
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: StringFieldUpdateOperationsInput | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPretInput = {
    update: XOR<UserUpdateWithoutPretInput, UserUncheckedUpdateWithoutPretInput>
    create: XOR<UserCreateWithoutPretInput, UserUncheckedCreateWithoutPretInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPretInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPretInput, UserUncheckedUpdateWithoutPretInput>
  }

  export type UserUpdateWithoutPretInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
    admintask?: admintaskUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPretInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
    admintask?: admintaskUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommandeSousTraitantCreateWithoutSoustraitantInput = {
    chantierId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandeSousTraitantCreateNestedManyWithoutCommandeSousTraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutCommande_soustraitantInput
  }

  export type CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput = {
    id?: number
    chantierId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandeSousTraitantUncheckedCreateNestedManyWithoutCommandeSousTraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutCommande_soustraitantInput
  }

  export type CommandeSousTraitantCreateOrConnectWithoutSoustraitantInput = {
    where: CommandeSousTraitantWhereUniqueInput
    create: XOR<CommandeSousTraitantCreateWithoutSoustraitantInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput>
  }

  export type CommandeSousTraitantCreateManySoustraitantInputEnvelope = {
    data: CommandeSousTraitantCreateManySoustraitantInput | CommandeSousTraitantCreateManySoustraitantInput[]
    skipDuplicates?: boolean
  }

  export type contratCreateWithoutSoustraitantInput = {
    id?: string
    url: string
    dateGeneration?: Date | string
    dateSignature?: Date | string | null
    estSigne?: boolean
    token?: string | null
  }

  export type contratUncheckedCreateWithoutSoustraitantInput = {
    id?: string
    url: string
    dateGeneration?: Date | string
    dateSignature?: Date | string | null
    estSigne?: boolean
    token?: string | null
  }

  export type contratCreateOrConnectWithoutSoustraitantInput = {
    where: contratWhereUniqueInput
    create: XOR<contratCreateWithoutSoustraitantInput, contratUncheckedCreateWithoutSoustraitantInput>
  }

  export type contratCreateManySoustraitantInputEnvelope = {
    data: contratCreateManySoustraitantInput | contratCreateManySoustraitantInput[]
    skipDuplicates?: boolean
  }

  export type soustraitant_etat_avancementCreateWithoutSoustraitantInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    commande_soustraitant?: CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
    etat_avancement: EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput = {
    id?: number
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementCreateOrConnectWithoutSoustraitantInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    create: XOR<soustraitant_etat_avancementCreateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput>
  }

  export type soustraitant_etat_avancementCreateManySoustraitantInputEnvelope = {
    data: soustraitant_etat_avancementCreateManySoustraitantInput | soustraitant_etat_avancementCreateManySoustraitantInput[]
    skipDuplicates?: boolean
  }

  export type CommandeSousTraitantUpsertWithWhereUniqueWithoutSoustraitantInput = {
    where: CommandeSousTraitantWhereUniqueInput
    update: XOR<CommandeSousTraitantUpdateWithoutSoustraitantInput, CommandeSousTraitantUncheckedUpdateWithoutSoustraitantInput>
    create: XOR<CommandeSousTraitantCreateWithoutSoustraitantInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitantInput>
  }

  export type CommandeSousTraitantUpdateWithWhereUniqueWithoutSoustraitantInput = {
    where: CommandeSousTraitantWhereUniqueInput
    data: XOR<CommandeSousTraitantUpdateWithoutSoustraitantInput, CommandeSousTraitantUncheckedUpdateWithoutSoustraitantInput>
  }

  export type CommandeSousTraitantUpdateManyWithWhereWithoutSoustraitantInput = {
    where: CommandeSousTraitantScalarWhereInput
    data: XOR<CommandeSousTraitantUpdateManyMutationInput, CommandeSousTraitantUncheckedUpdateManyWithoutSoustraitantInput>
  }

  export type CommandeSousTraitantScalarWhereInput = {
    AND?: CommandeSousTraitantScalarWhereInput | CommandeSousTraitantScalarWhereInput[]
    OR?: CommandeSousTraitantScalarWhereInput[]
    NOT?: CommandeSousTraitantScalarWhereInput | CommandeSousTraitantScalarWhereInput[]
    id?: IntFilter<"CommandeSousTraitant"> | number
    chantierId?: StringFilter<"CommandeSousTraitant"> | string
    soustraitantId?: StringFilter<"CommandeSousTraitant"> | string
    dateCommande?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    reference?: StringNullableFilter<"CommandeSousTraitant"> | string | null
    tauxTVA?: FloatFilter<"CommandeSousTraitant"> | number
    sousTotal?: FloatFilter<"CommandeSousTraitant"> | number
    tva?: FloatFilter<"CommandeSousTraitant"> | number
    total?: FloatFilter<"CommandeSousTraitant"> | number
    statut?: StringFilter<"CommandeSousTraitant"> | string
    estVerrouillee?: BoolFilter<"CommandeSousTraitant"> | boolean
    createdAt?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeFilter<"CommandeSousTraitant"> | Date | string
  }

  export type contratUpsertWithWhereUniqueWithoutSoustraitantInput = {
    where: contratWhereUniqueInput
    update: XOR<contratUpdateWithoutSoustraitantInput, contratUncheckedUpdateWithoutSoustraitantInput>
    create: XOR<contratCreateWithoutSoustraitantInput, contratUncheckedCreateWithoutSoustraitantInput>
  }

  export type contratUpdateWithWhereUniqueWithoutSoustraitantInput = {
    where: contratWhereUniqueInput
    data: XOR<contratUpdateWithoutSoustraitantInput, contratUncheckedUpdateWithoutSoustraitantInput>
  }

  export type contratUpdateManyWithWhereWithoutSoustraitantInput = {
    where: contratScalarWhereInput
    data: XOR<contratUpdateManyMutationInput, contratUncheckedUpdateManyWithoutSoustraitantInput>
  }

  export type contratScalarWhereInput = {
    AND?: contratScalarWhereInput | contratScalarWhereInput[]
    OR?: contratScalarWhereInput[]
    NOT?: contratScalarWhereInput | contratScalarWhereInput[]
    id?: StringFilter<"contrat"> | string
    soustraitantId?: StringFilter<"contrat"> | string
    url?: StringFilter<"contrat"> | string
    dateGeneration?: DateTimeFilter<"contrat"> | Date | string
    dateSignature?: DateTimeNullableFilter<"contrat"> | Date | string | null
    estSigne?: BoolFilter<"contrat"> | boolean
    token?: StringNullableFilter<"contrat"> | string | null
  }

  export type soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitantInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    update: XOR<soustraitant_etat_avancementUpdateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitantInput>
    create: XOR<soustraitant_etat_avancementCreateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutSoustraitantInput>
  }

  export type soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitantInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    data: XOR<soustraitant_etat_avancementUpdateWithoutSoustraitantInput, soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitantInput>
  }

  export type soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitantInput = {
    where: soustraitant_etat_avancementScalarWhereInput
    data: XOR<soustraitant_etat_avancementUpdateManyMutationInput, soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitantInput>
  }

  export type soustraitant_etat_avancementScalarWhereInput = {
    AND?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
    OR?: soustraitant_etat_avancementScalarWhereInput[]
    NOT?: soustraitant_etat_avancementScalarWhereInput | soustraitant_etat_avancementScalarWhereInput[]
    id?: IntFilter<"soustraitant_etat_avancement"> | number
    soustraitantId?: StringFilter<"soustraitant_etat_avancement"> | string
    numero?: IntFilter<"soustraitant_etat_avancement"> | number
    date?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    commentaires?: StringNullableFilter<"soustraitant_etat_avancement"> | string | null
    estFinalise?: BoolFilter<"soustraitant_etat_avancement"> | boolean
    createdAt?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"soustraitant_etat_avancement"> | Date | string
    commandeSousTraitantId?: IntNullableFilter<"soustraitant_etat_avancement"> | number | null
    etatAvancementId?: IntFilter<"soustraitant_etat_avancement"> | number
  }

  export type soustraitantCreateWithoutContratsInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    commandes?: CommandeSousTraitantCreateNestedManyWithoutSoustraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantUncheckedCreateWithoutContratsInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    commandes?: CommandeSousTraitantUncheckedCreateNestedManyWithoutSoustraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantCreateOrConnectWithoutContratsInput = {
    where: soustraitantWhereUniqueInput
    create: XOR<soustraitantCreateWithoutContratsInput, soustraitantUncheckedCreateWithoutContratsInput>
  }

  export type soustraitantUpsertWithoutContratsInput = {
    update: XOR<soustraitantUpdateWithoutContratsInput, soustraitantUncheckedUpdateWithoutContratsInput>
    create: XOR<soustraitantCreateWithoutContratsInput, soustraitantUncheckedCreateWithoutContratsInput>
    where?: soustraitantWhereInput
  }

  export type soustraitantUpdateToOneWithWhereWithoutContratsInput = {
    where?: soustraitantWhereInput
    data: XOR<soustraitantUpdateWithoutContratsInput, soustraitantUncheckedUpdateWithoutContratsInput>
  }

  export type soustraitantUpdateWithoutContratsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    commandes?: CommandeSousTraitantUpdateManyWithoutSoustraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutSoustraitantNestedInput
  }

  export type soustraitantUncheckedUpdateWithoutContratsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    commandes?: CommandeSousTraitantUncheckedUpdateManyWithoutSoustraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitantNestedInput
  }

  export type LigneCommandeCreateWithoutCommandeInput = {
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeUncheckedCreateWithoutCommandeInput = {
    id?: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeCreateOrConnectWithoutCommandeInput = {
    where: LigneCommandeWhereUniqueInput
    create: XOR<LigneCommandeCreateWithoutCommandeInput, LigneCommandeUncheckedCreateWithoutCommandeInput>
  }

  export type LigneCommandeCreateManyCommandeInputEnvelope = {
    data: LigneCommandeCreateManyCommandeInput | LigneCommandeCreateManyCommandeInput[]
    skipDuplicates?: boolean
  }

  export type LigneCommandeUpsertWithWhereUniqueWithoutCommandeInput = {
    where: LigneCommandeWhereUniqueInput
    update: XOR<LigneCommandeUpdateWithoutCommandeInput, LigneCommandeUncheckedUpdateWithoutCommandeInput>
    create: XOR<LigneCommandeCreateWithoutCommandeInput, LigneCommandeUncheckedCreateWithoutCommandeInput>
  }

  export type LigneCommandeUpdateWithWhereUniqueWithoutCommandeInput = {
    where: LigneCommandeWhereUniqueInput
    data: XOR<LigneCommandeUpdateWithoutCommandeInput, LigneCommandeUncheckedUpdateWithoutCommandeInput>
  }

  export type LigneCommandeUpdateManyWithWhereWithoutCommandeInput = {
    where: LigneCommandeScalarWhereInput
    data: XOR<LigneCommandeUpdateManyMutationInput, LigneCommandeUncheckedUpdateManyWithoutCommandeInput>
  }

  export type LigneCommandeScalarWhereInput = {
    AND?: LigneCommandeScalarWhereInput | LigneCommandeScalarWhereInput[]
    OR?: LigneCommandeScalarWhereInput[]
    NOT?: LigneCommandeScalarWhereInput | LigneCommandeScalarWhereInput[]
    id?: IntFilter<"LigneCommande"> | number
    commandeId?: IntFilter<"LigneCommande"> | number
    ordre?: IntFilter<"LigneCommande"> | number
    article?: StringFilter<"LigneCommande"> | string
    description?: StringFilter<"LigneCommande"> | string
    type?: StringFilter<"LigneCommande"> | string
    unite?: StringFilter<"LigneCommande"> | string
    prixUnitaire?: FloatFilter<"LigneCommande"> | number
    quantite?: FloatFilter<"LigneCommande"> | number
    total?: FloatFilter<"LigneCommande"> | number
    estOption?: BoolFilter<"LigneCommande"> | boolean
    createdAt?: DateTimeFilter<"LigneCommande"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCommande"> | Date | string
  }

  export type CommandeCreateWithoutLignesInput = {
    chantierId: string
    clientId?: string | null
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    totalOptions?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeUncheckedCreateWithoutLignesInput = {
    id?: number
    chantierId: string
    clientId?: string | null
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    totalOptions?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutLignesInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutLignesInput, CommandeUncheckedCreateWithoutLignesInput>
  }

  export type CommandeUpsertWithoutLignesInput = {
    update: XOR<CommandeUpdateWithoutLignesInput, CommandeUncheckedUpdateWithoutLignesInput>
    create: XOR<CommandeCreateWithoutLignesInput, CommandeUncheckedCreateWithoutLignesInput>
    where?: CommandeWhereInput
  }

  export type CommandeUpdateToOneWithWhereWithoutLignesInput = {
    where?: CommandeWhereInput
    data: XOR<CommandeUpdateWithoutLignesInput, CommandeUncheckedUpdateWithoutLignesInput>
  }

  export type CommandeUpdateWithoutLignesInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    totalOptions?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateWithoutLignesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    totalOptions?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantEtatAvancementCreateWithoutEtatAvancementInput = {
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput = {
    id?: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvenantEtatAvancementCreateOrConnectWithoutEtatAvancementInput = {
    where: AvenantEtatAvancementWhereUniqueInput
    create: XOR<AvenantEtatAvancementCreateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput>
  }

  export type AvenantEtatAvancementCreateManyEtatAvancementInputEnvelope = {
    data: AvenantEtatAvancementCreateManyEtatAvancementInput | AvenantEtatAvancementCreateManyEtatAvancementInput[]
    skipDuplicates?: boolean
  }

  export type LigneEtatAvancementCreateWithoutEtatAvancementInput = {
    ligneCommandeId: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
  }

  export type LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput = {
    id?: number
    ligneCommandeId: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
  }

  export type LigneEtatAvancementCreateOrConnectWithoutEtatAvancementInput = {
    where: LigneEtatAvancementWhereUniqueInput
    create: XOR<LigneEtatAvancementCreateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput>
  }

  export type LigneEtatAvancementCreateManyEtatAvancementInputEnvelope = {
    data: LigneEtatAvancementCreateManyEtatAvancementInput | LigneEtatAvancementCreateManyEtatAvancementInput[]
    skipDuplicates?: boolean
  }

  export type soustraitant_etat_avancementCreateWithoutEtat_avancementInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    commande_soustraitant?: CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
    soustraitant: soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementCreateOrConnectWithoutEtat_avancementInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    create: XOR<soustraitant_etat_avancementCreateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput>
  }

  export type soustraitant_etat_avancementCreateManyEtat_avancementInputEnvelope = {
    data: soustraitant_etat_avancementCreateManyEtat_avancementInput | soustraitant_etat_avancementCreateManyEtat_avancementInput[]
    skipDuplicates?: boolean
  }

  export type AvenantEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput = {
    where: AvenantEtatAvancementWhereUniqueInput
    update: XOR<AvenantEtatAvancementUpdateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedUpdateWithoutEtatAvancementInput>
    create: XOR<AvenantEtatAvancementCreateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedCreateWithoutEtatAvancementInput>
  }

  export type AvenantEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput = {
    where: AvenantEtatAvancementWhereUniqueInput
    data: XOR<AvenantEtatAvancementUpdateWithoutEtatAvancementInput, AvenantEtatAvancementUncheckedUpdateWithoutEtatAvancementInput>
  }

  export type AvenantEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput = {
    where: AvenantEtatAvancementScalarWhereInput
    data: XOR<AvenantEtatAvancementUpdateManyMutationInput, AvenantEtatAvancementUncheckedUpdateManyWithoutEtatAvancementInput>
  }

  export type AvenantEtatAvancementScalarWhereInput = {
    AND?: AvenantEtatAvancementScalarWhereInput | AvenantEtatAvancementScalarWhereInput[]
    OR?: AvenantEtatAvancementScalarWhereInput[]
    NOT?: AvenantEtatAvancementScalarWhereInput | AvenantEtatAvancementScalarWhereInput[]
    id?: IntFilter<"AvenantEtatAvancement"> | number
    etatAvancementId?: IntFilter<"AvenantEtatAvancement"> | number
    article?: StringFilter<"AvenantEtatAvancement"> | string
    description?: StringFilter<"AvenantEtatAvancement"> | string
    type?: StringFilter<"AvenantEtatAvancement"> | string
    unite?: StringFilter<"AvenantEtatAvancement"> | string
    prixUnitaire?: FloatFilter<"AvenantEtatAvancement"> | number
    quantite?: FloatFilter<"AvenantEtatAvancement"> | number
    quantitePrecedente?: FloatFilter<"AvenantEtatAvancement"> | number
    quantiteActuelle?: FloatFilter<"AvenantEtatAvancement"> | number
    quantiteTotale?: FloatFilter<"AvenantEtatAvancement"> | number
    montantPrecedent?: FloatFilter<"AvenantEtatAvancement"> | number
    montantActuel?: FloatFilter<"AvenantEtatAvancement"> | number
    montantTotal?: FloatFilter<"AvenantEtatAvancement"> | number
    createdAt?: DateTimeFilter<"AvenantEtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"AvenantEtatAvancement"> | Date | string
  }

  export type LigneEtatAvancementUpsertWithWhereUniqueWithoutEtatAvancementInput = {
    where: LigneEtatAvancementWhereUniqueInput
    update: XOR<LigneEtatAvancementUpdateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedUpdateWithoutEtatAvancementInput>
    create: XOR<LigneEtatAvancementCreateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedCreateWithoutEtatAvancementInput>
  }

  export type LigneEtatAvancementUpdateWithWhereUniqueWithoutEtatAvancementInput = {
    where: LigneEtatAvancementWhereUniqueInput
    data: XOR<LigneEtatAvancementUpdateWithoutEtatAvancementInput, LigneEtatAvancementUncheckedUpdateWithoutEtatAvancementInput>
  }

  export type LigneEtatAvancementUpdateManyWithWhereWithoutEtatAvancementInput = {
    where: LigneEtatAvancementScalarWhereInput
    data: XOR<LigneEtatAvancementUpdateManyMutationInput, LigneEtatAvancementUncheckedUpdateManyWithoutEtatAvancementInput>
  }

  export type LigneEtatAvancementScalarWhereInput = {
    AND?: LigneEtatAvancementScalarWhereInput | LigneEtatAvancementScalarWhereInput[]
    OR?: LigneEtatAvancementScalarWhereInput[]
    NOT?: LigneEtatAvancementScalarWhereInput | LigneEtatAvancementScalarWhereInput[]
    id?: IntFilter<"LigneEtatAvancement"> | number
    etatAvancementId?: IntFilter<"LigneEtatAvancement"> | number
    ligneCommandeId?: IntFilter<"LigneEtatAvancement"> | number
    quantitePrecedente?: FloatFilter<"LigneEtatAvancement"> | number
    quantiteActuelle?: FloatFilter<"LigneEtatAvancement"> | number
    quantiteTotale?: FloatFilter<"LigneEtatAvancement"> | number
    montantPrecedent?: FloatFilter<"LigneEtatAvancement"> | number
    montantActuel?: FloatFilter<"LigneEtatAvancement"> | number
    montantTotal?: FloatFilter<"LigneEtatAvancement"> | number
    createdAt?: DateTimeFilter<"LigneEtatAvancement"> | Date | string
    updatedAt?: DateTimeFilter<"LigneEtatAvancement"> | Date | string
    article?: StringFilter<"LigneEtatAvancement"> | string
    description?: StringFilter<"LigneEtatAvancement"> | string
    prixUnitaire?: FloatFilter<"LigneEtatAvancement"> | number
    quantite?: FloatFilter<"LigneEtatAvancement"> | number
    type?: StringFilter<"LigneEtatAvancement"> | string
    unite?: StringFilter<"LigneEtatAvancement"> | string
  }

  export type soustraitant_etat_avancementUpsertWithWhereUniqueWithoutEtat_avancementInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    update: XOR<soustraitant_etat_avancementUpdateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedUpdateWithoutEtat_avancementInput>
    create: XOR<soustraitant_etat_avancementCreateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutEtat_avancementInput>
  }

  export type soustraitant_etat_avancementUpdateWithWhereUniqueWithoutEtat_avancementInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    data: XOR<soustraitant_etat_avancementUpdateWithoutEtat_avancementInput, soustraitant_etat_avancementUncheckedUpdateWithoutEtat_avancementInput>
  }

  export type soustraitant_etat_avancementUpdateManyWithWhereWithoutEtat_avancementInput = {
    where: soustraitant_etat_avancementScalarWhereInput
    data: XOR<soustraitant_etat_avancementUpdateManyMutationInput, soustraitant_etat_avancementUncheckedUpdateManyWithoutEtat_avancementInput>
  }

  export type EtatAvancementCreateWithoutLignesInput = {
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    avenants?: AvenantEtatAvancementCreateNestedManyWithoutEtatAvancementInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutEtat_avancementInput
  }

  export type EtatAvancementUncheckedCreateWithoutLignesInput = {
    id?: number
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    avenants?: AvenantEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutEtat_avancementInput
  }

  export type EtatAvancementCreateOrConnectWithoutLignesInput = {
    where: EtatAvancementWhereUniqueInput
    create: XOR<EtatAvancementCreateWithoutLignesInput, EtatAvancementUncheckedCreateWithoutLignesInput>
  }

  export type EtatAvancementUpsertWithoutLignesInput = {
    update: XOR<EtatAvancementUpdateWithoutLignesInput, EtatAvancementUncheckedUpdateWithoutLignesInput>
    create: XOR<EtatAvancementCreateWithoutLignesInput, EtatAvancementUncheckedCreateWithoutLignesInput>
    where?: EtatAvancementWhereInput
  }

  export type EtatAvancementUpdateToOneWithWhereWithoutLignesInput = {
    where?: EtatAvancementWhereInput
    data: XOR<EtatAvancementUpdateWithoutLignesInput, EtatAvancementUncheckedUpdateWithoutLignesInput>
  }

  export type EtatAvancementUpdateWithoutLignesInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantEtatAvancementUpdateManyWithoutEtatAvancementNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutEtat_avancementNestedInput
  }

  export type EtatAvancementUncheckedUpdateWithoutLignesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutEtat_avancementNestedInput
  }

  export type EtatAvancementCreateWithoutAvenantsInput = {
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lignes?: LigneEtatAvancementCreateNestedManyWithoutEtatAvancementInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutEtat_avancementInput
  }

  export type EtatAvancementUncheckedCreateWithoutAvenantsInput = {
    id?: number
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lignes?: LigneEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutEtat_avancementInput
  }

  export type EtatAvancementCreateOrConnectWithoutAvenantsInput = {
    where: EtatAvancementWhereUniqueInput
    create: XOR<EtatAvancementCreateWithoutAvenantsInput, EtatAvancementUncheckedCreateWithoutAvenantsInput>
  }

  export type EtatAvancementUpsertWithoutAvenantsInput = {
    update: XOR<EtatAvancementUpdateWithoutAvenantsInput, EtatAvancementUncheckedUpdateWithoutAvenantsInput>
    create: XOR<EtatAvancementCreateWithoutAvenantsInput, EtatAvancementUncheckedCreateWithoutAvenantsInput>
    where?: EtatAvancementWhereInput
  }

  export type EtatAvancementUpdateToOneWithWhereWithoutAvenantsInput = {
    where?: EtatAvancementWhereInput
    data: XOR<EtatAvancementUpdateWithoutAvenantsInput, EtatAvancementUncheckedUpdateWithoutAvenantsInput>
  }

  export type EtatAvancementUpdateWithoutAvenantsInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lignes?: LigneEtatAvancementUpdateManyWithoutEtatAvancementNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutEtat_avancementNestedInput
  }

  export type EtatAvancementUncheckedUpdateWithoutAvenantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lignes?: LigneEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutEtat_avancementNestedInput
  }

  export type soustraitantCreateWithoutCommandesInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    contrats?: contratCreateNestedManyWithoutSoustraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantUncheckedCreateWithoutCommandesInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    contrats?: contratUncheckedCreateNestedManyWithoutSoustraitantInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantCreateOrConnectWithoutCommandesInput = {
    where: soustraitantWhereUniqueInput
    create: XOR<soustraitantCreateWithoutCommandesInput, soustraitantUncheckedCreateWithoutCommandesInput>
  }

  export type LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput = {
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput = {
    id?: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeSousTraitantCreateOrConnectWithoutCommandeSousTraitantInput = {
    where: LigneCommandeSousTraitantWhereUniqueInput
    create: XOR<LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput>
  }

  export type LigneCommandeSousTraitantCreateManyCommandeSousTraitantInputEnvelope = {
    data: LigneCommandeSousTraitantCreateManyCommandeSousTraitantInput | LigneCommandeSousTraitantCreateManyCommandeSousTraitantInput[]
    skipDuplicates?: boolean
  }

  export type soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    etat_avancement: EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput
    soustraitant: soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    etatAvancementId: number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementCreateOrConnectWithoutCommande_soustraitantInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    create: XOR<soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput>
  }

  export type soustraitant_etat_avancementCreateManyCommande_soustraitantInputEnvelope = {
    data: soustraitant_etat_avancementCreateManyCommande_soustraitantInput | soustraitant_etat_avancementCreateManyCommande_soustraitantInput[]
    skipDuplicates?: boolean
  }

  export type soustraitantUpsertWithoutCommandesInput = {
    update: XOR<soustraitantUpdateWithoutCommandesInput, soustraitantUncheckedUpdateWithoutCommandesInput>
    create: XOR<soustraitantCreateWithoutCommandesInput, soustraitantUncheckedCreateWithoutCommandesInput>
    where?: soustraitantWhereInput
  }

  export type soustraitantUpdateToOneWithWhereWithoutCommandesInput = {
    where?: soustraitantWhereInput
    data: XOR<soustraitantUpdateWithoutCommandesInput, soustraitantUncheckedUpdateWithoutCommandesInput>
  }

  export type soustraitantUpdateWithoutCommandesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    contrats?: contratUpdateManyWithoutSoustraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutSoustraitantNestedInput
  }

  export type soustraitantUncheckedUpdateWithoutCommandesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    contrats?: contratUncheckedUpdateManyWithoutSoustraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitantNestedInput
  }

  export type LigneCommandeSousTraitantUpsertWithWhereUniqueWithoutCommandeSousTraitantInput = {
    where: LigneCommandeSousTraitantWhereUniqueInput
    update: XOR<LigneCommandeSousTraitantUpdateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedUpdateWithoutCommandeSousTraitantInput>
    create: XOR<LigneCommandeSousTraitantCreateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedCreateWithoutCommandeSousTraitantInput>
  }

  export type LigneCommandeSousTraitantUpdateWithWhereUniqueWithoutCommandeSousTraitantInput = {
    where: LigneCommandeSousTraitantWhereUniqueInput
    data: XOR<LigneCommandeSousTraitantUpdateWithoutCommandeSousTraitantInput, LigneCommandeSousTraitantUncheckedUpdateWithoutCommandeSousTraitantInput>
  }

  export type LigneCommandeSousTraitantUpdateManyWithWhereWithoutCommandeSousTraitantInput = {
    where: LigneCommandeSousTraitantScalarWhereInput
    data: XOR<LigneCommandeSousTraitantUpdateManyMutationInput, LigneCommandeSousTraitantUncheckedUpdateManyWithoutCommandeSousTraitantInput>
  }

  export type LigneCommandeSousTraitantScalarWhereInput = {
    AND?: LigneCommandeSousTraitantScalarWhereInput | LigneCommandeSousTraitantScalarWhereInput[]
    OR?: LigneCommandeSousTraitantScalarWhereInput[]
    NOT?: LigneCommandeSousTraitantScalarWhereInput | LigneCommandeSousTraitantScalarWhereInput[]
    id?: IntFilter<"LigneCommandeSousTraitant"> | number
    commandeSousTraitantId?: IntFilter<"LigneCommandeSousTraitant"> | number
    ordre?: IntFilter<"LigneCommandeSousTraitant"> | number
    article?: StringFilter<"LigneCommandeSousTraitant"> | string
    description?: StringFilter<"LigneCommandeSousTraitant"> | string
    type?: StringFilter<"LigneCommandeSousTraitant"> | string
    unite?: StringFilter<"LigneCommandeSousTraitant"> | string
    prixUnitaire?: FloatFilter<"LigneCommandeSousTraitant"> | number
    quantite?: FloatFilter<"LigneCommandeSousTraitant"> | number
    total?: FloatFilter<"LigneCommandeSousTraitant"> | number
    createdAt?: DateTimeFilter<"LigneCommandeSousTraitant"> | Date | string
    updatedAt?: DateTimeFilter<"LigneCommandeSousTraitant"> | Date | string
  }

  export type soustraitant_etat_avancementUpsertWithWhereUniqueWithoutCommande_soustraitantInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    update: XOR<soustraitant_etat_avancementUpdateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedUpdateWithoutCommande_soustraitantInput>
    create: XOR<soustraitant_etat_avancementCreateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedCreateWithoutCommande_soustraitantInput>
  }

  export type soustraitant_etat_avancementUpdateWithWhereUniqueWithoutCommande_soustraitantInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    data: XOR<soustraitant_etat_avancementUpdateWithoutCommande_soustraitantInput, soustraitant_etat_avancementUncheckedUpdateWithoutCommande_soustraitantInput>
  }

  export type soustraitant_etat_avancementUpdateManyWithWhereWithoutCommande_soustraitantInput = {
    where: soustraitant_etat_avancementScalarWhereInput
    data: XOR<soustraitant_etat_avancementUpdateManyMutationInput, soustraitant_etat_avancementUncheckedUpdateManyWithoutCommande_soustraitantInput>
  }

  export type CommandeSousTraitantCreateWithoutLignesInput = {
    chantierId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soustraitant: soustraitantCreateNestedOneWithoutCommandesInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementCreateNestedManyWithoutCommande_soustraitantInput
  }

  export type CommandeSousTraitantUncheckedCreateWithoutLignesInput = {
    id?: number
    chantierId: string
    soustraitantId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedCreateNestedManyWithoutCommande_soustraitantInput
  }

  export type CommandeSousTraitantCreateOrConnectWithoutLignesInput = {
    where: CommandeSousTraitantWhereUniqueInput
    create: XOR<CommandeSousTraitantCreateWithoutLignesInput, CommandeSousTraitantUncheckedCreateWithoutLignesInput>
  }

  export type CommandeSousTraitantUpsertWithoutLignesInput = {
    update: XOR<CommandeSousTraitantUpdateWithoutLignesInput, CommandeSousTraitantUncheckedUpdateWithoutLignesInput>
    create: XOR<CommandeSousTraitantCreateWithoutLignesInput, CommandeSousTraitantUncheckedCreateWithoutLignesInput>
    where?: CommandeSousTraitantWhereInput
  }

  export type CommandeSousTraitantUpdateToOneWithWhereWithoutLignesInput = {
    where?: CommandeSousTraitantWhereInput
    data: XOR<CommandeSousTraitantUpdateWithoutLignesInput, CommandeSousTraitantUncheckedUpdateWithoutLignesInput>
  }

  export type CommandeSousTraitantUpdateWithoutLignesInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant?: soustraitantUpdateOneRequiredWithoutCommandesNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutCommande_soustraitantNestedInput
  }

  export type CommandeSousTraitantUncheckedUpdateWithoutLignesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    soustraitantId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutCommande_soustraitantNestedInput
  }

  export type soustraitant_etat_avancementCreateWithoutAvenant_soustraitant_etat_avancementInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    commande_soustraitant?: CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
    etat_avancement: EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput
    soustraitant: soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateWithoutAvenant_soustraitant_etat_avancementInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementCreateOrConnectWithoutAvenant_soustraitant_etat_avancementInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    create: XOR<soustraitant_etat_avancementCreateWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutAvenant_soustraitant_etat_avancementInput>
  }

  export type soustraitant_etat_avancementUpsertWithoutAvenant_soustraitant_etat_avancementInput = {
    update: XOR<soustraitant_etat_avancementUpdateWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedUpdateWithoutAvenant_soustraitant_etat_avancementInput>
    create: XOR<soustraitant_etat_avancementCreateWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutAvenant_soustraitant_etat_avancementInput>
    where?: soustraitant_etat_avancementWhereInput
  }

  export type soustraitant_etat_avancementUpdateToOneWithWhereWithoutAvenant_soustraitant_etat_avancementInput = {
    where?: soustraitant_etat_avancementWhereInput
    data: XOR<soustraitant_etat_avancementUpdateWithoutAvenant_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedUpdateWithoutAvenant_soustraitant_etat_avancementInput>
  }

  export type soustraitant_etat_avancementUpdateWithoutAvenant_soustraitant_etat_avancementInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    commande_soustraitant?: CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput
    etat_avancement?: EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
    soustraitant?: soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateWithoutAvenant_soustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementCreateWithoutLigne_soustraitant_etat_avancementInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    commande_soustraitant?: CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
    etat_avancement: EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput
    soustraitant: soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateWithoutLigne_soustraitant_etat_avancementInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    photos?: photo_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementCreateOrConnectWithoutLigne_soustraitant_etat_avancementInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    create: XOR<soustraitant_etat_avancementCreateWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutLigne_soustraitant_etat_avancementInput>
  }

  export type soustraitant_etat_avancementUpsertWithoutLigne_soustraitant_etat_avancementInput = {
    update: XOR<soustraitant_etat_avancementUpdateWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedUpdateWithoutLigne_soustraitant_etat_avancementInput>
    create: XOR<soustraitant_etat_avancementCreateWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedCreateWithoutLigne_soustraitant_etat_avancementInput>
    where?: soustraitant_etat_avancementWhereInput
  }

  export type soustraitant_etat_avancementUpdateToOneWithWhereWithoutLigne_soustraitant_etat_avancementInput = {
    where?: soustraitant_etat_avancementWhereInput
    data: XOR<soustraitant_etat_avancementUpdateWithoutLigne_soustraitant_etat_avancementInput, soustraitant_etat_avancementUncheckedUpdateWithoutLigne_soustraitant_etat_avancementInput>
  }

  export type soustraitant_etat_avancementUpdateWithoutLigne_soustraitant_etat_avancementInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    commande_soustraitant?: CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput
    etat_avancement?: EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
    soustraitant?: soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateWithoutLigne_soustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput = {
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput = {
    id?: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type avenant_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput = {
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
    create: XOR<avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope = {
    data: avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput | avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput[]
    skipDuplicates?: boolean
  }

  export type ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput = {
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput = {
    id?: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ligne_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput = {
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
    create: XOR<ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope = {
    data: ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput | ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput[]
    skipDuplicates?: boolean
  }

  export type photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput = {
    url: string
    description?: string | null
    dateAjout?: Date | string
  }

  export type photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput = {
    id?: number
    url: string
    description?: string | null
    dateAjout?: Date | string
  }

  export type photo_soustraitant_etat_avancementCreateOrConnectWithoutSoustraitant_etat_avancementInput = {
    where: photo_soustraitant_etat_avancementWhereUniqueInput
    create: XOR<photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInputEnvelope = {
    data: photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput | photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput[]
    skipDuplicates?: boolean
  }

  export type CommandeSousTraitantCreateWithoutSoustraitant_etat_avancementInput = {
    chantierId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    soustraitant: soustraitantCreateNestedOneWithoutCommandesInput
    lignes?: LigneCommandeSousTraitantCreateNestedManyWithoutCommandeSousTraitantInput
  }

  export type CommandeSousTraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput = {
    id?: number
    chantierId: string
    soustraitantId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandeSousTraitantUncheckedCreateNestedManyWithoutCommandeSousTraitantInput
  }

  export type CommandeSousTraitantCreateOrConnectWithoutSoustraitant_etat_avancementInput = {
    where: CommandeSousTraitantWhereUniqueInput
    create: XOR<CommandeSousTraitantCreateWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type EtatAvancementCreateWithoutSoustraitant_etat_avancementInput = {
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    avenants?: AvenantEtatAvancementCreateNestedManyWithoutEtatAvancementInput
    lignes?: LigneEtatAvancementCreateNestedManyWithoutEtatAvancementInput
  }

  export type EtatAvancementUncheckedCreateWithoutSoustraitant_etat_avancementInput = {
    id?: number
    chantierId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    avenants?: AvenantEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput
    lignes?: LigneEtatAvancementUncheckedCreateNestedManyWithoutEtatAvancementInput
  }

  export type EtatAvancementCreateOrConnectWithoutSoustraitant_etat_avancementInput = {
    where: EtatAvancementWhereUniqueInput
    create: XOR<EtatAvancementCreateWithoutSoustraitant_etat_avancementInput, EtatAvancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type soustraitantCreateWithoutSoustraitant_etat_avancementInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    commandes?: CommandeSousTraitantCreateNestedManyWithoutSoustraitantInput
    contrats?: contratCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput = {
    id: string
    nom: string
    email: string
    contact?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    tva?: string | null
    commandes?: CommandeSousTraitantUncheckedCreateNestedManyWithoutSoustraitantInput
    contrats?: contratUncheckedCreateNestedManyWithoutSoustraitantInput
  }

  export type soustraitantCreateOrConnectWithoutSoustraitant_etat_avancementInput = {
    where: soustraitantWhereUniqueInput
    create: XOR<soustraitantCreateWithoutSoustraitant_etat_avancementInput, soustraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type avenant_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput = {
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
    update: XOR<avenant_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
    create: XOR<avenant_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type avenant_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput = {
    where: avenant_soustraitant_etat_avancementWhereUniqueInput
    data: XOR<avenant_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput, avenant_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type avenant_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput = {
    where: avenant_soustraitant_etat_avancementScalarWhereInput
    data: XOR<avenant_soustraitant_etat_avancementUpdateManyMutationInput, avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementInput>
  }

  export type avenant_soustraitant_etat_avancementScalarWhereInput = {
    AND?: avenant_soustraitant_etat_avancementScalarWhereInput | avenant_soustraitant_etat_avancementScalarWhereInput[]
    OR?: avenant_soustraitant_etat_avancementScalarWhereInput[]
    NOT?: avenant_soustraitant_etat_avancementScalarWhereInput | avenant_soustraitant_etat_avancementScalarWhereInput[]
    id?: IntFilter<"avenant_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntFilter<"avenant_soustraitant_etat_avancement"> | number
    article?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    description?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    type?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    unite?: StringFilter<"avenant_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantite?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantActuel?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    montantTotal?: FloatFilter<"avenant_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeFilter<"avenant_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"avenant_soustraitant_etat_avancement"> | Date | string
  }

  export type ligne_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput = {
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
    update: XOR<ligne_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
    create: XOR<ligne_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type ligne_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput = {
    where: ligne_soustraitant_etat_avancementWhereUniqueInput
    data: XOR<ligne_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput, ligne_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type ligne_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput = {
    where: ligne_soustraitant_etat_avancementScalarWhereInput
    data: XOR<ligne_soustraitant_etat_avancementUpdateManyMutationInput, ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementInput>
  }

  export type ligne_soustraitant_etat_avancementScalarWhereInput = {
    AND?: ligne_soustraitant_etat_avancementScalarWhereInput | ligne_soustraitant_etat_avancementScalarWhereInput[]
    OR?: ligne_soustraitant_etat_avancementScalarWhereInput[]
    NOT?: ligne_soustraitant_etat_avancementScalarWhereInput | ligne_soustraitant_etat_avancementScalarWhereInput[]
    id?: IntFilter<"ligne_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntFilter<"ligne_soustraitant_etat_avancement"> | number
    article?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    description?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    type?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    unite?: StringFilter<"ligne_soustraitant_etat_avancement"> | string
    prixUnitaire?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantite?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantitePrecedente?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteActuelle?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    quantiteTotale?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantPrecedent?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantActuel?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    montantTotal?: FloatFilter<"ligne_soustraitant_etat_avancement"> | number
    createdAt?: DateTimeFilter<"ligne_soustraitant_etat_avancement"> | Date | string
    updatedAt?: DateTimeFilter<"ligne_soustraitant_etat_avancement"> | Date | string
  }

  export type photo_soustraitant_etat_avancementUpsertWithWhereUniqueWithoutSoustraitant_etat_avancementInput = {
    where: photo_soustraitant_etat_avancementWhereUniqueInput
    update: XOR<photo_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
    create: XOR<photo_soustraitant_etat_avancementCreateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
  }

  export type photo_soustraitant_etat_avancementUpdateWithWhereUniqueWithoutSoustraitant_etat_avancementInput = {
    where: photo_soustraitant_etat_avancementWhereUniqueInput
    data: XOR<photo_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput, photo_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type photo_soustraitant_etat_avancementUpdateManyWithWhereWithoutSoustraitant_etat_avancementInput = {
    where: photo_soustraitant_etat_avancementScalarWhereInput
    data: XOR<photo_soustraitant_etat_avancementUpdateManyMutationInput, photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementInput>
  }

  export type photo_soustraitant_etat_avancementScalarWhereInput = {
    AND?: photo_soustraitant_etat_avancementScalarWhereInput | photo_soustraitant_etat_avancementScalarWhereInput[]
    OR?: photo_soustraitant_etat_avancementScalarWhereInput[]
    NOT?: photo_soustraitant_etat_avancementScalarWhereInput | photo_soustraitant_etat_avancementScalarWhereInput[]
    id?: IntFilter<"photo_soustraitant_etat_avancement"> | number
    soustraitantEtatAvancementId?: IntFilter<"photo_soustraitant_etat_avancement"> | number
    url?: StringFilter<"photo_soustraitant_etat_avancement"> | string
    description?: StringNullableFilter<"photo_soustraitant_etat_avancement"> | string | null
    dateAjout?: DateTimeFilter<"photo_soustraitant_etat_avancement"> | Date | string
  }

  export type CommandeSousTraitantUpsertWithoutSoustraitant_etat_avancementInput = {
    update: XOR<CommandeSousTraitantUpdateWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
    create: XOR<CommandeSousTraitantCreateWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    where?: CommandeSousTraitantWhereInput
  }

  export type CommandeSousTraitantUpdateToOneWithWhereWithoutSoustraitant_etat_avancementInput = {
    where?: CommandeSousTraitantWhereInput
    data: XOR<CommandeSousTraitantUpdateWithoutSoustraitant_etat_avancementInput, CommandeSousTraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type CommandeSousTraitantUpdateWithoutSoustraitant_etat_avancementInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soustraitant?: soustraitantUpdateOneRequiredWithoutCommandesNestedInput
    lignes?: LigneCommandeSousTraitantUpdateManyWithoutCommandeSousTraitantNestedInput
  }

  export type CommandeSousTraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    soustraitantId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandeSousTraitantUncheckedUpdateManyWithoutCommandeSousTraitantNestedInput
  }

  export type EtatAvancementUpsertWithoutSoustraitant_etat_avancementInput = {
    update: XOR<EtatAvancementUpdateWithoutSoustraitant_etat_avancementInput, EtatAvancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
    create: XOR<EtatAvancementCreateWithoutSoustraitant_etat_avancementInput, EtatAvancementUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    where?: EtatAvancementWhereInput
  }

  export type EtatAvancementUpdateToOneWithWhereWithoutSoustraitant_etat_avancementInput = {
    where?: EtatAvancementWhereInput
    data: XOR<EtatAvancementUpdateWithoutSoustraitant_etat_avancementInput, EtatAvancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type EtatAvancementUpdateWithoutSoustraitant_etat_avancementInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantEtatAvancementUpdateManyWithoutEtatAvancementNestedInput
    lignes?: LigneEtatAvancementUpdateManyWithoutEtatAvancementNestedInput
  }

  export type EtatAvancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput
    lignes?: LigneEtatAvancementUncheckedUpdateManyWithoutEtatAvancementNestedInput
  }

  export type soustraitantUpsertWithoutSoustraitant_etat_avancementInput = {
    update: XOR<soustraitantUpdateWithoutSoustraitant_etat_avancementInput, soustraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
    create: XOR<soustraitantCreateWithoutSoustraitant_etat_avancementInput, soustraitantUncheckedCreateWithoutSoustraitant_etat_avancementInput>
    where?: soustraitantWhereInput
  }

  export type soustraitantUpdateToOneWithWhereWithoutSoustraitant_etat_avancementInput = {
    where?: soustraitantWhereInput
    data: XOR<soustraitantUpdateWithoutSoustraitant_etat_avancementInput, soustraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput>
  }

  export type soustraitantUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    commandes?: CommandeSousTraitantUpdateManyWithoutSoustraitantNestedInput
    contrats?: contratUpdateManyWithoutSoustraitantNestedInput
  }

  export type soustraitantUncheckedUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tva?: NullableStringFieldUpdateOperationsInput | string | null
    commandes?: CommandeSousTraitantUncheckedUpdateManyWithoutSoustraitantNestedInput
    contrats?: contratUncheckedUpdateManyWithoutSoustraitantNestedInput
  }

  export type soustraitant_etat_avancementCreateWithoutPhotosInput = {
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementCreateNestedManyWithoutSoustraitant_etat_avancementInput
    commande_soustraitant?: CommandeSousTraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
    etat_avancement: EtatAvancementCreateNestedOneWithoutSoustraitant_etat_avancementInput
    soustraitant: soustraitantCreateNestedOneWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementUncheckedCreateWithoutPhotosInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedCreateNestedManyWithoutSoustraitant_etat_avancementInput
  }

  export type soustraitant_etat_avancementCreateOrConnectWithoutPhotosInput = {
    where: soustraitant_etat_avancementWhereUniqueInput
    create: XOR<soustraitant_etat_avancementCreateWithoutPhotosInput, soustraitant_etat_avancementUncheckedCreateWithoutPhotosInput>
  }

  export type soustraitant_etat_avancementUpsertWithoutPhotosInput = {
    update: XOR<soustraitant_etat_avancementUpdateWithoutPhotosInput, soustraitant_etat_avancementUncheckedUpdateWithoutPhotosInput>
    create: XOR<soustraitant_etat_avancementCreateWithoutPhotosInput, soustraitant_etat_avancementUncheckedCreateWithoutPhotosInput>
    where?: soustraitant_etat_avancementWhereInput
  }

  export type soustraitant_etat_avancementUpdateToOneWithWhereWithoutPhotosInput = {
    where?: soustraitant_etat_avancementWhereInput
    data: XOR<soustraitant_etat_avancementUpdateWithoutPhotosInput, soustraitant_etat_avancementUncheckedUpdateWithoutPhotosInput>
  }

  export type soustraitant_etat_avancementUpdateWithoutPhotosInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    commande_soustraitant?: CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput
    etat_avancement?: EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
    soustraitant?: soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type EmplacementCreateWithoutRackInput = {
    id?: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materiaux?: MateriauCreateNestedManyWithoutEmplacementInput
  }

  export type EmplacementUncheckedCreateWithoutRackInput = {
    id?: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materiaux?: MateriauUncheckedCreateNestedManyWithoutEmplacementInput
  }

  export type EmplacementCreateOrConnectWithoutRackInput = {
    where: EmplacementWhereUniqueInput
    create: XOR<EmplacementCreateWithoutRackInput, EmplacementUncheckedCreateWithoutRackInput>
  }

  export type EmplacementCreateManyRackInputEnvelope = {
    data: EmplacementCreateManyRackInput | EmplacementCreateManyRackInput[]
    skipDuplicates?: boolean
  }

  export type EmplacementUpsertWithWhereUniqueWithoutRackInput = {
    where: EmplacementWhereUniqueInput
    update: XOR<EmplacementUpdateWithoutRackInput, EmplacementUncheckedUpdateWithoutRackInput>
    create: XOR<EmplacementCreateWithoutRackInput, EmplacementUncheckedCreateWithoutRackInput>
  }

  export type EmplacementUpdateWithWhereUniqueWithoutRackInput = {
    where: EmplacementWhereUniqueInput
    data: XOR<EmplacementUpdateWithoutRackInput, EmplacementUncheckedUpdateWithoutRackInput>
  }

  export type EmplacementUpdateManyWithWhereWithoutRackInput = {
    where: EmplacementScalarWhereInput
    data: XOR<EmplacementUpdateManyMutationInput, EmplacementUncheckedUpdateManyWithoutRackInput>
  }

  export type EmplacementScalarWhereInput = {
    AND?: EmplacementScalarWhereInput | EmplacementScalarWhereInput[]
    OR?: EmplacementScalarWhereInput[]
    NOT?: EmplacementScalarWhereInput | EmplacementScalarWhereInput[]
    id?: StringFilter<"Emplacement"> | string
    rackId?: StringFilter<"Emplacement"> | string
    ligne?: IntFilter<"Emplacement"> | number
    colonne?: IntFilter<"Emplacement"> | number
    codeQR?: StringFilter<"Emplacement"> | string
    statut?: StringFilter<"Emplacement"> | string
    createdAt?: DateTimeFilter<"Emplacement"> | Date | string
    updatedAt?: DateTimeFilter<"Emplacement"> | Date | string
  }

  export type RackCreateWithoutEmplacementsInput = {
    id?: string
    nom: string
    position: string
    lignes: number
    colonnes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RackUncheckedCreateWithoutEmplacementsInput = {
    id?: string
    nom: string
    position: string
    lignes: number
    colonnes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RackCreateOrConnectWithoutEmplacementsInput = {
    where: RackWhereUniqueInput
    create: XOR<RackCreateWithoutEmplacementsInput, RackUncheckedCreateWithoutEmplacementsInput>
  }

  export type MateriauCreateWithoutEmplacementInput = {
    id?: string
    nom: string
    description?: string | null
    quantite?: number
    codeQR?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriauUncheckedCreateWithoutEmplacementInput = {
    id?: string
    nom: string
    description?: string | null
    quantite?: number
    codeQR?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriauCreateOrConnectWithoutEmplacementInput = {
    where: MateriauWhereUniqueInput
    create: XOR<MateriauCreateWithoutEmplacementInput, MateriauUncheckedCreateWithoutEmplacementInput>
  }

  export type MateriauCreateManyEmplacementInputEnvelope = {
    data: MateriauCreateManyEmplacementInput | MateriauCreateManyEmplacementInput[]
    skipDuplicates?: boolean
  }

  export type RackUpsertWithoutEmplacementsInput = {
    update: XOR<RackUpdateWithoutEmplacementsInput, RackUncheckedUpdateWithoutEmplacementsInput>
    create: XOR<RackCreateWithoutEmplacementsInput, RackUncheckedCreateWithoutEmplacementsInput>
    where?: RackWhereInput
  }

  export type RackUpdateToOneWithWhereWithoutEmplacementsInput = {
    where?: RackWhereInput
    data: XOR<RackUpdateWithoutEmplacementsInput, RackUncheckedUpdateWithoutEmplacementsInput>
  }

  export type RackUpdateWithoutEmplacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    lignes?: IntFieldUpdateOperationsInput | number
    colonnes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RackUncheckedUpdateWithoutEmplacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    lignes?: IntFieldUpdateOperationsInput | number
    colonnes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauUpsertWithWhereUniqueWithoutEmplacementInput = {
    where: MateriauWhereUniqueInput
    update: XOR<MateriauUpdateWithoutEmplacementInput, MateriauUncheckedUpdateWithoutEmplacementInput>
    create: XOR<MateriauCreateWithoutEmplacementInput, MateriauUncheckedCreateWithoutEmplacementInput>
  }

  export type MateriauUpdateWithWhereUniqueWithoutEmplacementInput = {
    where: MateriauWhereUniqueInput
    data: XOR<MateriauUpdateWithoutEmplacementInput, MateriauUncheckedUpdateWithoutEmplacementInput>
  }

  export type MateriauUpdateManyWithWhereWithoutEmplacementInput = {
    where: MateriauScalarWhereInput
    data: XOR<MateriauUpdateManyMutationInput, MateriauUncheckedUpdateManyWithoutEmplacementInput>
  }

  export type MateriauScalarWhereInput = {
    AND?: MateriauScalarWhereInput | MateriauScalarWhereInput[]
    OR?: MateriauScalarWhereInput[]
    NOT?: MateriauScalarWhereInput | MateriauScalarWhereInput[]
    id?: StringFilter<"Materiau"> | string
    nom?: StringFilter<"Materiau"> | string
    description?: StringNullableFilter<"Materiau"> | string | null
    quantite?: IntFilter<"Materiau"> | number
    codeQR?: StringNullableFilter<"Materiau"> | string | null
    emplacementId?: StringNullableFilter<"Materiau"> | string | null
    createdAt?: DateTimeFilter<"Materiau"> | Date | string
    updatedAt?: DateTimeFilter<"Materiau"> | Date | string
  }

  export type EmplacementCreateWithoutMateriauxInput = {
    id?: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rack: RackCreateNestedOneWithoutEmplacementsInput
  }

  export type EmplacementUncheckedCreateWithoutMateriauxInput = {
    id?: string
    rackId: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmplacementCreateOrConnectWithoutMateriauxInput = {
    where: EmplacementWhereUniqueInput
    create: XOR<EmplacementCreateWithoutMateriauxInput, EmplacementUncheckedCreateWithoutMateriauxInput>
  }

  export type EmplacementUpsertWithoutMateriauxInput = {
    update: XOR<EmplacementUpdateWithoutMateriauxInput, EmplacementUncheckedUpdateWithoutMateriauxInput>
    create: XOR<EmplacementCreateWithoutMateriauxInput, EmplacementUncheckedCreateWithoutMateriauxInput>
    where?: EmplacementWhereInput
  }

  export type EmplacementUpdateToOneWithWhereWithoutMateriauxInput = {
    where?: EmplacementWhereInput
    data: XOR<EmplacementUpdateWithoutMateriauxInput, EmplacementUncheckedUpdateWithoutMateriauxInput>
  }

  export type EmplacementUpdateWithoutMateriauxInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rack?: RackUpdateOneRequiredWithoutEmplacementsNestedInput
  }

  export type EmplacementUncheckedUpdateWithoutMateriauxInput = {
    id?: StringFieldUpdateOperationsInput | string
    rackId?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChantierCreateWithoutAvenantsInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutAvenantsInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutAvenantsInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutAvenantsInput, ChantierUncheckedCreateWithoutAvenantsInput>
  }

  export type MarcheCreateWithoutAvenantInput = {
    dateImport?: Date | string
    montantTotal: number
    LigneMarche?: LigneMarcheCreateNestedManyWithoutMarcheInput
    Chantier: ChantierCreateNestedOneWithoutMarchesInput
  }

  export type MarcheUncheckedCreateWithoutAvenantInput = {
    id?: number
    chantierId: string
    dateImport?: Date | string
    montantTotal: number
    LigneMarche?: LigneMarcheUncheckedCreateNestedManyWithoutMarcheInput
  }

  export type MarcheCreateOrConnectWithoutAvenantInput = {
    where: MarcheWhereUniqueInput
    create: XOR<MarcheCreateWithoutAvenantInput, MarcheUncheckedCreateWithoutAvenantInput>
  }

  export type ChantierUpsertWithoutAvenantsInput = {
    update: XOR<ChantierUpdateWithoutAvenantsInput, ChantierUncheckedUpdateWithoutAvenantsInput>
    create: XOR<ChantierCreateWithoutAvenantsInput, ChantierUncheckedCreateWithoutAvenantsInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutAvenantsInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutAvenantsInput, ChantierUncheckedUpdateWithoutAvenantsInput>
  }

  export type ChantierUpdateWithoutAvenantsInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutAvenantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type MarcheUpsertWithoutAvenantInput = {
    update: XOR<MarcheUpdateWithoutAvenantInput, MarcheUncheckedUpdateWithoutAvenantInput>
    create: XOR<MarcheCreateWithoutAvenantInput, MarcheUncheckedCreateWithoutAvenantInput>
    where?: MarcheWhereInput
  }

  export type MarcheUpdateToOneWithWhereWithoutAvenantInput = {
    where?: MarcheWhereInput
    data: XOR<MarcheUpdateWithoutAvenantInput, MarcheUncheckedUpdateWithoutAvenantInput>
  }

  export type MarcheUpdateWithoutAvenantInput = {
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    LigneMarche?: LigneMarcheUpdateManyWithoutMarcheNestedInput
    Chantier?: ChantierUpdateOneRequiredWithoutMarchesNestedInput
  }

  export type MarcheUncheckedUpdateWithoutAvenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    LigneMarche?: LigneMarcheUncheckedUpdateManyWithoutMarcheNestedInput
  }

  export type AvenantCreateWithoutChantierInput = {
    numero: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Marche: MarcheCreateNestedOneWithoutAvenantInput
  }

  export type AvenantUncheckedCreateWithoutChantierInput = {
    id?: number
    numero: number
    date?: Date | string
    description?: string | null
    marcheId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AvenantCreateOrConnectWithoutChantierInput = {
    where: AvenantWhereUniqueInput
    create: XOR<AvenantCreateWithoutChantierInput, AvenantUncheckedCreateWithoutChantierInput>
  }

  export type AvenantCreateManyChantierInputEnvelope = {
    data: AvenantCreateManyChantierInput | AvenantCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutChantierInput = {
    id: string
    nom: string
    email?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ClientUncheckedCreateWithoutChantierInput = {
    id: string
    nom: string
    email?: string | null
    adresse?: string | null
    telephone?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ClientCreateOrConnectWithoutChantierInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutChantierInput, ClientUncheckedCreateWithoutChantierInput>
  }

  export type DocumentCreateWithoutChantierInput = {
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    User: UserCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutChantierInput = {
    id?: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentCreateOrConnectWithoutChantierInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutChantierInput, DocumentUncheckedCreateWithoutChantierInput>
  }

  export type DocumentCreateManyChantierInputEnvelope = {
    data: DocumentCreateManyChantierInput | DocumentCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type EtatCreateWithoutChantierInput = {
    numero: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    LigneEtat?: LigneEtatCreateNestedManyWithoutEtatInput
  }

  export type EtatUncheckedCreateWithoutChantierInput = {
    id?: number
    numero: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    LigneEtat?: LigneEtatUncheckedCreateNestedManyWithoutEtatInput
  }

  export type EtatCreateOrConnectWithoutChantierInput = {
    where: EtatWhereUniqueInput
    create: XOR<EtatCreateWithoutChantierInput, EtatUncheckedCreateWithoutChantierInput>
  }

  export type EtatCreateManyChantierInputEnvelope = {
    data: EtatCreateManyChantierInput | EtatCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type MarcheCreateWithoutChantierInput = {
    dateImport?: Date | string
    montantTotal: number
    Avenant?: AvenantCreateNestedManyWithoutMarcheInput
    LigneMarche?: LigneMarcheCreateNestedManyWithoutMarcheInput
  }

  export type MarcheUncheckedCreateWithoutChantierInput = {
    id?: number
    dateImport?: Date | string
    montantTotal: number
    Avenant?: AvenantUncheckedCreateNestedManyWithoutMarcheInput
    LigneMarche?: LigneMarcheUncheckedCreateNestedManyWithoutMarcheInput
  }

  export type MarcheCreateOrConnectWithoutChantierInput = {
    where: MarcheWhereUniqueInput
    create: XOR<MarcheCreateWithoutChantierInput, MarcheUncheckedCreateWithoutChantierInput>
  }

  export type NoteCreateWithoutChantierInput = {
    contenu: string
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutChantierInput = {
    id?: number
    contenu: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NoteCreateOrConnectWithoutChantierInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutChantierInput, NoteUncheckedCreateWithoutChantierInput>
  }

  export type NoteCreateManyChantierInputEnvelope = {
    data: NoteCreateManyChantierInput | NoteCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type TacheCreateWithoutChantierInput = {
    id: string
    label: string
    completed?: boolean
    completedAt?: Date | string | null
    category: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TacheUncheckedCreateWithoutChantierInput = {
    id: string
    label: string
    completed?: boolean
    completedAt?: Date | string | null
    category: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TacheCreateOrConnectWithoutChantierInput = {
    where: TacheWhereUniqueInput
    create: XOR<TacheCreateWithoutChantierInput, TacheUncheckedCreateWithoutChantierInput>
  }

  export type TacheCreateManyChantierInputEnvelope = {
    data: TacheCreateManyChantierInput | TacheCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type admintaskCreateWithoutChantierInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
    user?: UserCreateNestedOneWithoutAdmintaskInput
  }

  export type admintaskUncheckedCreateWithoutChantierInput = {
    id?: number
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
  }

  export type admintaskCreateOrConnectWithoutChantierInput = {
    where: admintaskWhereUniqueInput
    create: XOR<admintaskCreateWithoutChantierInput, admintaskUncheckedCreateWithoutChantierInput>
  }

  export type admintaskCreateManyChantierInputEnvelope = {
    data: admintaskCreateManyChantierInput | admintaskCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type BonRegieCreateWithoutChantierInput = {
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation?: number | null
    tempsTrajets?: number | null
    tempsChantier?: number | null
    nombreTechniciens?: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonRegieUncheckedCreateWithoutChantierInput = {
    id?: number
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation?: number | null
    tempsTrajets?: number | null
    tempsChantier?: number | null
    nombreTechniciens?: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BonRegieCreateOrConnectWithoutChantierInput = {
    where: BonRegieWhereUniqueInput
    create: XOR<BonRegieCreateWithoutChantierInput, BonRegieUncheckedCreateWithoutChantierInput>
  }

  export type BonRegieCreateManyChantierInputEnvelope = {
    data: BonRegieCreateManyChantierInput | BonRegieCreateManyChantierInput[]
    skipDuplicates?: boolean
  }

  export type AvenantUpsertWithWhereUniqueWithoutChantierInput = {
    where: AvenantWhereUniqueInput
    update: XOR<AvenantUpdateWithoutChantierInput, AvenantUncheckedUpdateWithoutChantierInput>
    create: XOR<AvenantCreateWithoutChantierInput, AvenantUncheckedCreateWithoutChantierInput>
  }

  export type AvenantUpdateWithWhereUniqueWithoutChantierInput = {
    where: AvenantWhereUniqueInput
    data: XOR<AvenantUpdateWithoutChantierInput, AvenantUncheckedUpdateWithoutChantierInput>
  }

  export type AvenantUpdateManyWithWhereWithoutChantierInput = {
    where: AvenantScalarWhereInput
    data: XOR<AvenantUpdateManyMutationInput, AvenantUncheckedUpdateManyWithoutChantierInput>
  }

  export type AvenantScalarWhereInput = {
    AND?: AvenantScalarWhereInput | AvenantScalarWhereInput[]
    OR?: AvenantScalarWhereInput[]
    NOT?: AvenantScalarWhereInput | AvenantScalarWhereInput[]
    id?: IntFilter<"Avenant"> | number
    numero?: IntFilter<"Avenant"> | number
    date?: DateTimeFilter<"Avenant"> | Date | string
    description?: StringNullableFilter<"Avenant"> | string | null
    chantierId?: StringFilter<"Avenant"> | string
    marcheId?: IntFilter<"Avenant"> | number
    createdAt?: DateTimeFilter<"Avenant"> | Date | string
    updatedAt?: DateTimeFilter<"Avenant"> | Date | string
  }

  export type ClientUpsertWithoutChantierInput = {
    update: XOR<ClientUpdateWithoutChantierInput, ClientUncheckedUpdateWithoutChantierInput>
    create: XOR<ClientCreateWithoutChantierInput, ClientUncheckedCreateWithoutChantierInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutChantierInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutChantierInput, ClientUncheckedUpdateWithoutChantierInput>
  }

  export type ClientUpdateWithoutChantierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateWithoutChantierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutChantierInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutChantierInput, DocumentUncheckedUpdateWithoutChantierInput>
    create: XOR<DocumentCreateWithoutChantierInput, DocumentUncheckedCreateWithoutChantierInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutChantierInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutChantierInput, DocumentUncheckedUpdateWithoutChantierInput>
  }

  export type DocumentUpdateManyWithWhereWithoutChantierInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutChantierInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    nom?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    taille?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    chantierId?: StringFilter<"Document"> | string
    createdBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    metadata?: JsonNullableFilter<"Document">
  }

  export type EtatUpsertWithWhereUniqueWithoutChantierInput = {
    where: EtatWhereUniqueInput
    update: XOR<EtatUpdateWithoutChantierInput, EtatUncheckedUpdateWithoutChantierInput>
    create: XOR<EtatCreateWithoutChantierInput, EtatUncheckedCreateWithoutChantierInput>
  }

  export type EtatUpdateWithWhereUniqueWithoutChantierInput = {
    where: EtatWhereUniqueInput
    data: XOR<EtatUpdateWithoutChantierInput, EtatUncheckedUpdateWithoutChantierInput>
  }

  export type EtatUpdateManyWithWhereWithoutChantierInput = {
    where: EtatScalarWhereInput
    data: XOR<EtatUpdateManyMutationInput, EtatUncheckedUpdateManyWithoutChantierInput>
  }

  export type EtatScalarWhereInput = {
    AND?: EtatScalarWhereInput | EtatScalarWhereInput[]
    OR?: EtatScalarWhereInput[]
    NOT?: EtatScalarWhereInput | EtatScalarWhereInput[]
    id?: IntFilter<"Etat"> | number
    numero?: IntFilter<"Etat"> | number
    date?: DateTimeFilter<"Etat"> | Date | string
    chantierId?: StringFilter<"Etat"> | string
    createdAt?: DateTimeFilter<"Etat"> | Date | string
    updatedAt?: DateTimeFilter<"Etat"> | Date | string
  }

  export type MarcheUpsertWithoutChantierInput = {
    update: XOR<MarcheUpdateWithoutChantierInput, MarcheUncheckedUpdateWithoutChantierInput>
    create: XOR<MarcheCreateWithoutChantierInput, MarcheUncheckedCreateWithoutChantierInput>
    where?: MarcheWhereInput
  }

  export type MarcheUpdateToOneWithWhereWithoutChantierInput = {
    where?: MarcheWhereInput
    data: XOR<MarcheUpdateWithoutChantierInput, MarcheUncheckedUpdateWithoutChantierInput>
  }

  export type MarcheUpdateWithoutChantierInput = {
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    Avenant?: AvenantUpdateManyWithoutMarcheNestedInput
    LigneMarche?: LigneMarcheUpdateManyWithoutMarcheNestedInput
  }

  export type MarcheUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    Avenant?: AvenantUncheckedUpdateManyWithoutMarcheNestedInput
    LigneMarche?: LigneMarcheUncheckedUpdateManyWithoutMarcheNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutChantierInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutChantierInput, NoteUncheckedUpdateWithoutChantierInput>
    create: XOR<NoteCreateWithoutChantierInput, NoteUncheckedCreateWithoutChantierInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutChantierInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutChantierInput, NoteUncheckedUpdateWithoutChantierInput>
  }

  export type NoteUpdateManyWithWhereWithoutChantierInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutChantierInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: IntFilter<"Note"> | number
    chantierId?: StringFilter<"Note"> | string
    contenu?: StringFilter<"Note"> | string
    createdBy?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type TacheUpsertWithWhereUniqueWithoutChantierInput = {
    where: TacheWhereUniqueInput
    update: XOR<TacheUpdateWithoutChantierInput, TacheUncheckedUpdateWithoutChantierInput>
    create: XOR<TacheCreateWithoutChantierInput, TacheUncheckedCreateWithoutChantierInput>
  }

  export type TacheUpdateWithWhereUniqueWithoutChantierInput = {
    where: TacheWhereUniqueInput
    data: XOR<TacheUpdateWithoutChantierInput, TacheUncheckedUpdateWithoutChantierInput>
  }

  export type TacheUpdateManyWithWhereWithoutChantierInput = {
    where: TacheScalarWhereInput
    data: XOR<TacheUpdateManyMutationInput, TacheUncheckedUpdateManyWithoutChantierInput>
  }

  export type TacheScalarWhereInput = {
    AND?: TacheScalarWhereInput | TacheScalarWhereInput[]
    OR?: TacheScalarWhereInput[]
    NOT?: TacheScalarWhereInput | TacheScalarWhereInput[]
    id?: StringFilter<"Tache"> | string
    label?: StringFilter<"Tache"> | string
    completed?: BoolFilter<"Tache"> | boolean
    completedAt?: DateTimeNullableFilter<"Tache"> | Date | string | null
    chantierId?: StringFilter<"Tache"> | string
    category?: StringFilter<"Tache"> | string
    createdAt?: DateTimeFilter<"Tache"> | Date | string
    updatedAt?: DateTimeFilter<"Tache"> | Date | string
  }

  export type admintaskUpsertWithWhereUniqueWithoutChantierInput = {
    where: admintaskWhereUniqueInput
    update: XOR<admintaskUpdateWithoutChantierInput, admintaskUncheckedUpdateWithoutChantierInput>
    create: XOR<admintaskCreateWithoutChantierInput, admintaskUncheckedCreateWithoutChantierInput>
  }

  export type admintaskUpdateWithWhereUniqueWithoutChantierInput = {
    where: admintaskWhereUniqueInput
    data: XOR<admintaskUpdateWithoutChantierInput, admintaskUncheckedUpdateWithoutChantierInput>
  }

  export type admintaskUpdateManyWithWhereWithoutChantierInput = {
    where: admintaskScalarWhereInput
    data: XOR<admintaskUpdateManyMutationInput, admintaskUncheckedUpdateManyWithoutChantierInput>
  }

  export type admintaskScalarWhereInput = {
    AND?: admintaskScalarWhereInput | admintaskScalarWhereInput[]
    OR?: admintaskScalarWhereInput[]
    NOT?: admintaskScalarWhereInput | admintaskScalarWhereInput[]
    id?: IntFilter<"admintask"> | number
    chantierId?: StringFilter<"admintask"> | string
    completedBy?: StringNullableFilter<"admintask"> | string | null
    createdAt?: DateTimeFilter<"admintask"> | Date | string
    updatedAt?: DateTimeFilter<"admintask"> | Date | string
    completed?: BoolFilter<"admintask"> | boolean
    completedAt?: DateTimeNullableFilter<"admintask"> | Date | string | null
    taskType?: StringFilter<"admintask"> | string
    title?: StringNullableFilter<"admintask"> | string | null
  }

  export type BonRegieUpsertWithWhereUniqueWithoutChantierInput = {
    where: BonRegieWhereUniqueInput
    update: XOR<BonRegieUpdateWithoutChantierInput, BonRegieUncheckedUpdateWithoutChantierInput>
    create: XOR<BonRegieCreateWithoutChantierInput, BonRegieUncheckedCreateWithoutChantierInput>
  }

  export type BonRegieUpdateWithWhereUniqueWithoutChantierInput = {
    where: BonRegieWhereUniqueInput
    data: XOR<BonRegieUpdateWithoutChantierInput, BonRegieUncheckedUpdateWithoutChantierInput>
  }

  export type BonRegieUpdateManyWithWhereWithoutChantierInput = {
    where: BonRegieScalarWhereInput
    data: XOR<BonRegieUpdateManyMutationInput, BonRegieUncheckedUpdateManyWithoutChantierInput>
  }

  export type BonRegieScalarWhereInput = {
    AND?: BonRegieScalarWhereInput | BonRegieScalarWhereInput[]
    OR?: BonRegieScalarWhereInput[]
    NOT?: BonRegieScalarWhereInput | BonRegieScalarWhereInput[]
    id?: IntFilter<"BonRegie"> | number
    dates?: StringFilter<"BonRegie"> | string
    client?: StringFilter<"BonRegie"> | string
    nomChantier?: StringFilter<"BonRegie"> | string
    description?: StringFilter<"BonRegie"> | string
    tempsPreparation?: FloatNullableFilter<"BonRegie"> | number | null
    tempsTrajets?: FloatNullableFilter<"BonRegie"> | number | null
    tempsChantier?: FloatNullableFilter<"BonRegie"> | number | null
    nombreTechniciens?: IntNullableFilter<"BonRegie"> | number | null
    materiaux?: StringFilter<"BonRegie"> | string
    nomSignataire?: StringFilter<"BonRegie"> | string
    signature?: StringFilter<"BonRegie"> | string
    dateSignature?: DateTimeFilter<"BonRegie"> | Date | string
    createdAt?: DateTimeFilter<"BonRegie"> | Date | string
    updatedAt?: DateTimeFilter<"BonRegie"> | Date | string
    chantierId?: StringNullableFilter<"BonRegie"> | string | null
  }

  export type ChantierCreateWithoutClientInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutClientInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutClientInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutClientInput, ChantierUncheckedCreateWithoutClientInput>
  }

  export type ChantierCreateManyClientInputEnvelope = {
    data: ChantierCreateManyClientInput | ChantierCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ChantierUpsertWithWhereUniqueWithoutClientInput = {
    where: ChantierWhereUniqueInput
    update: XOR<ChantierUpdateWithoutClientInput, ChantierUncheckedUpdateWithoutClientInput>
    create: XOR<ChantierCreateWithoutClientInput, ChantierUncheckedCreateWithoutClientInput>
  }

  export type ChantierUpdateWithWhereUniqueWithoutClientInput = {
    where: ChantierWhereUniqueInput
    data: XOR<ChantierUpdateWithoutClientInput, ChantierUncheckedUpdateWithoutClientInput>
  }

  export type ChantierUpdateManyWithWhereWithoutClientInput = {
    where: ChantierScalarWhereInput
    data: XOR<ChantierUpdateManyMutationInput, ChantierUncheckedUpdateManyWithoutClientInput>
  }

  export type ChantierScalarWhereInput = {
    AND?: ChantierScalarWhereInput | ChantierScalarWhereInput[]
    OR?: ChantierScalarWhereInput[]
    NOT?: ChantierScalarWhereInput | ChantierScalarWhereInput[]
    id?: IntFilter<"Chantier"> | number
    chantierId?: StringFilter<"Chantier"> | string
    nomChantier?: StringFilter<"Chantier"> | string
    adresseChantier?: StringNullableFilter<"Chantier"> | string | null
    createdAt?: DateTimeFilter<"Chantier"> | Date | string
    updatedAt?: DateTimeFilter<"Chantier"> | Date | string
    clientId?: StringNullableFilter<"Chantier"> | string | null
    budget?: FloatNullableFilter<"Chantier"> | number | null
    dateDebut?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    dateFinPrevue?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    dateFinReelle?: DateTimeNullableFilter<"Chantier"> | Date | string | null
    description?: StringNullableFilter<"Chantier"> | string | null
    statut?: StringFilter<"Chantier"> | string
    villeChantier?: StringNullableFilter<"Chantier"> | string | null
    dureeEnJours?: IntNullableFilter<"Chantier"> | number | null
    typeDuree?: StringFilter<"Chantier"> | string
  }

  export type ChantierCreateWithoutDocumentsInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutDocumentsInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutDocumentsInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutDocumentsInput, ChantierUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDocumentInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Note?: NoteCreateNestedManyWithoutUserInput
    admintask?: admintaskCreateNestedManyWithoutUserInput
    pret?: pretCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
    admintask?: admintaskUncheckedCreateNestedManyWithoutUserInput
    pret?: pretUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
  }

  export type ChantierUpsertWithoutDocumentsInput = {
    update: XOR<ChantierUpdateWithoutDocumentsInput, ChantierUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ChantierCreateWithoutDocumentsInput, ChantierUncheckedCreateWithoutDocumentsInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutDocumentsInput, ChantierUncheckedUpdateWithoutDocumentsInput>
  }

  export type ChantierUpdateWithoutDocumentsInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type UserUpsertWithoutDocumentInput = {
    update: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type UserUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NoteUpdateManyWithoutUserNestedInput
    admintask?: admintaskUpdateManyWithoutUserNestedInput
    pret?: pretUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
    admintask?: admintaskUncheckedUpdateManyWithoutUserNestedInput
    pret?: pretUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OuvrierCreateWithoutDocumentOuvrierInput = {
    id: string
    nom: string
    prenom: string
    email?: string | null
    telephone?: string | null
    dateEntree: Date | string
    poste: string
    sousTraitantId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type OuvrierUncheckedCreateWithoutDocumentOuvrierInput = {
    id: string
    nom: string
    prenom: string
    email?: string | null
    telephone?: string | null
    dateEntree: Date | string
    poste: string
    sousTraitantId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type OuvrierCreateOrConnectWithoutDocumentOuvrierInput = {
    where: OuvrierWhereUniqueInput
    create: XOR<OuvrierCreateWithoutDocumentOuvrierInput, OuvrierUncheckedCreateWithoutDocumentOuvrierInput>
  }

  export type OuvrierUpsertWithoutDocumentOuvrierInput = {
    update: XOR<OuvrierUpdateWithoutDocumentOuvrierInput, OuvrierUncheckedUpdateWithoutDocumentOuvrierInput>
    create: XOR<OuvrierCreateWithoutDocumentOuvrierInput, OuvrierUncheckedCreateWithoutDocumentOuvrierInput>
    where?: OuvrierWhereInput
  }

  export type OuvrierUpdateToOneWithWhereWithoutDocumentOuvrierInput = {
    where?: OuvrierWhereInput
    data: XOR<OuvrierUpdateWithoutDocumentOuvrierInput, OuvrierUncheckedUpdateWithoutDocumentOuvrierInput>
  }

  export type OuvrierUpdateWithoutDocumentOuvrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    poste?: StringFieldUpdateOperationsInput | string
    sousTraitantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OuvrierUncheckedUpdateWithoutDocumentOuvrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    poste?: StringFieldUpdateOperationsInput | string
    sousTraitantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChantierCreateWithoutEtatsInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutEtatsInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutEtatsInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutEtatsInput, ChantierUncheckedCreateWithoutEtatsInput>
  }

  export type LigneEtatCreateWithoutEtatInput = {
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
    LigneMarche: LigneMarcheCreateNestedOneWithoutLigneEtatInput
  }

  export type LigneEtatUncheckedCreateWithoutEtatInput = {
    id?: number
    ligneMarcheId: number
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneEtatCreateOrConnectWithoutEtatInput = {
    where: LigneEtatWhereUniqueInput
    create: XOR<LigneEtatCreateWithoutEtatInput, LigneEtatUncheckedCreateWithoutEtatInput>
  }

  export type LigneEtatCreateManyEtatInputEnvelope = {
    data: LigneEtatCreateManyEtatInput | LigneEtatCreateManyEtatInput[]
    skipDuplicates?: boolean
  }

  export type ChantierUpsertWithoutEtatsInput = {
    update: XOR<ChantierUpdateWithoutEtatsInput, ChantierUncheckedUpdateWithoutEtatsInput>
    create: XOR<ChantierCreateWithoutEtatsInput, ChantierUncheckedCreateWithoutEtatsInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutEtatsInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutEtatsInput, ChantierUncheckedUpdateWithoutEtatsInput>
  }

  export type ChantierUpdateWithoutEtatsInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutEtatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type LigneEtatUpsertWithWhereUniqueWithoutEtatInput = {
    where: LigneEtatWhereUniqueInput
    update: XOR<LigneEtatUpdateWithoutEtatInput, LigneEtatUncheckedUpdateWithoutEtatInput>
    create: XOR<LigneEtatCreateWithoutEtatInput, LigneEtatUncheckedCreateWithoutEtatInput>
  }

  export type LigneEtatUpdateWithWhereUniqueWithoutEtatInput = {
    where: LigneEtatWhereUniqueInput
    data: XOR<LigneEtatUpdateWithoutEtatInput, LigneEtatUncheckedUpdateWithoutEtatInput>
  }

  export type LigneEtatUpdateManyWithWhereWithoutEtatInput = {
    where: LigneEtatScalarWhereInput
    data: XOR<LigneEtatUpdateManyMutationInput, LigneEtatUncheckedUpdateManyWithoutEtatInput>
  }

  export type LigneEtatScalarWhereInput = {
    AND?: LigneEtatScalarWhereInput | LigneEtatScalarWhereInput[]
    OR?: LigneEtatScalarWhereInput[]
    NOT?: LigneEtatScalarWhereInput | LigneEtatScalarWhereInput[]
    id?: IntFilter<"LigneEtat"> | number
    etatId?: IntFilter<"LigneEtat"> | number
    ligneMarcheId?: IntFilter<"LigneEtat"> | number
    quantite?: FloatFilter<"LigneEtat"> | number
    createdAt?: DateTimeFilter<"LigneEtat"> | Date | string
    updatedAt?: DateTimeFilter<"LigneEtat"> | Date | string
  }

  export type EtatCreateWithoutLigneEtatInput = {
    numero: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutEtatsInput
  }

  export type EtatUncheckedCreateWithoutLigneEtatInput = {
    id?: number
    numero: number
    date: Date | string
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type EtatCreateOrConnectWithoutLigneEtatInput = {
    where: EtatWhereUniqueInput
    create: XOR<EtatCreateWithoutLigneEtatInput, EtatUncheckedCreateWithoutLigneEtatInput>
  }

  export type LigneMarcheCreateWithoutLigneEtatInput = {
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    Marche: MarcheCreateNestedOneWithoutLigneMarcheInput
  }

  export type LigneMarcheUncheckedCreateWithoutLigneEtatInput = {
    id?: number
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    marcheId: number
  }

  export type LigneMarcheCreateOrConnectWithoutLigneEtatInput = {
    where: LigneMarcheWhereUniqueInput
    create: XOR<LigneMarcheCreateWithoutLigneEtatInput, LigneMarcheUncheckedCreateWithoutLigneEtatInput>
  }

  export type EtatUpsertWithoutLigneEtatInput = {
    update: XOR<EtatUpdateWithoutLigneEtatInput, EtatUncheckedUpdateWithoutLigneEtatInput>
    create: XOR<EtatCreateWithoutLigneEtatInput, EtatUncheckedCreateWithoutLigneEtatInput>
    where?: EtatWhereInput
  }

  export type EtatUpdateToOneWithWhereWithoutLigneEtatInput = {
    where?: EtatWhereInput
    data: XOR<EtatUpdateWithoutLigneEtatInput, EtatUncheckedUpdateWithoutLigneEtatInput>
  }

  export type EtatUpdateWithoutLigneEtatInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutEtatsNestedInput
  }

  export type EtatUncheckedUpdateWithoutLigneEtatInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneMarcheUpsertWithoutLigneEtatInput = {
    update: XOR<LigneMarcheUpdateWithoutLigneEtatInput, LigneMarcheUncheckedUpdateWithoutLigneEtatInput>
    create: XOR<LigneMarcheCreateWithoutLigneEtatInput, LigneMarcheUncheckedCreateWithoutLigneEtatInput>
    where?: LigneMarcheWhereInput
  }

  export type LigneMarcheUpdateToOneWithWhereWithoutLigneEtatInput = {
    where?: LigneMarcheWhereInput
    data: XOR<LigneMarcheUpdateWithoutLigneEtatInput, LigneMarcheUncheckedUpdateWithoutLigneEtatInput>
  }

  export type LigneMarcheUpdateWithoutLigneEtatInput = {
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    Marche?: MarcheUpdateOneRequiredWithoutLigneMarcheNestedInput
  }

  export type LigneMarcheUncheckedUpdateWithoutLigneEtatInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    marcheId?: IntFieldUpdateOperationsInput | number
  }

  export type LigneEtatCreateWithoutLigneMarcheInput = {
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
    Etat: EtatCreateNestedOneWithoutLigneEtatInput
  }

  export type LigneEtatUncheckedCreateWithoutLigneMarcheInput = {
    id?: number
    etatId: number
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneEtatCreateOrConnectWithoutLigneMarcheInput = {
    where: LigneEtatWhereUniqueInput
    create: XOR<LigneEtatCreateWithoutLigneMarcheInput, LigneEtatUncheckedCreateWithoutLigneMarcheInput>
  }

  export type LigneEtatCreateManyLigneMarcheInputEnvelope = {
    data: LigneEtatCreateManyLigneMarcheInput | LigneEtatCreateManyLigneMarcheInput[]
    skipDuplicates?: boolean
  }

  export type MarcheCreateWithoutLigneMarcheInput = {
    dateImport?: Date | string
    montantTotal: number
    Avenant?: AvenantCreateNestedManyWithoutMarcheInput
    Chantier: ChantierCreateNestedOneWithoutMarchesInput
  }

  export type MarcheUncheckedCreateWithoutLigneMarcheInput = {
    id?: number
    chantierId: string
    dateImport?: Date | string
    montantTotal: number
    Avenant?: AvenantUncheckedCreateNestedManyWithoutMarcheInput
  }

  export type MarcheCreateOrConnectWithoutLigneMarcheInput = {
    where: MarcheWhereUniqueInput
    create: XOR<MarcheCreateWithoutLigneMarcheInput, MarcheUncheckedCreateWithoutLigneMarcheInput>
  }

  export type LigneEtatUpsertWithWhereUniqueWithoutLigneMarcheInput = {
    where: LigneEtatWhereUniqueInput
    update: XOR<LigneEtatUpdateWithoutLigneMarcheInput, LigneEtatUncheckedUpdateWithoutLigneMarcheInput>
    create: XOR<LigneEtatCreateWithoutLigneMarcheInput, LigneEtatUncheckedCreateWithoutLigneMarcheInput>
  }

  export type LigneEtatUpdateWithWhereUniqueWithoutLigneMarcheInput = {
    where: LigneEtatWhereUniqueInput
    data: XOR<LigneEtatUpdateWithoutLigneMarcheInput, LigneEtatUncheckedUpdateWithoutLigneMarcheInput>
  }

  export type LigneEtatUpdateManyWithWhereWithoutLigneMarcheInput = {
    where: LigneEtatScalarWhereInput
    data: XOR<LigneEtatUpdateManyMutationInput, LigneEtatUncheckedUpdateManyWithoutLigneMarcheInput>
  }

  export type MarcheUpsertWithoutLigneMarcheInput = {
    update: XOR<MarcheUpdateWithoutLigneMarcheInput, MarcheUncheckedUpdateWithoutLigneMarcheInput>
    create: XOR<MarcheCreateWithoutLigneMarcheInput, MarcheUncheckedCreateWithoutLigneMarcheInput>
    where?: MarcheWhereInput
  }

  export type MarcheUpdateToOneWithWhereWithoutLigneMarcheInput = {
    where?: MarcheWhereInput
    data: XOR<MarcheUpdateWithoutLigneMarcheInput, MarcheUncheckedUpdateWithoutLigneMarcheInput>
  }

  export type MarcheUpdateWithoutLigneMarcheInput = {
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    Avenant?: AvenantUpdateManyWithoutMarcheNestedInput
    Chantier?: ChantierUpdateOneRequiredWithoutMarchesNestedInput
  }

  export type MarcheUncheckedUpdateWithoutLigneMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    dateImport?: DateTimeFieldUpdateOperationsInput | Date | string
    montantTotal?: FloatFieldUpdateOperationsInput | number
    Avenant?: AvenantUncheckedUpdateManyWithoutMarcheNestedInput
  }

  export type pretCreateWithoutMachineInput = {
    id: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
    user: UserCreateNestedOneWithoutPretInput
  }

  export type pretUncheckedCreateWithoutMachineInput = {
    id: string
    userId: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
  }

  export type pretCreateOrConnectWithoutMachineInput = {
    where: pretWhereUniqueInput
    create: XOR<pretCreateWithoutMachineInput, pretUncheckedCreateWithoutMachineInput>
  }

  export type pretCreateManyMachineInputEnvelope = {
    data: pretCreateManyMachineInput | pretCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type pretUpsertWithWhereUniqueWithoutMachineInput = {
    where: pretWhereUniqueInput
    update: XOR<pretUpdateWithoutMachineInput, pretUncheckedUpdateWithoutMachineInput>
    create: XOR<pretCreateWithoutMachineInput, pretUncheckedCreateWithoutMachineInput>
  }

  export type pretUpdateWithWhereUniqueWithoutMachineInput = {
    where: pretWhereUniqueInput
    data: XOR<pretUpdateWithoutMachineInput, pretUncheckedUpdateWithoutMachineInput>
  }

  export type pretUpdateManyWithWhereWithoutMachineInput = {
    where: pretScalarWhereInput
    data: XOR<pretUpdateManyMutationInput, pretUncheckedUpdateManyWithoutMachineInput>
  }

  export type pretScalarWhereInput = {
    AND?: pretScalarWhereInput | pretScalarWhereInput[]
    OR?: pretScalarWhereInput[]
    NOT?: pretScalarWhereInput | pretScalarWhereInput[]
    id?: StringFilter<"pret"> | string
    machineId?: StringFilter<"pret"> | string
    userId?: StringFilter<"pret"> | string
    datePret?: DateTimeFilter<"pret"> | Date | string
    dateRetourPrevue?: DateTimeFilter<"pret"> | Date | string
    dateRetourEffective?: DateTimeNullableFilter<"pret"> | Date | string | null
    statut?: Enumpret_statutFilter<"pret"> | $Enums.pret_statut
    commentaire?: StringNullableFilter<"pret"> | string | null
    createdAt?: DateTimeFilter<"pret"> | Date | string
    updatedAt?: DateTimeFilter<"pret"> | Date | string
    emprunteur?: StringFilter<"pret"> | string
  }

  export type AvenantCreateWithoutMarcheInput = {
    numero: number
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutAvenantsInput
  }

  export type AvenantUncheckedCreateWithoutMarcheInput = {
    id?: number
    numero: number
    date?: Date | string
    description?: string | null
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AvenantCreateOrConnectWithoutMarcheInput = {
    where: AvenantWhereUniqueInput
    create: XOR<AvenantCreateWithoutMarcheInput, AvenantUncheckedCreateWithoutMarcheInput>
  }

  export type AvenantCreateManyMarcheInputEnvelope = {
    data: AvenantCreateManyMarcheInput | AvenantCreateManyMarcheInput[]
    skipDuplicates?: boolean
  }

  export type LigneMarcheCreateWithoutMarcheInput = {
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    LigneEtat?: LigneEtatCreateNestedManyWithoutLigneMarcheInput
  }

  export type LigneMarcheUncheckedCreateWithoutMarcheInput = {
    id?: number
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
    LigneEtat?: LigneEtatUncheckedCreateNestedManyWithoutLigneMarcheInput
  }

  export type LigneMarcheCreateOrConnectWithoutMarcheInput = {
    where: LigneMarcheWhereUniqueInput
    create: XOR<LigneMarcheCreateWithoutMarcheInput, LigneMarcheUncheckedCreateWithoutMarcheInput>
  }

  export type LigneMarcheCreateManyMarcheInputEnvelope = {
    data: LigneMarcheCreateManyMarcheInput | LigneMarcheCreateManyMarcheInput[]
    skipDuplicates?: boolean
  }

  export type ChantierCreateWithoutMarchesInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutMarchesInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutMarchesInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutMarchesInput, ChantierUncheckedCreateWithoutMarchesInput>
  }

  export type AvenantUpsertWithWhereUniqueWithoutMarcheInput = {
    where: AvenantWhereUniqueInput
    update: XOR<AvenantUpdateWithoutMarcheInput, AvenantUncheckedUpdateWithoutMarcheInput>
    create: XOR<AvenantCreateWithoutMarcheInput, AvenantUncheckedCreateWithoutMarcheInput>
  }

  export type AvenantUpdateWithWhereUniqueWithoutMarcheInput = {
    where: AvenantWhereUniqueInput
    data: XOR<AvenantUpdateWithoutMarcheInput, AvenantUncheckedUpdateWithoutMarcheInput>
  }

  export type AvenantUpdateManyWithWhereWithoutMarcheInput = {
    where: AvenantScalarWhereInput
    data: XOR<AvenantUpdateManyMutationInput, AvenantUncheckedUpdateManyWithoutMarcheInput>
  }

  export type LigneMarcheUpsertWithWhereUniqueWithoutMarcheInput = {
    where: LigneMarcheWhereUniqueInput
    update: XOR<LigneMarcheUpdateWithoutMarcheInput, LigneMarcheUncheckedUpdateWithoutMarcheInput>
    create: XOR<LigneMarcheCreateWithoutMarcheInput, LigneMarcheUncheckedCreateWithoutMarcheInput>
  }

  export type LigneMarcheUpdateWithWhereUniqueWithoutMarcheInput = {
    where: LigneMarcheWhereUniqueInput
    data: XOR<LigneMarcheUpdateWithoutMarcheInput, LigneMarcheUncheckedUpdateWithoutMarcheInput>
  }

  export type LigneMarcheUpdateManyWithWhereWithoutMarcheInput = {
    where: LigneMarcheScalarWhereInput
    data: XOR<LigneMarcheUpdateManyMutationInput, LigneMarcheUncheckedUpdateManyWithoutMarcheInput>
  }

  export type LigneMarcheScalarWhereInput = {
    AND?: LigneMarcheScalarWhereInput | LigneMarcheScalarWhereInput[]
    OR?: LigneMarcheScalarWhereInput[]
    NOT?: LigneMarcheScalarWhereInput | LigneMarcheScalarWhereInput[]
    id?: IntFilter<"LigneMarche"> | number
    article?: IntFilter<"LigneMarche"> | number
    descriptif?: StringFilter<"LigneMarche"> | string
    unite?: StringFilter<"LigneMarche"> | string
    quantite?: FloatFilter<"LigneMarche"> | number
    prixUnitaire?: FloatFilter<"LigneMarche"> | number
    marcheId?: IntFilter<"LigneMarche"> | number
  }

  export type ChantierUpsertWithoutMarchesInput = {
    update: XOR<ChantierUpdateWithoutMarchesInput, ChantierUncheckedUpdateWithoutMarchesInput>
    create: XOR<ChantierCreateWithoutMarchesInput, ChantierUncheckedCreateWithoutMarchesInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutMarchesInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutMarchesInput, ChantierUncheckedUpdateWithoutMarchesInput>
  }

  export type ChantierUpdateWithoutMarchesInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutMarchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type ChantierCreateWithoutNotesInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutNotesInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutNotesInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutNotesInput, ChantierUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNoteInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentCreateNestedManyWithoutUserInput
    admintask?: admintaskCreateNestedManyWithoutUserInput
    pret?: pretCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoteInput = {
    id: string
    email: string
    password: string
    role?: $Enums.User_role
    createdAt?: Date | string
    updatedAt: Date | string
    name?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    admintask?: admintaskUncheckedCreateNestedManyWithoutUserInput
    pret?: pretUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNoteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
  }

  export type ChantierUpsertWithoutNotesInput = {
    update: XOR<ChantierUpdateWithoutNotesInput, ChantierUncheckedUpdateWithoutNotesInput>
    create: XOR<ChantierCreateWithoutNotesInput, ChantierUncheckedCreateWithoutNotesInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutNotesInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutNotesInput, ChantierUncheckedUpdateWithoutNotesInput>
  }

  export type ChantierUpdateWithoutNotesInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type UserUpsertWithoutNoteInput = {
    update: XOR<UserUpdateWithoutNoteInput, UserUncheckedUpdateWithoutNoteInput>
    create: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteInput, UserUncheckedUpdateWithoutNoteInput>
  }

  export type UserUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUpdateManyWithoutUserNestedInput
    admintask?: admintaskUpdateManyWithoutUserNestedInput
    pret?: pretUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    admintask?: admintaskUncheckedUpdateManyWithoutUserNestedInput
    pret?: pretUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentOuvrierCreateWithoutOuvrierInput = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentOuvrierUncheckedCreateWithoutOuvrierInput = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentOuvrierCreateOrConnectWithoutOuvrierInput = {
    where: DocumentOuvrierWhereUniqueInput
    create: XOR<DocumentOuvrierCreateWithoutOuvrierInput, DocumentOuvrierUncheckedCreateWithoutOuvrierInput>
  }

  export type DocumentOuvrierCreateManyOuvrierInputEnvelope = {
    data: DocumentOuvrierCreateManyOuvrierInput | DocumentOuvrierCreateManyOuvrierInput[]
    skipDuplicates?: boolean
  }

  export type DocumentOuvrierUpsertWithWhereUniqueWithoutOuvrierInput = {
    where: DocumentOuvrierWhereUniqueInput
    update: XOR<DocumentOuvrierUpdateWithoutOuvrierInput, DocumentOuvrierUncheckedUpdateWithoutOuvrierInput>
    create: XOR<DocumentOuvrierCreateWithoutOuvrierInput, DocumentOuvrierUncheckedCreateWithoutOuvrierInput>
  }

  export type DocumentOuvrierUpdateWithWhereUniqueWithoutOuvrierInput = {
    where: DocumentOuvrierWhereUniqueInput
    data: XOR<DocumentOuvrierUpdateWithoutOuvrierInput, DocumentOuvrierUncheckedUpdateWithoutOuvrierInput>
  }

  export type DocumentOuvrierUpdateManyWithWhereWithoutOuvrierInput = {
    where: DocumentOuvrierScalarWhereInput
    data: XOR<DocumentOuvrierUpdateManyMutationInput, DocumentOuvrierUncheckedUpdateManyWithoutOuvrierInput>
  }

  export type DocumentOuvrierScalarWhereInput = {
    AND?: DocumentOuvrierScalarWhereInput | DocumentOuvrierScalarWhereInput[]
    OR?: DocumentOuvrierScalarWhereInput[]
    NOT?: DocumentOuvrierScalarWhereInput | DocumentOuvrierScalarWhereInput[]
    id?: StringFilter<"DocumentOuvrier"> | string
    nom?: StringFilter<"DocumentOuvrier"> | string
    type?: StringFilter<"DocumentOuvrier"> | string
    url?: StringFilter<"DocumentOuvrier"> | string
    dateExpiration?: DateTimeNullableFilter<"DocumentOuvrier"> | Date | string | null
    ouvrierId?: StringFilter<"DocumentOuvrier"> | string
    createdAt?: DateTimeFilter<"DocumentOuvrier"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentOuvrier"> | Date | string
  }

  export type ChantierCreateWithoutTachesInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutTachesInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
    bonsRegie?: BonRegieUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutTachesInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutTachesInput, ChantierUncheckedCreateWithoutTachesInput>
  }

  export type ChantierUpsertWithoutTachesInput = {
    update: XOR<ChantierUpdateWithoutTachesInput, ChantierUncheckedUpdateWithoutTachesInput>
    create: XOR<ChantierCreateWithoutTachesInput, ChantierUncheckedCreateWithoutTachesInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutTachesInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutTachesInput, ChantierUncheckedUpdateWithoutTachesInput>
  }

  export type ChantierUpdateWithoutTachesInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutTachesInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type DocumentCreateWithoutUserInput = {
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    chantier: ChantierCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutUserInput = {
    contenu: string
    createdAt?: Date | string
    updatedAt: Date | string
    Chantier: ChantierCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutUserInput = {
    id?: number
    chantierId: string
    contenu: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NoteCreateOrConnectWithoutUserInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteCreateManyUserInputEnvelope = {
    data: NoteCreateManyUserInput | NoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type admintaskCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
    chantier: ChantierCreateNestedOneWithoutAdmintasksInput
  }

  export type admintaskUncheckedCreateWithoutUserInput = {
    id?: number
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
  }

  export type admintaskCreateOrConnectWithoutUserInput = {
    where: admintaskWhereUniqueInput
    create: XOR<admintaskCreateWithoutUserInput, admintaskUncheckedCreateWithoutUserInput>
  }

  export type admintaskCreateManyUserInputEnvelope = {
    data: admintaskCreateManyUserInput | admintaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type pretCreateWithoutUserInput = {
    id: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
    machine: MachineCreateNestedOneWithoutPretInput
  }

  export type pretUncheckedCreateWithoutUserInput = {
    id: string
    machineId: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
  }

  export type pretCreateOrConnectWithoutUserInput = {
    where: pretWhereUniqueInput
    create: XOR<pretCreateWithoutUserInput, pretUncheckedCreateWithoutUserInput>
  }

  export type pretCreateManyUserInputEnvelope = {
    data: pretCreateManyUserInput | pretCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
  }

  export type NoteUpdateManyWithWhereWithoutUserInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutUserInput>
  }

  export type admintaskUpsertWithWhereUniqueWithoutUserInput = {
    where: admintaskWhereUniqueInput
    update: XOR<admintaskUpdateWithoutUserInput, admintaskUncheckedUpdateWithoutUserInput>
    create: XOR<admintaskCreateWithoutUserInput, admintaskUncheckedCreateWithoutUserInput>
  }

  export type admintaskUpdateWithWhereUniqueWithoutUserInput = {
    where: admintaskWhereUniqueInput
    data: XOR<admintaskUpdateWithoutUserInput, admintaskUncheckedUpdateWithoutUserInput>
  }

  export type admintaskUpdateManyWithWhereWithoutUserInput = {
    where: admintaskScalarWhereInput
    data: XOR<admintaskUpdateManyMutationInput, admintaskUncheckedUpdateManyWithoutUserInput>
  }

  export type pretUpsertWithWhereUniqueWithoutUserInput = {
    where: pretWhereUniqueInput
    update: XOR<pretUpdateWithoutUserInput, pretUncheckedUpdateWithoutUserInput>
    create: XOR<pretCreateWithoutUserInput, pretUncheckedCreateWithoutUserInput>
  }

  export type pretUpdateWithWhereUniqueWithoutUserInput = {
    where: pretWhereUniqueInput
    data: XOR<pretUpdateWithoutUserInput, pretUncheckedUpdateWithoutUserInput>
  }

  export type pretUpdateManyWithWhereWithoutUserInput = {
    where: pretScalarWhereInput
    data: XOR<pretUpdateManyMutationInput, pretUncheckedUpdateManyWithoutUserInput>
  }

  export type ChantierCreateWithoutBonsRegieInput = {
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantCreateNestedManyWithoutChantierInput
    client?: ClientCreateNestedOneWithoutChantierInput
    documents?: DocumentCreateNestedManyWithoutChantierInput
    etats?: EtatCreateNestedManyWithoutChantierInput
    marches?: MarcheCreateNestedOneWithoutChantierInput
    notes?: NoteCreateNestedManyWithoutChantierInput
    taches?: TacheCreateNestedManyWithoutChantierInput
    admintasks?: admintaskCreateNestedManyWithoutChantierInput
  }

  export type ChantierUncheckedCreateWithoutBonsRegieInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clientId?: string | null
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
    avenants?: AvenantUncheckedCreateNestedManyWithoutChantierInput
    documents?: DocumentUncheckedCreateNestedManyWithoutChantierInput
    etats?: EtatUncheckedCreateNestedManyWithoutChantierInput
    marches?: MarcheUncheckedCreateNestedOneWithoutChantierInput
    notes?: NoteUncheckedCreateNestedManyWithoutChantierInput
    taches?: TacheUncheckedCreateNestedManyWithoutChantierInput
    admintasks?: admintaskUncheckedCreateNestedManyWithoutChantierInput
  }

  export type ChantierCreateOrConnectWithoutBonsRegieInput = {
    where: ChantierWhereUniqueInput
    create: XOR<ChantierCreateWithoutBonsRegieInput, ChantierUncheckedCreateWithoutBonsRegieInput>
  }

  export type ChantierUpsertWithoutBonsRegieInput = {
    update: XOR<ChantierUpdateWithoutBonsRegieInput, ChantierUncheckedUpdateWithoutBonsRegieInput>
    create: XOR<ChantierCreateWithoutBonsRegieInput, ChantierUncheckedCreateWithoutBonsRegieInput>
    where?: ChantierWhereInput
  }

  export type ChantierUpdateToOneWithWhereWithoutBonsRegieInput = {
    where?: ChantierWhereInput
    data: XOR<ChantierUpdateWithoutBonsRegieInput, ChantierUncheckedUpdateWithoutBonsRegieInput>
  }

  export type ChantierUpdateWithoutBonsRegieInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    client?: ClientUpdateOneWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutBonsRegieInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type CommandeSousTraitantCreateManySoustraitantInput = {
    id?: number
    chantierId: string
    dateCommande?: Date | string
    reference?: string | null
    tauxTVA?: number
    sousTotal?: number
    tva?: number
    total?: number
    statut?: string
    estVerrouillee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type contratCreateManySoustraitantInput = {
    id?: string
    url: string
    dateGeneration?: Date | string
    dateSignature?: Date | string | null
    estSigne?: boolean
    token?: string | null
  }

  export type soustraitant_etat_avancementCreateManySoustraitantInput = {
    id?: number
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
    etatAvancementId: number
  }

  export type CommandeSousTraitantUpdateWithoutSoustraitantInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandeSousTraitantUpdateManyWithoutCommandeSousTraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUpdateManyWithoutCommande_soustraitantNestedInput
  }

  export type CommandeSousTraitantUncheckedUpdateWithoutSoustraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandeSousTraitantUncheckedUpdateManyWithoutCommandeSousTraitantNestedInput
    soustraitant_etat_avancement?: soustraitant_etat_avancementUncheckedUpdateManyWithoutCommande_soustraitantNestedInput
  }

  export type CommandeSousTraitantUncheckedUpdateManyWithoutSoustraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tauxTVA?: FloatFieldUpdateOperationsInput | number
    sousTotal?: FloatFieldUpdateOperationsInput | number
    tva?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    statut?: StringFieldUpdateOperationsInput | string
    estVerrouillee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contratUpdateWithoutSoustraitantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratUncheckedUpdateWithoutSoustraitantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratUncheckedUpdateManyWithoutSoustraitantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estSigne?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type soustraitant_etat_avancementUpdateWithoutSoustraitantInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    commande_soustraitant?: CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput
    etat_avancement?: EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    etatAvancementId?: IntFieldUpdateOperationsInput | number
  }

  export type LigneCommandeCreateManyCommandeInput = {
    id?: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    estOption?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneCommandeUpdateWithoutCommandeInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeUncheckedUpdateManyWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    estOption?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantEtatAvancementCreateManyEtatAvancementInput = {
    id?: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneEtatAvancementCreateManyEtatAvancementInput = {
    id?: number
    ligneCommandeId: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    description: string
    prixUnitaire: number
    quantite: number
    type: string
    unite: string
  }

  export type soustraitant_etat_avancementCreateManyEtat_avancementInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commandeSousTraitantId?: number | null
  }

  export type AvenantEtatAvancementUpdateWithoutEtatAvancementInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantEtatAvancementUncheckedUpdateWithoutEtatAvancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantEtatAvancementUncheckedUpdateManyWithoutEtatAvancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatAvancementUpdateWithoutEtatAvancementInput = {
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
  }

  export type LigneEtatAvancementUncheckedUpdateWithoutEtatAvancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
  }

  export type LigneEtatAvancementUncheckedUpdateManyWithoutEtatAvancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    ligneCommandeId?: IntFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
  }

  export type soustraitant_etat_avancementUpdateWithoutEtat_avancementInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    commande_soustraitant?: CommandeSousTraitantUpdateOneWithoutSoustraitant_etat_avancementNestedInput
    soustraitant?: soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateWithoutEtat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyWithoutEtat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandeSousTraitantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LigneCommandeSousTraitantCreateManyCommandeSousTraitantInput = {
    id?: number
    ordre: number
    article: string
    description: string
    type?: string
    unite: string
    prixUnitaire: number
    quantite: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type soustraitant_etat_avancementCreateManyCommande_soustraitantInput = {
    id?: number
    soustraitantId: string
    numero: number
    date?: Date | string
    commentaires?: string | null
    estFinalise?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    etatAvancementId: number
  }

  export type LigneCommandeSousTraitantUpdateWithoutCommandeSousTraitantInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeSousTraitantUncheckedUpdateWithoutCommandeSousTraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandeSousTraitantUncheckedUpdateManyWithoutCommandeSousTraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soustraitant_etat_avancementUpdateWithoutCommande_soustraitantInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    etat_avancement?: EtatAvancementUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
    soustraitant?: soustraitantUpdateOneRequiredWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateWithoutCommande_soustraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etatAvancementId?: IntFieldUpdateOperationsInput | number
    avenant_soustraitant_etat_avancement?: avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    ligne_soustraitant_etat_avancement?: ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
    photos?: photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementNestedInput
  }

  export type soustraitant_etat_avancementUncheckedUpdateManyWithoutCommande_soustraitantInput = {
    id?: IntFieldUpdateOperationsInput | number
    soustraitantId?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    estFinalise?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etatAvancementId?: IntFieldUpdateOperationsInput | number
  }

  export type avenant_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput = {
    id?: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ligne_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput = {
    id?: number
    article: string
    description: string
    type: string
    unite: string
    prixUnitaire: number
    quantite: number
    quantitePrecedente?: number
    quantiteActuelle?: number
    quantiteTotale?: number
    montantPrecedent?: number
    montantActuel?: number
    montantTotal?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type photo_soustraitant_etat_avancementCreateManySoustraitant_etat_avancementInput = {
    id?: number
    url: string
    description?: string | null
    dateAjout?: Date | string
  }

  export type avenant_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avenant_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type avenant_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ligne_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput = {
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ligne_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ligne_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    quantitePrecedente?: FloatFieldUpdateOperationsInput | number
    quantiteActuelle?: FloatFieldUpdateOperationsInput | number
    quantiteTotale?: FloatFieldUpdateOperationsInput | number
    montantPrecedent?: FloatFieldUpdateOperationsInput | number
    montantActuel?: FloatFieldUpdateOperationsInput | number
    montantTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photo_soustraitant_etat_avancementUpdateWithoutSoustraitant_etat_avancementInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photo_soustraitant_etat_avancementUncheckedUpdateWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type photo_soustraitant_etat_avancementUncheckedUpdateManyWithoutSoustraitant_etat_avancementInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmplacementCreateManyRackInput = {
    id?: string
    ligne: number
    colonne: number
    codeQR: string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmplacementUpdateWithoutRackInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiaux?: MateriauUpdateManyWithoutEmplacementNestedInput
  }

  export type EmplacementUncheckedUpdateWithoutRackInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiaux?: MateriauUncheckedUpdateManyWithoutEmplacementNestedInput
  }

  export type EmplacementUncheckedUpdateManyWithoutRackInput = {
    id?: StringFieldUpdateOperationsInput | string
    ligne?: IntFieldUpdateOperationsInput | number
    colonne?: IntFieldUpdateOperationsInput | number
    codeQR?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauCreateManyEmplacementInput = {
    id?: string
    nom: string
    description?: string | null
    quantite?: number
    codeQR?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MateriauUpdateWithoutEmplacementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauUncheckedUpdateWithoutEmplacementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MateriauUncheckedUpdateManyWithoutEmplacementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantite?: IntFieldUpdateOperationsInput | number
    codeQR?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantCreateManyChantierInput = {
    id?: number
    numero: number
    date?: Date | string
    description?: string | null
    marcheId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentCreateManyChantierInput = {
    id?: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EtatCreateManyChantierInput = {
    id?: number
    numero: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NoteCreateManyChantierInput = {
    id?: number
    contenu: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TacheCreateManyChantierInput = {
    id: string
    label: string
    completed?: boolean
    completedAt?: Date | string | null
    category: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type admintaskCreateManyChantierInput = {
    id?: number
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
  }

  export type BonRegieCreateManyChantierInput = {
    id?: number
    dates: string
    client: string
    nomChantier: string
    description: string
    tempsPreparation?: number | null
    tempsTrajets?: number | null
    tempsChantier?: number | null
    nombreTechniciens?: number | null
    materiaux: string
    nomSignataire: string
    signature: string
    dateSignature: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvenantUpdateWithoutChantierInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Marche?: MarcheUpdateOneRequiredWithoutAvenantNestedInput
  }

  export type AvenantUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    marcheId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantUncheckedUpdateManyWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    marcheId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutChantierInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    User?: UserUpdateOneRequiredWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentUncheckedUpdateManyWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EtatUpdateWithoutChantierInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LigneEtat?: LigneEtatUpdateManyWithoutEtatNestedInput
  }

  export type EtatUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LigneEtat?: LigneEtatUncheckedUpdateManyWithoutEtatNestedInput
  }

  export type EtatUncheckedUpdateManyWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutChantierInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacheUpdateWithoutChantierInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacheUncheckedUpdateWithoutChantierInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacheUncheckedUpdateManyWithoutChantierInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admintaskUpdateWithoutChantierInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAdmintaskNestedInput
  }

  export type admintaskUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admintaskUncheckedUpdateManyWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BonRegieUpdateWithoutChantierInput = {
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonRegieUncheckedUpdateWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonRegieUncheckedUpdateManyWithoutChantierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dates?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tempsPreparation?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsTrajets?: NullableFloatFieldUpdateOperationsInput | number | null
    tempsChantier?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreTechniciens?: NullableIntFieldUpdateOperationsInput | number | null
    materiaux?: StringFieldUpdateOperationsInput | string
    nomSignataire?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChantierCreateManyClientInput = {
    id?: number
    chantierId: string
    nomChantier: string
    adresseChantier?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    budget?: number | null
    dateDebut?: Date | string | null
    dateFinPrevue?: Date | string | null
    dateFinReelle?: Date | string | null
    description?: string | null
    statut?: string
    villeChantier?: string | null
    dureeEnJours?: number | null
    typeDuree?: string
  }

  export type ChantierUpdateWithoutClientInput = {
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUpdateManyWithoutChantierNestedInput
    documents?: DocumentUpdateManyWithoutChantierNestedInput
    etats?: EtatUpdateManyWithoutChantierNestedInput
    marches?: MarcheUpdateOneWithoutChantierNestedInput
    notes?: NoteUpdateManyWithoutChantierNestedInput
    taches?: TacheUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
    avenants?: AvenantUncheckedUpdateManyWithoutChantierNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutChantierNestedInput
    etats?: EtatUncheckedUpdateManyWithoutChantierNestedInput
    marches?: MarcheUncheckedUpdateOneWithoutChantierNestedInput
    notes?: NoteUncheckedUpdateManyWithoutChantierNestedInput
    taches?: TacheUncheckedUpdateManyWithoutChantierNestedInput
    admintasks?: admintaskUncheckedUpdateManyWithoutChantierNestedInput
    bonsRegie?: BonRegieUncheckedUpdateManyWithoutChantierNestedInput
  }

  export type ChantierUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    nomChantier?: StringFieldUpdateOperationsInput | string
    adresseChantier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinPrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    villeChantier?: NullableStringFieldUpdateOperationsInput | string | null
    dureeEnJours?: NullableIntFieldUpdateOperationsInput | number | null
    typeDuree?: StringFieldUpdateOperationsInput | string
  }

  export type LigneEtatCreateManyEtatInput = {
    id?: number
    ligneMarcheId: number
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneEtatUpdateWithoutEtatInput = {
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LigneMarche?: LigneMarcheUpdateOneRequiredWithoutLigneEtatNestedInput
  }

  export type LigneEtatUncheckedUpdateWithoutEtatInput = {
    id?: IntFieldUpdateOperationsInput | number
    ligneMarcheId?: IntFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatUncheckedUpdateManyWithoutEtatInput = {
    id?: IntFieldUpdateOperationsInput | number
    ligneMarcheId?: IntFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatCreateManyLigneMarcheInput = {
    id?: number
    etatId: number
    quantite: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneEtatUpdateWithoutLigneMarcheInput = {
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Etat?: EtatUpdateOneRequiredWithoutLigneEtatNestedInput
  }

  export type LigneEtatUncheckedUpdateWithoutLigneMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatId?: IntFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneEtatUncheckedUpdateManyWithoutLigneMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    etatId?: IntFieldUpdateOperationsInput | number
    quantite?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pretCreateManyMachineInput = {
    id: string
    userId: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
  }

  export type pretUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPretNestedInput
  }

  export type pretUncheckedUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }

  export type pretUncheckedUpdateManyWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }

  export type AvenantCreateManyMarcheInput = {
    id?: number
    numero: number
    date?: Date | string
    description?: string | null
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LigneMarcheCreateManyMarcheInput = {
    id?: number
    article: number
    descriptif: string
    unite: string
    quantite: number
    prixUnitaire: number
  }

  export type AvenantUpdateWithoutMarcheInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutAvenantsNestedInput
  }

  export type AvenantUncheckedUpdateWithoutMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvenantUncheckedUpdateManyWithoutMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneMarcheUpdateWithoutMarcheInput = {
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    LigneEtat?: LigneEtatUpdateManyWithoutLigneMarcheNestedInput
  }

  export type LigneMarcheUncheckedUpdateWithoutMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    LigneEtat?: LigneEtatUncheckedUpdateManyWithoutLigneMarcheNestedInput
  }

  export type LigneMarcheUncheckedUpdateManyWithoutMarcheInput = {
    id?: IntFieldUpdateOperationsInput | number
    article?: IntFieldUpdateOperationsInput | number
    descriptif?: StringFieldUpdateOperationsInput | string
    unite?: StringFieldUpdateOperationsInput | string
    quantite?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
  }

  export type DocumentOuvrierCreateManyOuvrierInput = {
    id: string
    nom: string
    type: string
    url: string
    dateExpiration?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentOuvrierUpdateWithoutOuvrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentOuvrierUncheckedUpdateWithoutOuvrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentOuvrierUncheckedUpdateManyWithoutOuvrierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyUserInput = {
    id?: number
    nom: string
    type: string
    url: string
    taille: number
    mimeType: string
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateManyUserInput = {
    id?: number
    chantierId: string
    contenu: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type admintaskCreateManyUserInput = {
    id?: number
    chantierId: string
    createdAt?: Date | string
    updatedAt: Date | string
    completed?: boolean
    completedAt?: Date | string | null
    taskType: string
    title?: string | null
  }

  export type pretCreateManyUserInput = {
    id: string
    machineId: string
    datePret?: Date | string
    dateRetourPrevue: Date | string
    dateRetourEffective?: Date | string | null
    statut?: $Enums.pret_statut
    commentaire?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    emprunteur: string
  }

  export type DocumentUpdateWithoutUserInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    chantier?: ChantierUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    taille?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUpdateWithoutUserInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Chantier?: ChantierUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admintaskUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    chantier?: ChantierUpdateOneRequiredWithoutAdmintasksNestedInput
  }

  export type admintaskUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admintaskUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chantierId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pretUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
    machine?: MachineUpdateOneRequiredWithoutPretNestedInput
  }

  export type pretUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }

  export type pretUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    datePret?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourPrevue?: DateTimeFieldUpdateOperationsInput | Date | string
    dateRetourEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: Enumpret_statutFieldUpdateOperationsInput | $Enums.pret_statut
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprunteur?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}